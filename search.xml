<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap</title>
    <url>/2020/10/26/HashMap/</url>
    <content><![CDATA[<h4 id="map实现类之一hashmap">Map实现类之一：HashMap</h4>
<ul>
<li>所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()</li>
<li>所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的类要重写：equals()</li>
</ul>
<a id="more"></a>
<ul>
<li>一个key-value构成一个entry</li>
<li>所有的entry构成的集合是Set:无序的、不可重复的</li>
<li>HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。</li>
<li>HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。</li>
</ul>
<h5 id="hashmap的存储结构">HashMap的存储结构</h5>
<p><strong>数组+链表 （jdk7及之前）</strong></p>
<p><img src="https://img-blog.csdn.net/20131105152215718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdmtpbmdfd2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom:67%;" /></p>
<p><strong>数组+链表+红黑树 （jdk 8）</strong></p>
<p><img src="https://img-blog.csdn.net/20170803204952538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG9naW5fc29uYXRh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="存储结构" style="zoom:67%;" /></p>
<h5 id="hashmap添加元素的过程">HashMap添加元素的过程</h5>
<p>HashMap map=new HashMap();</p>
<p>实例化后底层创建了长度是<strong>16</strong>的一维数组Entry[] table。这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
<p>每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。</p>
<p>...可能已经多次put...</p>
<p>map.put(key1,value1):</p>
<ol type="1">
<li><p>调用key1所在类的HashCode()方法计算key1的哈希值</p></li>
<li><p>此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置</p>
<p>1).如果此位置上的数据为空，此时的key1-value1（即entyr1）添加成功。 ----&gt;情况1</p>
<p>2).如果此位置已存在一个或多个数据（以链表形式存在），比较key1和已存在数据的哈希值</p>
<ul>
<li>key1的哈希值与已存在数据的哈希值都不相同，添加成功。 ----&gt;情况2</li>
<li>key1的哈希值与key2的哈希值相同，调用key1所在类的equals()方法
<ul>
<li>equals()返回false：此时key1-value1添加成功。 ---&gt;情况3</li>
<li>equals()返回true：value1替换value2</li>
</ul></li>
</ul></li>
</ol>
<ul>
<li><p>对于情况2、3添加成功的元素a与已存在的元素以链表形式存储—7上8下</p>
<figure>
<img src="https://user-gold-cdn.xitu.io/2018/12/21/167cf3bc3724604a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /><figcaption>img</figcaption>
</figure></li>
</ul>
<h5 id="hashmap的扩容">HashMap的扩容</h5>
<h6 id="jdk7及以前">jdk7及以前</h6>
<ul>
<li><pre><code> DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</code></pre></li>
<li><pre><code> DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</code></pre></li>
<li><pre><code> threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12</code></pre></li>
<li><pre><code> TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</code></pre></li>
<li><pre><code> MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</code></pre></li>
</ul>
<p>​ 当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的默认值 (DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么<strong>当HashMap中元素个数超过<span class="math inline">\(16*0.75 = 12\)</span>（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 <span class="math inline">\(2*16=32\)</span>，即扩大一倍</strong>，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>
<h6 id="jdk8">jdk8</h6>
<p>相较于jdk7在底层实现方面的不同：</p>
<ol type="1">
<li><p>new HashMap():底层没有创建一个长度为16的数组</p></li>
<li><p>jdk 8底层的数组是：<strong>Node[]</strong>,而非Entry[]</p></li>
<li><p>首次调用put()方法时，底层创建长度为16的数组</p></li>
<li><p>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</p>
<p>4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素） 4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</p></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo攻略-添加分类</title>
    <url>/2020/10/27/Hexo%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h2 id="hexo攻略-添加分类">Hexo攻略-添加分类</h2>
<h3 id="创建分类选项">1.创建“分类”选项</h3>
<p>在命令窗口输入下方命令</p>
<blockquote>
<p>hexo new page categories</p>
</blockquote>
<a id="more"></a>
<p>/source/categories文件夹下会有index.md文件，打开后内容默认为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-10-26 19:47:40</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>添加type: categories到内容中，添加后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2019-04-24 15:30:30</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<h3 id="新建文章并添加categories属性">2.新建文章并添加“categories”属性</h3>
<p>在命令行输入下方命令创建新文章</p>
<blockquote>
<p>hexo n &quot;新文章名称&quot;</p>
</blockquote>
<p>在/source/_posts下自动生成.md文件，打开为其添加categories属性。下方的categories:Hexo攻略，表示这篇文章添加到到“Hexo攻略”这个分类。注意：一篇文章只会添加到一个分类中，如果是多个默认放到第一个分类中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Hexo攻略-添加分类及标签</span><br><span class="line">date: 2020-10-27 15:22:42</span><br><span class="line">categories: Hexo攻略</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“分类”即可看到该分类下的所有文章。效果如图。</p>
<p><img src="/images/cate.jpg" /></p>
]]></content>
      <categories>
        <category>Hexo攻略</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo攻略-更换网页图标</title>
    <url>/2020/10/28/Hexo%E6%94%BB%E7%95%A5-%E6%9B%B4%E6%8D%A2%E7%BD%91%E9%A1%B5%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<h2 id="hexo攻略更改网页图标">Hexo攻略—更改网页图标</h2>
<p>Hexo next主题默认的网页图标长这个样子~</p>
<p><img src="/images/icon1.PNG" /></p>
<p>当然要和别人不一样！</p>
<a id="more"></a>
<h4 id="下载图标">下载图标</h4>
<p>自己也可以绘制，懒得话就去下载，到<a href="https://www.easyicon.net/">这里</a>进行下载，<code>ico</code>文件和<code>png</code>都可以，我下载的是<code>ico</code></p>
<h4 id="修改文件名">修改文件名</h4>
<p>下载的图标重命名为<code>favicon.ico</code>，位置放在<code>/themes/next/source/images</code></p>
<h4 id="修改主题配置文件">修改主题配置文件</h4>
<p>在<code>/themes/next/_config.yml</code>中修改成自己的图标</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;favicon.ico</span><br><span class="line">  #medium: &#x2F;images&#x2F;favicon-32x32-next.png</span><br><span class="line">  medium: &#x2F;images&#x2F;favicon.ico</span><br><span class="line">  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: &#x2F;images&#x2F;logo.svg</span><br><span class="line">  #android_manifest: &#x2F;manifest.json</span><br></pre></td></tr></table></figure>
<p>进入测试上传就好啦~</p>
<p>效果图<img src="/images/icon2.PNG" /></p>
]]></content>
      <categories>
        <category>Hexo攻略</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo攻略-去除代码块的行序列号</title>
    <url>/2020/11/16/Hexo%E6%94%BB%E7%95%A5-%E5%8E%BB%E9%99%A4%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="hexo攻略去除代码块的行序列号">Hexo攻略—去除代码块的行序列号</h1>
<p>Hexo博客Next主题默认的代码块是标有行序列号的，看代码时会有些干扰，怎么将它去除呢？</p>
<a id="more"></a>
<p><img src="/images/hexo1.PNG" alt="在这里插入图片描述" /> 其实很简单，但我找了好久才找到，现在分享给大家！在<strong>配置文件</strong>-config.yml中，找到highlight，并将line_number：true改为false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: false</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace: &#39;&#39;</span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br></pre></td></tr></table></figure>
<p>最终效果： <img src="/images/hexo行.PNG" /> 这样代码看着就清爽许多了~</p>
]]></content>
      <categories>
        <category>Hexo攻略</category>
      </categories>
  </entry>
  <entry>
    <title>Java-Scanner类</title>
    <url>/2020/11/28/Java-Scanner%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="java-scanner类">Java Scanner类</h2>
<ul>
<li><p>用于获取用户输入 语法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure></p></li>
<li><p>可通过调用下列函数<code>nextDouble()</code>，<code>nextFloat</code>，<code>nextInt()</code>，<code>nextLine()</code>，<code>nextLong()</code>，<code>nextShot()</code>读取用户在命令行输入的各种数据类型　</p></li>
<li><p>next()与nextLine()区别：</p>
<p><a id="more"></a></p>
<ul>
<li>next() :</li>
</ul>
<ol type="1">
<li>一定要读到有效字符结束输入</li>
<li>对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li>
<li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li>
<li>next() 不能得到带有空格的字符串。 总之就是<strong>遇到空格停止扫描</strong></li>
</ol>
<ul>
<li>nextLine()：</li>
</ul>
<ol type="1">
<li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li>
<li>可以获得空白。 总之就是<strong>以回车为停止扫描</strong></li>
</ol></li>
</ul>
<p>举例： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;输入：&quot;</span>);</span><br><span class="line">String s = sc.next();<span class="comment">//Hello World!</span></span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure> 测试效果： <img src="https://img-blog.csdnimg.cn/20201127160744149.png" alt="在这里插入图片描述" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;输入：&quot;</span>);</span><br><span class="line">String s = sc.nextLine();<span class="comment">//Hello World!</span></span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>
<p>测试效果： <img src="https://img-blog.csdnimg.cn/20201127160901915.png" alt="在这里插入图片描述" /></p>
<ul>
<li><p>控制台输入一个可变长度数组 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String[] strArray = <span class="keyword">null</span>;</span><br><span class="line">strArray = sc.nextLine().split(<span class="string">&quot;\\s*,\\s*&quot;</span>);  <span class="comment">// &#x27;,&#x27;分割，前后可以有空格</span></span><br><span class="line"><span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[strArray.length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; strArray.length; i++) &#123;</span><br><span class="line">    intArray[i] = Integer.parseInt(strArray[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>控制台输入一个二维数组 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> System.out.print(<span class="string">&quot;二维数组的行数：&quot;</span>);</span><br><span class="line"> <span class="keyword">int</span> r = sc.nextInt();</span><br><span class="line"> System.out.println(<span class="string">&quot;二维数组的列数：&quot;</span>);</span><br><span class="line"> <span class="keyword">int</span> c = sc.nextInt();</span><br><span class="line"> <span class="keyword">int</span>[][]matrix = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line"> sc.nextLine();<span class="comment">//用来跳过行列后的回车符</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++)&#123;</span><br><span class="line">         matrix[i][j] = sc.nextInt();</span><br><span class="line">         System.out.print(matrix[i][j] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> 测试效果： <img src="https://img-blog.csdnimg.cn/20201128205414284.PNG" alt="在这里插入图片描述" /></p></li>
</ul>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Scanner类</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo攻略-设置分页与显示文章数</title>
    <url>/2020/10/29/Hexo%E6%94%BB%E7%95%A5-%E8%AE%BE%E7%BD%AE%E5%88%86%E9%A1%B5%E4%B8%8E%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%95%B0/</url>
    <content><![CDATA[<h2 id="hexo攻略-设置分页与显示文章数">Hexo攻略-设置分页与显示文章数</h2>
<p>使用next主题下，默认首页、分类、标签页都是显示10个文章，想进行分页和设置显示文章数。按照以下步骤操作~</p>
<a id="more"></a>
<ul>
<li><p>在Git Bash下安装插件</p>
<blockquote>
<p>$ npm install hexo-generator-index --save</p>
</blockquote>
<blockquote>
<p>$ npm install hexo-generator-archive -- save</p>
</blockquote>
<blockquote>
<p>$ npm install hexo-generator-tag --save</p>
</blockquote></li>
<li><p>在主题配置文件<code>_config.yml</code>中修改</p></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Algolia Search</span><br><span class="line"># For more information: https:&#x2F;&#x2F;www.algolia.com</span><br><span class="line">algolia_search:</span><br><span class="line">  enable: false</span><br><span class="line">  hits:</span><br><span class="line">    per_page: 5</span><br><span class="line"></span><br><span class="line">#主页每页显示文章数</span><br><span class="line">index_generator:</span><br><span class="line">    per_page: 5</span><br><span class="line">#archive分页每页显示文章数</span><br><span class="line">archive_generator:</span><br><span class="line">    per_page: 5</span><br><span class="line">#tag分页每页显示文章数</span><br><span class="line">tag_generator:</span><br><span class="line">    per_page: 10</span><br><span class="line">#category分页每页显示文章数</span><br><span class="line">category_generator: </span><br><span class="line">    per_page: 10</span><br></pre></td></tr></table></figure>
<p>按照以上步骤操作，保证一次就能修改好啦！</p>
<p>实现分页效果如图</p>
<p><img src="/images/分页.PNG" /></p>
]]></content>
      <categories>
        <category>Hexo攻略</category>
      </categories>
  </entry>
  <entry>
    <title>Java动态代理</title>
    <url>/2020/11/26/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="java动态代理">Java动态代理</h1>
<h2 id="引言">引言</h2>
<p>因为在学习Spring AOP，其中用到了Java动态代理机制，所以好好把动态代理模式梳理了一遍。</p>
<h2 id="代理设计模式">代理设计模式</h2>
<ul>
<li>原理：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</li>
</ul>
<a id="more"></a>
<ul>
<li>静态代理弊端：只能一个代理类实现一个接口，如果接口中的还有未实现的方法时，代理类也要必须实现。同时会产生大量重复的代码。</li>
<li><p>动态代理：通过反射机制实现动态代理（利用java.lang.reflect.InvocationHandler与java.lang.reflect.Proxy），抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理。</p></li>
<li><p>结构示意图：</p></li>
</ul>
<p><img src="/images/proxy.png" /></p>
<p>代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。</p>
<h2 id="java-动态代理相关api">Java 动态代理相关API</h2>
<p>Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：</p>
<p>（1）Interface InvocationHandler：调用处理器接口，该接口中仅定义了一个invoke方法，用于集中处理在动态代理类实例上的方法调用，通常在该方法中实现对实现类的代理访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象</span><br><span class="line">&#x2F;&#x2F; 第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上发射执行</span><br><span class="line">public object invoke(Object obj,Method method, Object[] args)</span><br></pre></td></tr></table></figure>
<p>每次生成动态代理类实例时都需要指定一个实现了该接口的调用处理器对象。</p>
<p>（2）Proxy：该类即为<strong>动态代理类</strong>，提供了一组静态方法来为一组接口动态地生成代理类及其实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Proxy的静态方法</span></span><br><span class="line"><span class="comment">// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 2：该方法用于获取关联于指定类装载器和一组接口的 动态代理类的类对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">getProxyClass</span><span class="params">(ClassLoader loader, Class[] interfaces)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 3：该方法用于判断指定类对象是否是一个动态代理类</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class cl)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器 创建一个动态代理对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class[] interfaces, </span></span></span><br><span class="line"><span class="function"><span class="params">    InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="代理机制">代理机制</h2>
<h4 id="动态代理步骤">动态代理步骤：</h4>
<ol type="1">
<li>创建一个实现接口InvocationHandler的类，它必须实现invoke方法</li>
<li>创建被代理的类以及接口</li>
<li>通过Proxy的静态方法newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理</li>
<li>通过代理实现类的方法</li>
</ol>
<h4 id="实例">实例：</h4>
<ol type="1">
<li><p>需要动态代理的接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Human&#123;</span><br><span class="line"></span><br><span class="line">    String getBelief();</span><br><span class="line"></span><br><span class="line">    void eat(String food);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>被代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>根据被代理类，动态的<strong>创建一个代理类及其对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法，返回一个代理类的对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span></span>&#123;<span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line"></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代理类的对象调用方法a时，动态调用<strong>被代理类的同名方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//需要使用被代理类的对象进行赋值，使用方法或构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法(创建代理类对象时传参handler)</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        Object returnValue = method.invoke(obj,args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中的invoke()的返回值。</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperMan superMan = <span class="keyword">new</span> SuperMan();</span><br><span class="line">        <span class="comment">//proxyInstance:代理类的对象</span></span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        String belief = proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;四川麻辣烫&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的值传递机制</title>
    <url>/2020/10/27/Java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>Java中方法的值传递方式只有一种：值传递。</strong></p>
<a id="more"></a>
<p>值传递机制：</p>
<ul>
<li>如果参数是基本数据类型，此时实参赋给形参的是<strong>实参真实存储的数据值</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line">     System.out.println(<span class="string">&quot;排序前：&quot;</span>+<span class="string">&quot;a=&quot;</span>+a+<span class="string">&quot;,b=&quot;</span>+b);</span><br><span class="line">     valueTransferTest t=<span class="keyword">new</span> valueTransferTest();</span><br><span class="line">     t.swap(a,b);</span><br><span class="line">     System.out.println(<span class="string">&quot;排序后：&quot;</span>+<span class="string">&quot;a=&quot;</span>+a+<span class="string">&quot;,b=&quot;</span>+b);<span class="comment">//a = 10,b = 20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> temp=m;</span><br><span class="line">     m=n;</span><br><span class="line">     n=temp;</span><br><span class="line">     <span class="comment">// System.out.println(&quot;m=&quot;+m+&quot;,n=&quot;+n);//m = 20, n = 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实参a,b将值传给形参，排序后a,b的值未发生改变，对实参值没有影响。</p>
<p>内存中</p>
<p><img src="/images/image_1.jpg" /></p>
<ul>
<li>如果参数是引用数据类型，此时实参赋给形参的是<strong>实参存储数据的地址值</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	 Data data = <span class="keyword">new</span> Data();</span><br><span class="line">		</span><br><span class="line">	 data.m = <span class="number">10</span>; data.n = <span class="number">20</span>;</span><br><span class="line">		</span><br><span class="line">	 System.out.println(<span class="string">&quot;m = &quot;</span> + data.m + <span class="string">&quot;, n = &quot;</span> + data.n);<span class="comment">//m = 10, n = 20</span></span><br><span class="line">	 swap(data);</span><br><span class="line">     System.out.println(<span class="string">&quot;m = &quot;</span> + data.m + <span class="string">&quot;, n = &quot;</span> + data.n);<span class="comment">//m = 20, n = 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Data data)</span></span>&#123;</span><br><span class="line">	 <span class="keyword">int</span> temp = data.m;</span><br><span class="line">	 data.m = data.n;</span><br><span class="line">	 data.n = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存中显示</p>
<p><img src="/images/image_2.jpg" /></p>
<p>参数保存的是实际对象的地址值，改变的只是地址值指向的堆内存中的实际对象，<strong>并没有真正改变参数</strong>，<strong>参数的地址值没有变</strong>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现单链表与循环链表</title>
    <url>/2020/10/29/Java%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表的引入">链表的引入</h2>
<h3 id="数组和链表的对比">数组和链表的对比</h3>
<ul>
<li><p>数组：</p>
<p>访问数组时，其实是利用指针，即内存地址，直接访问对应内存地址中的数值，所以访问速度非常快。查找复杂度：<strong>O(1)</strong></p>
<a id="more"></a>
<p>添加元素时，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。删除一个元素，同样需要移动大量元素去填掉被移动的元素。添加/删除元素的时间复杂度： <strong>O(n)</strong></p></li>
<li><p>链表：</p>
<p>链表与数组相反，链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。第一个元素指向第二个，以此类推直到最后一个元素。所以查找链表中某一个元素就要从第一个元素开始找，一直到找到需要的元素。 查找复杂度：<strong>O(n)</strong></p>
<p>但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改相应位置前后元素中的指针就可以了。复杂度：<strong>O(1)</strong></p>
<p>添加node：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">node.next = pre.next;</span><br><span class="line">pre.next = node;</span><br></pre></td></tr></table></figure>
<p>删除node：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pre.next = node.next;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="单链表">单链表</h3>
<p>​ 单向链表是一种线性表，实际上是由节点（Node）组成的，一个链表拥有不定数量的节点。head为头节点，他不存放任何的数据，只是充当一个指向链表中真正存放数据的第一个节点的作用，而每个节点中都有一个next引用，指向下一个节点，就这样一节一节往下面记录，直到最后一个节点，其中的next指向null。</p>
<p><img src="/images/链表1.png" /></p>
<p>代码实现（已定义<code>Node head</code>）</p>
<ul>
<li><p>其他功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取链表长度</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2020/10/29</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *获取指定位置的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/10/29</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> &amp;&amp; index &gt;= getLength())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head;<span class="comment">//从头遍历找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getLength(); i++, temp = temp.next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == index)&#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *判断链表是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/10/29</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *打印链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/10/29</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(temp.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>增加节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">        head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.next = node;</span><br><span class="line">    node.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> l = getLength();</span><br><span class="line">    l++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>插入节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *在指定位置插入节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index,Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> &amp;&amp; index &gt;= getLength()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        head = node;</span><br><span class="line">        node.next = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1 2 3 4 ,length=4</span></span><br><span class="line">    <span class="keyword">if</span>(index &gt; <span class="number">0</span> &amp;&amp; index &lt; length - <span class="number">1</span>)&#123;</span><br><span class="line">        Node pre = getNode(index - <span class="number">1</span>);</span><br><span class="line">        node.next = pre.next;</span><br><span class="line">        pre.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *删除指定位置的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> &amp;&amp; index &gt;= getLength()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除头节点</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        length--;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除尾节点</span></span><br><span class="line">    <span class="keyword">if</span>(index == getLength() - <span class="number">1</span>)&#123;</span><br><span class="line">        Node newEndNode = getNode(getLength() - <span class="number">2</span>);</span><br><span class="line">        newEndNode.next = getNode(index).next;</span><br><span class="line">        length--;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定位置</span></span><br><span class="line">    <span class="keyword">if</span>(index != <span class="number">0</span> &amp;&amp; index != getLength() - <span class="number">1</span>)&#123;</span><br><span class="line">        getNode(index - <span class="number">1</span>).next = getNode(index + <span class="number">1</span>);</span><br><span class="line">        length--;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="循环链表">循环链表</h3>
<p>单链表的尾结点指向 NULL，而循环链表的尾结点指向头结点，构成环状。</p>
<p><img src="/images/循环链表.PNG" /></p>
<p>代码实现：</p>
<ul>
<li><p>其他功能:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定位置的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/10/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNodeByIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从头节点开始遍历链表查找</span></span><br><span class="line">        Node curr = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++,curr = curr.next)</span><br><span class="line">            <span class="keyword">if</span> (i == index)</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定位置元素的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/10/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> &amp;&amp; index &gt;= length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有找到此元素！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> getNodeByIndex(index).val;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印链表全部节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/10/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">             Node temp = head;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                 System.out.print(temp.val+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                 temp = temp.next;</span><br><span class="line">             &#125;</span><br><span class="line">             System.out.println(getVal(length - <span class="number">1</span>));</span><br><span class="line">             System.out.println(<span class="string">&quot;length = &quot;</span>+length);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>添加节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾部添加元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/10/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">            head.next = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Node temp = head;</span><br><span class="line">            <span class="comment">//head后还有节点，继续向后</span></span><br><span class="line">            <span class="keyword">while</span>(temp.next != head)&#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到目前最后一个元素，它指向head。在它后面插入node</span></span><br><span class="line">            temp.next = node;</span><br><span class="line">            node.next = head;</span><br><span class="line">        &#125;</span><br><span class="line">        length++;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定位置添加元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/10/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Node newNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> &amp;&amp; index &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//index = 0,将newNode设为头节点</span></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            newNode.next = head;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//将newNode插入到链表中，先获取前一个和后一个节点</span></span><br><span class="line">            Node pre = getNodeByIndex(index - <span class="number">1</span>);</span><br><span class="line">            newNode.next = pre.next;</span><br><span class="line">            pre.next = newNode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        length++;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/10/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//链表中只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">1</span>)&#123;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            getNodeByIndex(length - <span class="number">1</span>).next = head;</span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除尾节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/10/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">deleteTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//链表中只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">1</span>)&#123;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            getNodeByIndex(length - <span class="number">2</span>).next = head;</span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定位置节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/10/26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">deleteIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> &amp;&amp; index &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有找到该删除元素！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index != <span class="number">0</span> &amp;&amp; index != length -<span class="number">1</span>)&#123;</span><br><span class="line">            getNodeByIndex(index - <span class="number">1</span>).next = getNodeByIndex(index + <span class="number">1</span>);</span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>summary: 原理大概都懂，代码实现上有些细节要注意。讨论头节点是否为null；给定某个位置index，讨论index是否在合理范围内。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—二叉树的遍历</title>
    <url>/2020/12/20/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h4 id="此篇用于梳理二叉树的遍历方式深度优先遍历前中后序遍历和广度优先遍历不仅能快速领会思想和总结规律还可以顺便刷下这些题">此篇用于梳理二叉树的遍历方式：深度优先遍历（前、中、后序遍历）和广度优先遍历，不仅能快速领会思想和总结规律，还可以顺便刷下这些题：</h4>
<p><a href="#LeetCode的94题：二叉树的中序遍历">94，二叉树的中序遍历，medium</a> <a href="#LeetCode的102题：二叉树的层次遍历">102，二叉树的层序遍历，easy</a> <a href="#LeetCode的230题：二叉搜索树中第k小的元素">230，二叉搜索树中第k小的元素，medium</a> <a href="#LeetCode的501题：二叉搜索树中的众数">501，二叉搜索树中的众数，easy</a> <a href="#LeetCode的530题：二叉树搜索树的最小绝对差">530，二叉树搜索树的最小绝对差，easy</a></p>
<p><a href="#LeetCode的530题：二叉树搜索树的最小绝对差">530，二叉树搜索树的最小绝对差，easy</a></p>
<a id="more"></a>
<h2 id="一二叉树的遍历有四种方式">一、二叉树的遍历有四种方式：</h2>
<h5 id="前序遍历根-左-右">1. 前序遍历：根-左-右</h5>
<h5 id="中序遍历左-根-右">2. 中序遍历：左-根-右</h5>
<h5 id="后序遍历左-右-根">3. 后序遍历：左-右-根</h5>
<h5 id="层次遍历bfs-分层存储">4. 层次遍历：BFS + 分层存储</h5>
<p>例如： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">4   5   6</span><br></pre></td></tr></table></figure> - 前序遍历顺序：[1 2 4 5 3 6] （中-左-右） - 中序遍历顺序：[4 2 5 1 3 6] （左-中-右） - 后序遍历顺序：[4 5 2 6 3 1] （右-左-中） - 层次遍历顺序：[1 2 3 4 5 6]</p>
<p>层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性；而前序、中序、后序遍历利用了 DFS 实现。</p>
<p>前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同。</p>
<p>注意：对于<strong>二叉搜索树，常进行中序遍历，其结果由小到大的顺序</strong>有时对解题很有帮助。 ## 二、二叉树遍历的模板 ##### 1. 前序遍历：根-左-右 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    visit(root);</span><br><span class="line">    preorderTraversal(root.left);</span><br><span class="line">    preorderTraversal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##### 2. 中序遍历：左-根-右</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    preorderTraversal(root.left);</span><br><span class="line">    visit(root);</span><br><span class="line">    preorderTraversal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历左-右-根-1">3. 后序遍历：左-右-根</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    preorderTraversal(root.left);</span><br><span class="line">    preorderTraversal(root.right);</span><br><span class="line">    visit(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="层次遍历">4. 层次遍历</h5>
<p>使用【队列】来由上至下由左至右遍历，队列由 LinkedList 实现。</p>
<h2 id="三实现递归与迭代两种方式">三、实现（递归与迭代两种方式）</h2>
<h5 id="前序遍历根-左-右-1">1. 前序遍历：根-左-右</h5>
<h6 id="leetcode的144题二叉树的前序遍历">LeetCode的144题：二叉树的前序遍历</h6>
<p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img" style="zoom:80%;" /></p>
<p>输入：root = [1,null,2,3] 输出：[1,2,3]</p>
<ul>
<li><p>方法一：递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; res  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       dfs(root, res);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       res.add(root.val);</span><br><span class="line">       dfs(root.left, res);</span><br><span class="line">       dfs(root.right, res);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：迭代。借助栈。</p>
<ul>
<li><p>思路： 首先应该创建一个Stack用来存放节点，首先我们想要打印根节点的数据，此时Stack里面的内容为空，所以我们优先将头结点加入Stack，然后打印。</p>
之后应该先打印左子树，然后右子树。所以先加入Stack的就是右子树，然后左子树。 <img src="https://img-blog.csdnimg.cn/20201220215751572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></li>
<li><p>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">     stack.push(root);</span><br><span class="line">     <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">         TreeNode node = stack.pop();</span><br><span class="line">         res.add(node.val);</span><br><span class="line">          <span class="comment">//栈先进后出，为保证左边的子节点先弹出，把右子节点压入栈</span></span><br><span class="line">         <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">         <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<h5 id="中序遍历左-根-右-1">2. 中序遍历：左-根-右</h5>
<h6 id="leetcode的94题二叉树的中序遍历">LeetCode的94题：二叉树的中序遍历</h6>
<ul>
<li>方法一：递归。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       dfs(root, res);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">       <span class="comment">//左中右</span></span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">       dfs(root.left, res);</span><br><span class="line">       res.add(root.val);</span><br><span class="line">       dfs(root.right, res);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>方法二：迭代。
<ul>
<li>思路： 从根节点向左找到最后一个左子节点，并压入栈。弹出栈顶节点，并加入结果集。再找此节点的右子节点，如果为空将弹出根节点。 <img src="https://img-blog.csdnimg.cn/20201220220612254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></li>
<li>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">           <span class="comment">//向左找左子节点</span></span><br><span class="line">           <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//将左子节点入栈</span></span><br><span class="line">               stack.push(root);</span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//找到左子树最后一个左子节点弹出并添加至结果集</span></span><br><span class="line">           root = stack.pop();</span><br><span class="line">           res.add(root.val);</span><br><span class="line">           <span class="comment">//找此节点的右子节点进入上面循环</span></span><br><span class="line">           root = root.right;  </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   ｝</span><br></pre></td></tr></table></figure> ##### 3. 后序遍历：左-右-根 ###### LeetCode的145题：二叉树的后序遍历</li>
</ul></li>
<li>方法一：递归。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       dfs(root, res);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">       <span class="comment">//左右中</span></span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">       dfs(root.left, res);</span><br><span class="line">       dfs(root.right, res);</span><br><span class="line">       res.add(root.val);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>方法二：迭代。前序遍历的结果倒序添加。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(root != <span class="keyword">null</span>) stack.push(root);</span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           TreeNode node = stack.pop();</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">           <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">           </span><br><span class="line">           res.add(<span class="number">0</span>, node.val);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> ##### 4. 层次遍历：BFS遍历 + 分层</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201220214729751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BFS遍历实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">        	<span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            	queue.add(node.left);</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            	queue.add(node.right);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="leetcode的102题二叉树的层次遍历">LeetCode的102题：二叉树的层次遍历</h6>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例： 二叉树：[3,9,20,null,null,15,7],</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre>
<p>返回其层次遍历结果：</p>
<p>[ [3], [9,20], [15,7]]</p>
<ul>
<li>思路：由上面BFS遍历过程，稍加修改，即将每层的节点序列存储到集合temp中，再将每一层添加至<code>List&lt;List&lt;Integer&gt;&gt; res</code>即可</li>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)</span><br><span class="line">            queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将每层添加至结果集</span></span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四二叉搜索树的中序遍历">四、二叉搜索树的中序遍历</h2>
<p>由于<strong>BST树左小右大、中序遍历的结果由小到大</strong>，常利用这一结论来解题。如： ###### LeetCode的230题：二叉搜索树中第k小的元素 给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p>
<p>说明： 你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<ul>
<li>思路：直接应用上面中序遍历的结果，返回 list 的 第 k - 1 个元素即可。
<ul>
<li>递归 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      helper(root, res);       </span><br><span class="line">      <span class="keyword">return</span> res.get(k - <span class="number">1</span>).val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//中序遍历结果</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">      helper(root.left, list);</span><br><span class="line">      list.add(root);</span><br><span class="line">      helper(root.right, list);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>迭代 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">          <span class="comment">//向左找左子节点</span></span><br><span class="line">          <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="comment">//将左子节点入栈</span></span><br><span class="line">              stack.push(root);</span><br><span class="line">              root = root.left;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到左子树最后一个左子节点弹出并添加至结果集</span></span><br><span class="line">          root = stack.pop();</span><br><span class="line">          <span class="comment">//找到第k小的节点</span></span><br><span class="line">          k--;</span><br><span class="line">          <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">          <span class="comment">//找此节点的右子节点进入上面循环</span></span><br><span class="line">          root = root.right;  </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ###### LeetCode的501题：二叉搜索树中的众数 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</li>
</ul></li>
</ul>
<p>假定 BST 有如下定义：</p>
<p>结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树</p>
<p>例如： 给定 BST [1,null,2,2],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>返回[2].</p>
<p>提示：如果众数超过1个，不需考虑输出顺序 - 方法：改造中序遍历。</p>
<ul>
<li><p>思路：</p>
<p>加入全局变量当前节点值<code>curVal</code>，当前节点出现次数<code>count</code>，最大出现的次数<code>maxCount</code></p>
<ul>
<li>如果当前节点值 <code>root.val == curVal</code>，<code>count++</code></li>
<li>如果不等于<code>curVal</code>，说明遇到下一个新的值，更新<code>curVal = root.val</code> ，且 <code>count = 1</code></li>
</ul>
<p>比较 <code>count</code> 与 maxCount</p>
<ul>
<li>如果相等，添加到结果集中</li>
<li>如果<code>count &gt; maxCount</code>，清空结果集，并把节点值 <code>root.val</code> 加入结果集，更新<code>maxCount = count</code> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> curVal;<span class="comment">//当前节点的值</span></span><br><span class="line">  	<span class="keyword">int</span> count;<span class="comment">//cur节点的次数</span></span><br><span class="line"> 	<span class="keyword">int</span> maxCount;<span class="comment">//当前的最大次数</span></span><br><span class="line">  	List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">      	inorder(root);</span><br><span class="line">      	<span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">      	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">          	ans[i] = res.get(i);</span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="keyword">return</span> ans; </span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      	<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">      	inorder(root.left);</span><br><span class="line">  <span class="comment">//如果当前节点值 node.val = cur，count + 1</span></span><br><span class="line">      	<span class="keyword">int</span> rootVal = root.val;</span><br><span class="line">      	<span class="keyword">if</span>(rootVal == curVal)&#123;</span><br><span class="line">          	count++;</span><br><span class="line">      	&#125;</span><br><span class="line">  <span class="comment">// 如果不等于cur，说明遇到下一个新的值，更新cur，且count = 1</span></span><br><span class="line">      	<span class="keyword">else</span>&#123;</span><br><span class="line">          	curVal = rootVal;</span><br><span class="line">          	count = <span class="number">1</span>;</span><br><span class="line">      	&#125;</span><br><span class="line">      <span class="comment">//比较count 与 maxCount</span></span><br><span class="line">  <span class="comment">// 如果相等，添加到结果集中</span></span><br><span class="line">      	<span class="keyword">if</span>(count == maxCount)&#123;</span><br><span class="line">         	res.add(rootVal);</span><br><span class="line">      	&#125;</span><br><span class="line">  <span class="comment">// 如果count &gt; maxCount，清空结果集，并把节点值 node.val 加入结果集，更新maxCount = count</span></span><br><span class="line">      	<span class="keyword">else</span> <span class="keyword">if</span>(count &gt; maxCount)&#123;</span><br><span class="line">          	res.clear();</span><br><span class="line">          	res.add(rootVal);</span><br><span class="line">         	maxCount = count;</span><br><span class="line">     	 &#125;</span><br><span class="line">      	inorder(root.right);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ###### LeetCode的530题：二叉树搜索树的最小绝对差 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</li>
</ul></li>
</ul>
<p>示例： 输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  3</span><br><span class="line"> &#x2F;</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>输出： 1</p>
<p>解释： 最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。 - 方法：改造中序遍历。因为二叉搜索树的中序遍历结果是升序的，我们只需要在中序遍历的时候和前一个节点比较，保存最小的差值即可。建立前一个节点作为全局变量。</p>
<ul>
<li>递归： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  TreeNode pre;<span class="comment">//前一个节点</span></span><br><span class="line">  <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      inorder(root);</span><br><span class="line">      <span class="keyword">return</span> min;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">      inorder(root.left);</span><br><span class="line">      <span class="keyword">if</span>(pre != <span class="keyword">null</span>)</span><br><span class="line">          min = Math.min(min, root.val - pre.val);</span><br><span class="line">      pre = root;<span class="comment">//更新pre到下个节点</span></span><br><span class="line">      inorder(root.right);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>迭代 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">      TreeNode cur = root, prev = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.empty()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">              stack.push(cur);</span><br><span class="line">              cur = cur.left;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              cur = stack.pop();</span><br><span class="line">              <span class="comment">//在这里进行改造</span></span><br><span class="line">              <span class="keyword">if</span> (prev != <span class="keyword">null</span>)</span><br><span class="line">                  min = Math.min(min, cur.val - prev.val);</span><br><span class="line">              prev = cur;</span><br><span class="line">              </span><br><span class="line">              cur = cur.right;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> min;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—BST树的基础操作及套路模板</title>
    <url>/2020/12/16/LeetCode%E5%88%B7%E9%A2%98%E2%80%94BST%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%A5%97%E8%B7%AF%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>本文针对BST 的基础操作：判断 BST 的合法性（<em>98</em>）、增（<em>701</em>）、删（<em>450</em>）、查（<em>700</em>）。以几道题来总结出套路模板，以一敌十！ <a href="#98，验证二叉搜索树，medium">98，验证二叉搜索树，medium</a> <a href="#700，二叉搜索树中的搜索，easy">700，二叉搜索树中的搜索，easy</a> <a href="#701，二叉搜索树中的插入操作，medium">701，二叉搜索树中的插入操作，medium</a> <a href="#450，删除二叉搜索树中的节点，medium">450，删除二叉搜索树中的节点，medium</a></p>
<a id="more"></a>
<h5 id="验证二叉搜索树medium">98，验证二叉搜索树，medium</h5>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法一：递归。</p>
<ul>
<li><p>思路：很容易想到对于节点root，采用递归判断左子节点的值比它小，右子节点的值比它大，但注意：对每个节点都满足也不一定是BST树，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   6</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   7</span><br></pre></td></tr></table></figure>
<p>没有满足右子树的节点都比root值大。</p>
<p>建立辅助函数，增加最小节点min和最大节点max 作为辅助函数的参量。对于root，比较<code>root.val</code>与当前的<code>min.val</code> 和 <code>max.val</code>，再对<code>root.left</code> 和<code>root.right</code> 进行递归操作。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> healper(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是BST树必须满足 min.val &lt; root.val &lt; max.val</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">healper</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(min != <span class="keyword">null</span> &amp;&amp; min.val &gt;= root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(max != <span class="keyword">null</span> &amp;&amp; max.val &lt;= root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//左子树范围的最小值是min.val，最大值是当前节点的值，也就是root的值，因为左子树的值要比当前节点小</span></span><br><span class="line">    <span class="comment">//右子数范围的最大值是max.val，最小值是当前节点的值，也就是root的值，因为右子树的值要比当前节点大</span></span><br><span class="line">        <span class="keyword">return</span> healper(root.left, min, root) &amp;&amp; healper(root.right, root, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>方法二：中序遍历。</p>
<ul>
<li><p>思路：中序遍历的结果是从小到大排序的，建立一个全局遍历<code>pre</code>代表前一个节点，当前节点与前一个节点进行比较。</p>
<ul>
<li><p>递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//中序遍历，代表前一个节点</span></span><br><span class="line">    TreeNode pre;</span><br><span class="line"><span class="comment">//中序遍历，递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 访问左子树</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 访问当前节点，如果不是按照从小到大的顺序，则返回false；否则pre右移，继续比较</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="comment">// 访问右子树</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>迭代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//中序遍历，代表前一个节点</span></span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            pre = root;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>易错点：采用递归方法只与左右子节点比较，但没有保证整棵树是BST树。</p></li>
</ul>
<h5 id="二叉搜索树中的搜索easy">700，二叉搜索树中的搜索，easy</h5>
<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>例如，</p>
<p>给定二叉搜索树:</p>
<pre><code>    4
   / \
  2   7
 / \
1   3</code></pre>
<p>和值: 2 你应该返回如下子树:</p>
<pre><code>  2     
 / \   
1   3</code></pre>
<p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p>
<ul>
<li><p>思路：对于普通二叉树，判断是否存在值为 <code>val</code> 的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val == val) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> search(root.left, val) || search(root.right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于BST树，利用其左小右大的规律，不需要递归地搜索两边，类似二分查找思想，根据<code>val</code>和<code>root.val</code>的大小比较，就能排除一边。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	<span class="keyword">if</span>(root.val == val) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val) <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">         <span class="keyword">if</span>(root.val &gt; val) <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.val == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> val &lt; root.val ? searchBST(root.left, val) : searchBST(root.right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>总结</strong>：BST树遍历搜索的框架为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)&#123;</span><br><span class="line">        <span class="comment">// 找到目标节点，进行具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//目标值target比当前节点值大，在右子树中找</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="comment">//目标值target比当前节点值小，在左子树中找</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="二叉搜索树中的插入操作medium">701，二叉搜索树中的插入操作，medium</h5>
<p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<p>示例 1：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/be940ab2e07119dcd45e5d58370fc5de.png" alt="img" /><figcaption>img</figcaption>
</figure>
<p>输入：root = [4,2,7,1,3], val = 5 输出：[4,2,7,1,3,5] 解释：另一个满足题目要求可以通过的树是：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" alt="img" style="zoom:80%;" /></p>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：</p>
<p>对于函数<code>TreeNode insertIntoBST(TreeNode root, int val)</code>，表示插入值为 <code>val</code> 的节点后的BST树。由上面总结的查找的模板，再加入修改的操作即可。<strong>一旦涉及「改」，函数就要返回<code>TreeNode</code>类型，并且对递归调用的返回值进行接收。</strong></p>
<ul>
<li>方法：递归</li>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查找 + 修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="comment">//val值比当前节点值大，将找个值插入右子树，且赋给root.right</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val) root.right = insertIntoBST(root.right, val);</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val) root.left = insertIntoBST(root.left, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="删除二叉搜索树中的节点medium">450，删除二叉搜索树中的节点，medium</h5>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<p>示例:</p>
<p>root = [5,3,6,2,4,null,7] key = 3</p>
<pre><code>    5
   / \
  3   6
 / \   \
2   4   7</code></pre>
<p>给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</p>
<p>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</p>
<pre><code>    5
   / \
  4   6
 /     \
2       7</code></pre>
<p>另一个正确答案是 [5,2,6,null,4,null,7]。</p>
<pre><code>    5
   / \
  2   6
   \   \
    4   7</code></pre>
<ul>
<li><p>思路：还是<strong>查找 + 修改</strong> 类型，按照上面的遍历框架，写出初步解答：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 找到啦，进行删除</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">       <span class="comment">//一些删除操作</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// key在左子树，对左子树进行删除操作并重新赋给root.left</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// key在右子树，对右子树进行删除操作并重新赋给root.right</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到要删除的节点后，删除操作有下面情况：</p></li>
</ul>
<figure>
<img src="https://img-blog.csdnimg.cn/20201216192138470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<ol type="1">
<li><p>左右子节点有为空的（如12），返回非空的子节点</p>
<p><em>（<code>deleteNode</code> 函数即返回删除值为key的节点后的树）</em></p>
<p>如果左右子节点都为空，则返回null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line"><span class="keyword">if</span>(root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br></pre></td></tr></table></figure></li>
<li><p>左右子节点都不为空，就要找到<strong>左子树的最大值或者右子树的最小值</strong>替换此root，并在左子树（或右子树）删除此节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">root.val = getMaxLeft(root.left).val;</span><br><span class="line">root.left = deleteNode(root.left, root.val);</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//找到了要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">            <span class="comment">//1.有子节点为空</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="comment">//2.子节点非空，则由左子树的最大值或者右子树的最小值替换此root，并在左子树（或右子树）删除此节点</span></span><br><span class="line">            root.val = getMaxLeft(root.left).val;</span><br><span class="line">            root.left = deleteNode(root.left, root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//key在右子树，对右子树进行删除操作，并把新的子树重新赋给root.right</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从root.left出发,找到root的左子树的最大值（向右找）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getMaxLeft</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="总结">总结：</h5>
<ul>
<li><p>由BST树的搜索框架，可以实现增（插）删改查，这几项的操作都是<strong>搜+改</strong>，做题可以先把框架写出来，再分析每步干什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)&#123;</span><br><span class="line">        <span class="comment">// 找到目标节点，进行具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//目标值target比当前节点值大，在右子树中找</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="comment">//目标值target比当前节点值小，在左子树中找</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于BST树最大的特点就是左小右大，中序遍历的结果由小到大。</p></li>
<li><p>递归最重要的就是弄清函数的含义，如果有返回值代表什么。</p></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—重建二叉树</title>
    <url>/2020/12/21/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>LeetCode中有三道很类似的题，思路也大同小异，故作一总结。</p>
<p><a href="#105，从前序与中序遍历序列构造二叉树，medium">105，从前序与中序遍历序列构造二叉树，medium</a> <a href="#106，根据中序和后序遍历构造二叉树，medium">106，根据中序和后序遍历构造二叉树，medium</a> <a href="#889，根据前序和后序遍历构造二叉树，medium">889，根据前序和后序遍历构造二叉树，medium</a></p>
<p>这三道题都是给出两种遍历方式，由其遍历顺序可发现规律来重建此二叉树。下面详解105题，后两题思路稍作改变，比较好懂了。</p>
<a id="more"></a>
<h4 id="从前序与中序遍历序列构造二叉树medium">105，从前序与中序遍历序列构造二叉树，medium</h4>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意: 你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre>
<h5 id="方法一分治思想-hashmap">方法一：分治思想 + HashMap</h5>
<ul>
<li><p>前序遍历：根-左-右。</p>
<p>中序遍历：左-根-右。</p>
<p>以题目示例为例： <img src="https://pic.leetcode-cn.com/1603644245-oFksKK-Picture1.png" alt="Picture1.png" style="zoom:80%;" /></p>
<ul>
<li>前序遍历划分 <code>[ 3 | 9 | 20 15 7 ]</code></li>
<li>中序遍历划分 <code>[ 9 | 3 | 15 20 7 ]</code></li>
</ul>
<p>则前序遍历的首个元素 为 <strong>根节点的值</strong>，在中序遍历数组中找到 <strong>根节点所在索引</strong>，其<strong>左边的元素</strong>为 根节点的<strong>左子树</strong>，<strong>右边的元素</strong>为 根节点的<strong>右子树</strong>。</p></li>
<li><p>以上子树的递推性质是 <strong>分治算法</strong> 的体现，考虑通过递归对所有子树进行划分。</p>
<p>辅助函数 build，参数为：前序遍历的起点索引 preL，结束索引 preR，中序遍历的起点索引 inL，结束索引 inR。</p>
<p>通过上面所述找到 root 在中序遍历的索引，递归其左边元素和 右边元素，分别赋给 root 的左子树 和 右子树。递归出口为 <code>preL &gt; preR || inL &gt; inR</code>，表示越过叶子节点，此时返回null。</p>
<ul>
<li><p>其中 找到 root 在中序遍历的索引 一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用 <strong>HashMap</strong> 快速地<strong>定位根节点</strong>。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的索引。</p></li>
<li><p>确定 preL、preR、inL、inR 需要解方程 <img src="https://img-blog.csdnimg.cn/20201221142412691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p>
<p>左子树 在 前序遍历中的起点索引：preL + 1</p>
<p>左子树 在 前序遍历中的结束索引：x</p>
<pre><code> x 满足 x - (preL + 1) = rootIndex - 1 - intL=&gt;  x = rootIndex - intL + preL</code></pre>
<p>左子树 在 中序遍历中的起点索引：intL</p>
<p>左子树 在 中序遍历中的结束索引：rootIndex - 1</p>
<p>右子树 在前序遍历中的起点索引：x + 1</p>
<p>右子树 在 前序遍历中的结束索引：preR</p>
<p>右子树 在 中序遍历中的起点索引：rootIndex + 1</p>
<p>右子树 在 中序遍历中的结束索引：inR</p></li>
</ul></li>
<li>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] preorder;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">      map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="comment">//将中序遍历数组的元素和其索引存入map键值对</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">          map.put(inorder[i], i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> build(<span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//前序遍历:preL起始索引，preR结束索引；中序遍历：inL起始索引，inR结束索引</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(preL &gt; preR || inL &gt; inR) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//将前序遍历首个元素设为根节点</span></span><br><span class="line">      <span class="keyword">int</span> rootVal = preorder[preL];</span><br><span class="line">      TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">      <span class="comment">//找到中序遍历中root的索引</span></span><br><span class="line">      <span class="keyword">int</span> rootIndex = map.get(rootVal);</span><br><span class="line">      <span class="comment">//递归调用中序遍历root左右部分形成root的左右子树</span></span><br><span class="line">      root.left = build(preL + <span class="number">1</span>, rootIndex - inL + preL, inL, rootIndex - <span class="number">1</span>);</span><br><span class="line">      root.right = build(rootIndex - inL + preL + <span class="number">1</span>, preR, rootIndex + <span class="number">1</span>, inR);</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##### 方法二</li>
<li><p>和上面总体思想一样，但不借助 HashMap 来定位 root 在中序遍历数组的索引，而是用 List 的 indexOf 来定位，用 subList 确定左右子树的范围。</p></li>
<li><p>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; prelist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      List&lt;Integer&gt; inlist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">//将int数组转为List</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preorder.length; i++)&#123;</span><br><span class="line">          prelist.add(preorder[i]);</span><br><span class="line">          inlist.add(inorder[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> build(prelist, inlist);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(List&lt;Integer&gt; prelist, List&lt;Integer&gt; inlist)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(inlist.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//前序集合的首个元素为根节点</span></span><br><span class="line">      <span class="keyword">int</span> rootVal = prelist.remove(<span class="number">0</span>);</span><br><span class="line">      TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">      <span class="comment">//找到根节点在中序的索引</span></span><br><span class="line">      <span class="keyword">int</span> index = inlist.indexOf(rootVal);</span><br><span class="line">      <span class="comment">//新的左右两边</span></span><br><span class="line">      root.left = build(prelist, inlist.subList(<span class="number">0</span>, index));</span><br><span class="line">      root.right = build(prelist, inlist.subList(index + <span class="number">1</span>, inlist.size()));</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 先把数组转化为list集合，然后在list集合中进行截取，这样效率明显不是很高。 #### 106，根据中序和后序遍历构造二叉树，medium 根据一棵树的中序遍历与后序遍历构造二叉树。</p></li>
</ul>
<p>注意: 你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre>
<ul>
<li><p>思路：和上一题的思路基本一致，由中序遍历的规律（root 左部分为左子树，右部分为右子树），后序遍历的根节点为最后的节点。</p></li>
<li><p>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] postorder;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.postorder = postorder;</span><br><span class="line">      map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">          map.put(inorder[i], i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> build(<span class="number">0</span>, inorder.length - <span class="number">1</span>, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span> inL, <span class="keyword">int</span> inR, <span class="keyword">int</span> postL, <span class="keyword">int</span> postR)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(inL &gt; inR || postL &gt; postR) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//在后序数组中找到根节点root</span></span><br><span class="line">      <span class="keyword">int</span> rootVal = postorder[postR];</span><br><span class="line">      TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">      <span class="comment">//中序中root的索引</span></span><br><span class="line">      <span class="keyword">int</span> rootIndex = map.get(rootVal);</span><br><span class="line">      root.left = build(inL, rootIndex - <span class="number">1</span>, postL, postL + rootIndex - <span class="number">1</span> - inL);</span><br><span class="line">      root.right = build(rootIndex + <span class="number">1</span>, inR, postL + rootIndex - inL, postR - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 889，根据前序和后序遍历构造二叉树，medium 返回与给定的前序和后序遍历匹配的任何二叉树。</p></li>
</ul>
<p>pre 和 post 遍历中的值是不同的正整数。</p>
<p>示例：</p>
<p>输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] 输出：[1,2,3,4,5,6,7]</p>
<ul>
<li><p>思路：还是按照之前的思路，找到根节点（即前序遍历的第一个元素或后序遍历的最后一个元素），但前序和后序 不像 中序的根作为分隔点，所以需要再找左子树的根 在 后序遍历数组 的 索引，依次来确定左右子树的长度。</p></li>
<li>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  Map&lt;Integer,Integer&gt; map;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] post;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] pre;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] post)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.post = post;</span><br><span class="line">      <span class="keyword">this</span>.pre = pre;</span><br><span class="line">      map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; post.length; i++)&#123;</span><br><span class="line">          map.put(post[i], i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> build(<span class="number">0</span>, pre.length - <span class="number">1</span>, <span class="number">0</span>,  post.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> postL, <span class="keyword">int</span> postR)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(preL &gt; preR || postL &gt; postR) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//不加这步，下面int leftRoot = pre[preL + 1];会出现角标越界</span></span><br><span class="line">      <span class="keyword">if</span>(preL == preR) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//根的索引即前序第一个元素和后序最后一个元素</span></span><br><span class="line">      TreeNode root = <span class="keyword">new</span> TreeNode(post[postR]);</span><br><span class="line">      <span class="comment">//下面是为了确定左子树在数组中的长度</span></span><br><span class="line">      <span class="comment">//左子树根节点</span></span><br><span class="line">      <span class="keyword">int</span> leftRoot = pre[preL + <span class="number">1</span>];</span><br><span class="line">      <span class="comment">//左子树根节点在后序的索引</span></span><br><span class="line">      <span class="keyword">int</span> leftRootIndex = map.get(leftRoot);</span><br><span class="line"></span><br><span class="line">      root.left = build(preL + <span class="number">1</span>, leftRootIndex - postL + preL + <span class="number">1</span>, postL, leftRootIndex);</span><br><span class="line">      root.right = build(leftRootIndex - postL + preL + <span class="number">2</span>, preR, leftRootIndex + <span class="number">1</span>, postR - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 总结</li>
<li>三个题中 前序 + 中序 和 后序 + 中序，都利用中序的根左边部分是左子树，右边部分是右子树。所以先建立根节点，并找出根节点在中序遍历数组的索引，就可以利用此规律重建二叉树。</li>
<li>只有 前序 + 后序时，无法利用中序遍历的规律，则需要再找出左子树的根节点，来确定左、右子树的长度。</li>
<li>用 HashMap 来以空间换时间，快速定位。</li>
<li><p>注意三题都不能有重复数字，才能用上面方法。</p></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>LeetCode刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—动态规划（二）</title>
    <url>/2020/12/29/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>刷了一系列这类的题，真的感受到dp 深深的套路，那就看看 什么套路来解此类题吧！</p>
<p><a href="#300，最长递增子序列，medium">300，最长递增子序列，medium</a> <a href="#673，最长递增子序列的个数，medium">673，最长递增子序列的个数，medium</a> <a href="#435，无重叠区间，medium">435，无重叠区间，medium</a> <a href="#646，最长数对链，medium">646，最长数对链，medium</a> <a href="#452，用最少数量的箭引爆气球，medium">452，用最少数量的箭引爆气球，medium</a></p>
<h3 id="最长递增子序列">最长递增子序列</h3>
<p>最长递增子序列（Longest Increasing Subsequence，简写 LIS）是比较经典的一个问题，比较容易想到的是动态规划解法，时间复杂度 <strong>O(N^2)</strong>。注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。</p>
<a id="more"></a>
<h4 id="最长递增子序列medium">300，最长递增子序列，medium</h4>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<p><code>1 &lt;= nums.length &lt;= 2500</code></p>
<p><code>-104 &lt;= nums[i] &lt;= 104</code></p>
<ul>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p>到 nums[i] 的最长递增子序列的长度为 <span class="math inline">\(dp[i]\)</span></p></li>
<li><p>递推关系</p>
<ul>
<li><p>base case</p>
<p>dp 数组应全部初始化为1，因为子序列最少也要包含自己。</p></li>
<li><p>状态转移方程</p></li>
</ul>
<figure>
<img src="https://img-blog.csdnimg.cn/20201229200921170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>对于 <span class="math inline">\(dp[i]\)</span>，<strong>比较 nums[i] 与前 i - 1 个元素</strong>，如果有比 nums[i] <strong>小</strong>的 元素 nums[j]，则 nums[i] 可以加入已形成的 <span class="math inline">\(dp[j]\)</span> 之后，<span class="math inline">\(dp[i]\)</span> 为与 <span class="math inline">\(dp[j] + 1\)</span> 取<strong>最大值</strong>后的结果。</p></li>
<li><p>返回值</p>
<p>最终返回最大的 <span class="math inline">\(dp[i]\)</span>，在第一次遍历数组得到 <span class="math inline">\(dp[0]\)</span> ~ <span class="math inline">\(dp[i-1]\)</span> 时，不断取最大值更新 res。</p></li>
</ol></li>
<li><p>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = nums.length;</span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">     <span class="comment">//base case</span></span><br><span class="line">     Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//得到 dp[0] ~ dp[i-1]</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">         <span class="comment">//nums[i] 与前 i-1 个数字进行比较，得到 dp[i]</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                 dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//在dp[0]~dp[n-1] 中找出最大值即为结果 </span></span><br><span class="line">         res = Math.max(res, dp[i]);</span><br><span class="line">     &#125;        </span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> #### 673，最长递增子序列的个数，medium</p></li>
</ul>
<p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,2,2,2]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p>到 nums[i] 结尾，最长递增子序列的长度为 <span class="math inline">\(dp[i]\)</span>，此外还需要一个数组 <span class="math inline">\(count[i]\)</span> 来记录具有该长度的序列个数。</p></li>
<li><p>递推关系</p>
<ul>
<li><p>base case</p>
<p>dp 数组应全部初始化为1，因为子序列最少也要包含自己。</p>
<p>count 数组全部初始化为1，个数至少有一个。</p></li>
<li><p>状态转移方程</p>
<p>遍历[0...i]，再套一层[0....j]，其中 j＜i</p>
<p>当 <code>nums[j]＜nums[i]</code>，说明可以形成最长递增序列，nums[i] 可以加入已形成的 <span class="math inline">\(dp[j]\)</span> 之后。</p>
<ul>
<li>当 <span class="math inline">\(dp[j] + 1 &gt; dp[i]\)</span> 时，第一次出现此长度，<span class="math inline">\(dp[i] = dp[j] + 1\)</span>，最长递增子序列的长度增加 但 个数不变，count[i] = count[j]</li>
<li>当 <span class="math inline">\(dp[j] + 1 = dp[i]\)</span> 时，在循环中已经出现过此长度，现在的组合方式 <code>count[i]</code> 加上 <code>count[j]</code> 并记录最大递增子序列长度</li>
</ul></li>
</ul></li>
<li><p>返回值</p>
返回最大长度对应的种类数之和。</li>
</ol></li>
<li><p>举例：</p>
输入：[1,1,3,2]<br />
<img src="https://img-blog.csdnimg.cn/20201229201136525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></li>
<li><p>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> n = nums.length;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">      <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">      Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">      Arrays.fill(count, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                  <span class="keyword">if</span>(dp[j] + <span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                      dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                      count[i] = count[j];</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(dp[j] + <span class="number">1</span> == dp[i])&#123;</span><br><span class="line">                      count[i] += count[j];</span><br><span class="line">                  &#125;   </span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          maxLength = Math.max(maxLength, dp[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(dp[i] == maxLength)&#123;</span><br><span class="line">              res += count[i];</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="一个小总结">一个小总结</h4>
<ul>
<li>上面两题思路是很像的，动态规划基于数学归纳法。</li>
<li>先得到第 i 位 的 最长递增子序列个数，最终结果（子序列的最大长度）应该是 dp 数组中的最大值。</li>
<li>而对 dp[i]，与前面的 i - 1 个数进行比较，加在前面的递增子序列之后，不断取最大值，得到 dp[i]。</li>
<li>第二题 多增加了count 数组来记录最长子序列的个数，注意循环中的比较。</li>
</ul>
<p>下面又是【最长递增子序列】的另一种题型，将上面题中的数组划分很多个小区间，如果能识别是同一种题就好解决了！</p>
<h4 id="无重叠区间medium">435，无重叠区间，medium</h4>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:</p>
<ol type="1">
<li>可以认为区间的终点总是大于它的起点。</li>
<li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li>
</ol>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>问题解析：</p>
<p>可以抽象成上面的问题：最长非严格递增子序列。题目要求可以接触但不可以重叠，即非严格递增。子序列长度改为区间个数，【删除区间的最小数量】即 【保留区间的最大个数】。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p>到第 i 个区间，保留的最大区间数为 <span class="math inline">\(dp[i]\)</span>。</p></li>
<li><p>递推关系</p>
<ul>
<li><p>base case</p>
<p>dp 数组应全部初始化为1，因为最少也要保留一个区间。</p></li>
<li><p>状态转移方程</p>
<p>对于 <span class="math inline">\(dp[i]\)</span>，前面 j = [0, i - 1] 个区间都有可能与它重叠（重叠即 j 的第 1 个元素 &gt; i 的第 0 个元素），需要得到保留不重叠的区间的最大值。</p>
<p><span class="math inline">\(dp[i] = Math.max(dp[i], dp[j] + 1)\)</span></p></li>
</ul></li>
<li><p>返回值</p>
<p>遍历过程中得到 ans 即 保留不重叠的区间的最大值，最后返回 n - ans，即删除的最小区间个数。</p></li>
</ol></li>
<li>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">if</span>(intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      	<span class="keyword">int</span> n = intervals.length;</span><br><span class="line">      	<span class="comment">//对区间按起始数字进行排序</span></span><br><span class="line">      	Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">          	<span class="meta">@Override</span></span><br><span class="line">          	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">              	<span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];</span><br><span class="line">          	&#125;</span><br><span class="line">      	&#125;);</span><br><span class="line">      	<span class="comment">//保留的最大区间个数</span></span><br><span class="line">      	<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">      	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">      	Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">      	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">          	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">              	<span class="comment">//如果没有重叠（即右边的0元素大于等于左边的1元素），更新dp[i]</span></span><br><span class="line">              	<span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= intervals[j][<span class="number">1</span>])   </span><br><span class="line">                  	dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);               </span><br><span class="line">          	&#125;</span><br><span class="line">          	ans = Math.max(ans, dp[i]);</span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="comment">//删除的最小数量</span></span><br><span class="line">      	<span class="keyword">return</span> n - ans;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>另一种：双指针</p>
<ul>
<li><p>思路：</p>
<p>先对各个区间从小到大排序，左区间小的优先；相同情况下，右区间小的优先。</p>
<p>排序后两个指针分别指向<strong>相邻</strong>两个区间，不发生重叠继续比较下两个相邻区间；发生重叠则去除 右元素较大的一个区间，这样较小的右区间才会尽可能减小与其他区间交集。</p></li>
<li><p>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    	Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        	<span class="meta">@Override</span></span><br><span class="line">        	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">            	<span class="keyword">if</span> (o1[<span class="number">0</span>] != o2[<span class="number">0</span>]) &#123;</span><br><span class="line">                	<span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            	&#125;<span class="keyword">else</span></span><br><span class="line">                	<span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;);</span><br><span class="line">    	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//i指向待比较的左边区间，j指向待比较的右边区间</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; intervals.length-<span class="number">1</span> &amp;&amp; j&lt;=intervals.length-<span class="number">1</span>; i++,j++) &#123;</span><br><span class="line">        	<span class="comment">//左边的1元素 &gt; 右边的0元素，发生重叠，需要去除其中一个</span></span><br><span class="line">        	<span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt; intervals[j][<span class="number">0</span>]) &#123;</span><br><span class="line">            	<span class="comment">//去除1元素较大的那个，如果右边区间的1元素较大，保留左边，i = i - 1，再次进入循环 i + 1，还在原位置;</span></span><br><span class="line">            	<span class="comment">//如果左边区间的1元素较大，保留右边，i = j - 1，再次进入循环 i + 1，i = j , j向后移</span></span><br><span class="line">            	i = intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>] ? i - <span class="number">1</span>: j - <span class="number">1</span>;</span><br><span class="line">            	count++;</span><br><span class="line">        	&#125; </span><br><span class="line">        <span class="comment">//不发生重叠</span></span><br><span class="line">        	<span class="keyword">else</span> &#123;</span><br><span class="line">            	i = j - <span class="number">1</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 646，最长数对链，medium</p></li>
</ul></li>
</ul>
<p>给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p>
<p>现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。</p>
<p>给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2], [2,3], [3,4]]</span><br><span class="line">输出：2</span><br><span class="line">解释：最长的数对链是 [1,2] -&gt; [3,4]</span><br></pre></td></tr></table></figure>
<ul>
<li>问题说明：与上一题的区别在于数对之间不可以有相等数字，是严格递增的区间。返回的是最长数对区间个数。</li>
<li>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = pairs.length;   </span><br><span class="line">       </span><br><span class="line">      Arrays.sort(paris, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (o1[<span class="number">0</span>] != o2[<span class="number">0</span>]) &#123;</span><br><span class="line">                  <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">              &#125;<span class="keyword">else</span></span><br><span class="line">                  <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">      Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">              <span class="comment">//不发生重叠, 更新 dp[i]</span></span><br><span class="line">              <span class="keyword">if</span>(pairs[i][<span class="number">0</span>] &gt; pairs[j][<span class="number">1</span>])&#123;</span><br><span class="line">                  dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">              &#125;    </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//上面对pairs 进行了排序，dp数组递增，返回最后一个元素即最大值</span></span><br><span class="line">      <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 452，用最少数量的箭引爆气球，medium</li>
</ul>
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>xstart</code>，<code>xend</code>， 且满足 <code>xstart ≤ x ≤ xend</code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 <code>points</code> ，其中 <code>points [i] = [xstart,xend]</code> ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：对于该样例，x &#x3D; 6 可以射爆 [2,8],[1,6] 两个气球，以及 x &#x3D; 11 射爆另外两个气球</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<ul>
<li>问题说明：<span class="math inline">\(dp[i]\)</span> 表示 到第 i 个区间的最小弓箭数。如果 左边区间的1元素 &gt;= 右边区间的0元素，说明有重叠，可以共用一个箭；如果 左边区间的1元素 &lt; 右边区间的0元素，没有重叠，<span class="math inline">\(dp[i] = dp[j] + 1\)</span>。</li>
<li>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> n = points.length;</span><br><span class="line">      Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (o1[<span class="number">0</span>] != o2[<span class="number">0</span>]) &#123;</span><br><span class="line">                  <span class="keyword">return</span> Integer.compare(o1[<span class="number">0</span>], o2[<span class="number">0</span>]);</span><br><span class="line">              &#125;<span class="keyword">else</span></span><br><span class="line">                  <span class="keyword">return</span> Integer.compare(o1[<span class="number">1</span>], o2[<span class="number">1</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">      Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;    </span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">              <span class="comment">//如果区间不重叠（左边的1元素 &lt; 右边的0元素），dp[j] + 1</span></span><br><span class="line">              <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; points[j][<span class="number">1</span>])</span><br><span class="line">                  dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">          &#125;      </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意：排序时，如果使用 <code>o1[0]-o2[0]</code> 、 <code>o1[1]-o2[1]</code> 在 [[-2147483646,-2147483645],[2147483646,2147483647]] 测试用例时会导致整形溢出。</li>
</ul>
<h4 id="一个小总结-1">一个小总结</h4>
<pre><code>这里动态规划的解法并不高效，只是为了讲解整体思路。
上面几题都是先对区间排序，再根据题意看是否重叠更新dp[i]。</code></pre>
<p>继续刷题！继续更新！</p>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—树的最近公共祖先</title>
    <url>/2020/12/17/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<p>针对下面两题作出解答与总结： <a href="#235，二叉搜索树的最近公共祖先，easy">235，二叉搜索树的最近公共祖先，easy</a> <a href="#236，二叉树的最近公共祖先，medium">236，二叉树的最近公共祖先，medium</a></p>
<a id="more"></a>
<h3 id="前序">前序</h3>
<p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>p、q两节点一定在此树上，有两种情况： 1. p、q 在一个节点两侧，此节点即为p、q的公共祖先，如下图中 2 为p = 7、q = 4 的最近公共祖先 <img src="https://img-blog.csdnimg.cn/20201217161655456.png" alt="在这里插入图片描述" /> 2. p 或 q为最近公共祖先，如下图中 p 即为最近公共祖先 <img src="https://img-blog.csdnimg.cn/20201217161909824.png" alt="在这里插入图片描述" /> ### 235，二叉搜索树的最近公共祖先，easy 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/f6e46ace5976ecb7788e718bdedf3e62.png" alt="img" /><figcaption>img</figcaption>
</figure>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<ul>
<li><p>方法一：递归。</p>
<ul>
<li><p>思路：利用BST树左大右小的规律，p、q的位置有如下三种情况：</p>
<ul>
<li>在root的一左一右：返回root</li>
<li>都在root左子树：递归root.left</li>
<li>都在root右子树：递归root.right</li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val == root.val || q.val == root.val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &gt; root.val || p.val &gt; root.val &amp;&amp; q.val &lt; root.val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &lt; root.val) <span class="keyword">return</span> lowestCommonAncestor(root.left, p , q);</span><br><span class="line">        <span class="keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val) <span class="keyword">return</span> lowestCommonAncestor(root.right, p , q);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简洁版：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两个差的乘积&lt;=0，p、q分布在root两侧,返回root</span></span><br><span class="line">        <span class="keyword">if</span>(p.val - root.val)*(q.val - root.val) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val &lt; root.val ?lowestCommonAncestor(root.left,p,q) : lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>方法二：迭代。</p>
<ul>
<li>思路：p，q与root可能有三种关系。①p，q都在root的左子树 ②.p，q都在root的右子树 ③.p，q在root的一左一右。</li>
<li>通过p.val，q.val与root.val的差的乘积来判断。
<ul>
<li>如果大于0，说明①或②，则在root的左或右不断向下找，直到乘积为负返回此时根节点。</li>
<li>如果小于0，说明③，返回root。</li>
</ul></li>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p.val == root.val || q.val == root.val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//更新root直到找到p、q为两侧时的root</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)</span><br><span class="line">                root = root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val)</span><br><span class="line">                root = root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="二叉树的最近公共祖先medium">236，二叉树的最近公共祖先，medium</h5>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/194dc616212512f5efd6c8e72895ea22.png" alt="img" /><figcaption>img</figcaption>
</figure>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。</p>
<ul>
<li><p>方法：递归回溯。</p>
<ul>
<li><p>思路：二叉树没有什么特点 ，只能考虑先知道左右子树的情况，然后决定向上返回什么。因此采用「后序遍历」的思想。通过递归对二叉树进行后序遍历，当遇到节点 p 或 q 时返回。<strong>从底至顶回溯</strong>，当节点 p,q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。</p>
<ul>
<li><p>递归出口：</p>
<ol type="1">
<li>root递归到叶子节点，返回 null</li>
<li>当 root 等于 p 或 q，返回 root</li>
</ol></li>
<li><p>递归体：</p>
<p>递归左子节点和右子节点</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 两种情况的 base case</span></span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">  TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>回溯的结果有三种情况：</p>
<p>以下面为例，</p></li>
</ul></li>
</ul></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201217162249379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /> （1）. 当 left和 right 同时不为空 ：说明 p,q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root为最近公共祖先，返回 root ；</p>
<p><img src="https://img-blog.csdnimg.cn/20201217162346233.png#pic_center" alt="在这里插入图片描述" /> （2）.当 left 和 right 有一为空，返回另一个值</p>
<p>left 为空，right 不为空，具体可分为两种情况：</p>
<ol type="1">
<li>p,q 其中一个在 root 的 右子树 中，此时 right 指向 p（假设为 p ，图中 p = 2， q 在 3 的右子树中）；</li>
<li>p,q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 （图中 p = 7， q = 4，返回公共节点 right = 2）； <img src="https://img-blog.csdnimg.cn/20201217162608560.png#pic_center" alt="在这里插入图片描述" /> 或 <img src="https://img-blog.csdnimg.cn/20201217162636205.png#pic_center" alt="在这里插入图片描述" /></li>
</ol>
<p>（3）left ，right 都为空，返回null <img src="https://img-blog.csdnimg.cn/20201217162704543.png#pic_center" alt="在这里插入图片描述" /></p>
<p>​</p>
<ul>
<li>代码：</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == p.val || root.val == q.val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//分别递归左右子树</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//回溯结果</span></span><br><span class="line">        <span class="comment">// if(left == null &amp;&amp; right == null) return null;</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合MyBatis-过程及报错解决</title>
    <url>/2020/12/27/SpringBoot%E6%95%B4%E5%90%88MyBatis-%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p>最近在学习Spring Boot，在整合MyBatis进行数据访问，报过多次错，踩了很多坑，在此记录一下。</p>
<blockquote>
<p>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML或注解来配置和映射原生信息，将接口和 Java 的POJOs(Plain Ordinary Java Object,普通的Java对象)映射成数据库中的记录。</p>
</blockquote>
<h2 id="整合过程">整合过程</h2>
<ol type="1">
<li>导入依赖 pom.xml文件如下：</li>
</ol>
<a id="more"></a>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kuang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-05-mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-05-mybatis<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>在 application.properties 中连接数据库 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></li>
<li>测试数据源 在tests类进行测试是否连接了数据库，代码及测试结果如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot05MybatisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(dataSource.getClass());</span><br><span class="line">        System.out.println(dataSource.getConnection());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="https://img-blog.csdnimg.cn/2020122708531157.png" alt="测试结果" /> ## 项目目标 对数据库 mybatis 中 user 表的查询，user 表内容为： <img src="https://img-blog.csdnimg.cn/20201227092203933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li>
</ol>
<h2 id="项目构建">项目构建</h2>
<ol type="1">
<li><p>项目结构 <img src="https://img-blog.csdnimg.cn/20201227090000359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p></li>
<li><p>搭建步骤： 1）. 在 application.properties 中整合 MyBatis <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#设置包别名（在Mapper映射文件中直接使用实体类名）</span><br><span class="line">mybatis.type-aliases-package==com.kuang.pojo</span><br><span class="line">#告诉系统在哪里找mapper.xml文件（映射文件）</span><br><span class="line">mybatis.mapper-locations=classpath:mybatis/mapper/*.xml</span><br></pre></td></tr></table></figure> 2). 创建实体类User <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">package</span> com.kuang.pojo;</span><br><span class="line">   <span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line">   <span class="keyword">import</span> lombok.Data;</span><br><span class="line">   <span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Data</span></span><br><span class="line">   <span class="meta">@NoArgsConstructor</span></span><br><span class="line">   <span class="meta">@AllArgsConstructor</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   	<span class="keyword">private</span> String uname;</span><br><span class="line">   	<span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 3). 创建数据访问接口 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kuang.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****</span></span><br><span class="line"><span class="comment">* 创建MyBatis的 Mapper 映射接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//这个注解表示这是一个mybatis的 mapper 类 ：Dao（数据访问层）</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span></span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">queryUserList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//    User queryUserById(int id);</span></span><br><span class="line"><span class="comment">//    int addUser(User user);</span></span><br><span class="line"><span class="comment">//    int updateUser(User user);</span></span><br><span class="line"><span class="comment">//    int deleteUser(int id);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 4). 创建 Mapper 映射文件 在 resources 目录下，创建名为 mapper 的包，并在包中创建 SQL 映射文件 Mapper.xml。 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">       	select * from user</span><br><span class="line">   	 <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure> 5). 创建控制器类 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">package</span> com.kuang.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kuang.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.kuang.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   	<span class="meta">@Autowired</span></span><br><span class="line">   	<span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">   	<span class="meta">@GetMapping(&quot;/queryUserList&quot;)</span></span><br><span class="line">  	 	<span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUserList</span><span class="params">()</span></span>&#123;</span><br><span class="line">       	List&lt;User&gt; userList = userMapper.queryUserList();</span><br><span class="line">       	<span class="keyword">for</span>(User user : userList)&#123;</span><br><span class="line">           	System.out.println(user);</span><br><span class="line">       	&#125;</span><br><span class="line">       	<span class="keyword">return</span> userList;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 6). 运行 由于在 Mapper 映射接口中有 <span class="citation" data-cites="Mapper">@Mapper</span> 注解，Application 主类中不用添加 <span class="citation" data-cites="MapperScan">@MapperScan</span> 注解。直接启动，运行效果为： <img src="https://img-blog.csdnimg.cn/20201227092422842.png" alt="在这里插入图片描述" /> ## 报错记录 #### bean无法注入的问题——Error creating bean with name 'userController':</p></li>
</ol>
<p>错误原因可能有： 1. 包的位置不对，可以看下上面的项目结构，主类 和 子包都要在com.kuang 包下。 2. 注解使用不对，如 Controller接口没有使用@Controller、<span class="citation" data-cites="RestController注解等">@RestController注解等</span>。 3. xml 文件格式，去掉空格和中文注解 #### Invalid bound statement (not found): 这个报错原因一般是xml 映射文件有错误。检查下面几处： 1. xml 文件所在包名 与 接口 所在包名 一致，否则会报500 <img src="https://img-blog.csdnimg.cn/20201227093757891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<ol start="2" type="1">
<li>xml 文件中 namespace 与 映射接口 的位置一致 <img src="https://img-blog.csdnimg.cn/20201227093409360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li>
<li>检察函数名是否一致 UserMapper 映射接口中 <img src="https://img-blog.csdnimg.cn/2020122709391747.png" alt="在这里插入图片描述" /> Mapper.xml 中 <img src="https://img-blog.csdnimg.cn/20201227093936837.png" alt="在这里插入图片描述" /> ## 总结 虽然是个很简单的整合，但一直报错，反复检查代码的过程中，也对各个注解的功能，项目的架构理解更深，继续积累，继续加油！</li>
</ol>
]]></content>
      <categories>
        <category>SpringBoot学习</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>typora使用攻略</title>
    <url>/2020/12/01/typora%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h3 id="一内部跳转">一、内部跳转</h3>
<p>想在文章开头使用链接直接跳转到指定标题，可以使用快捷键 <code>Ctrl + K</code> 创建内部链接，并在<code>[]</code>中填写链接内容，<code>()</code>中的格式为 <code>#要跳转到的标题</code> 。</p>
<p>效果如图：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20201201194926993.png" alt="img" /><figcaption>img</figcaption>
</figure>
<p>然后按住Ctrl，点击链接，即跳转到想看的标题了。</p>
<h3 id="二更换-next主题">二、更换 next主题</h3>
<p>Typora 自带的字体太丑了，忍了好久终于换了个主题。</p>
<h5 id="下载喜欢的主题">1. 下载喜欢的主题</h5>
<p><a href="https://theme.typora.io/theme/NexT/">官网网址</a> 点击 Download进入下面页面。<img src="https://img-blog.csdnimg.cn/20210111172457971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 点击第一个进行下载，解压之后可以看到如下文件。 <img src="https://img-blog.csdnimg.cn/20210111172627611.png" alt="在这里插入图片描述" /><img src="https://img-blog.csdnimg.cn/20210111172800217.png" alt="在这里插入图片描述" /></p>
<h5 id="将下载好的文件移入themes文件夹">2. 将下载好的文件移入themes文件夹</h5>
<p>找到 Typora/themes 目录，将上面的文件移入此文件夹中。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210111173949852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<h5 id="在typora-中选择next-主题">3. 在Typora 中选择next 主题</h5>
<p>如图，选择 next 主题即可更换。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210111173825626.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
]]></content>
      <tags>
        <tag>一</tag>
      </tags>
  </entry>
  <entry>
    <title>idea导入Github分支</title>
    <url>/2021/01/06/idea%E5%AF%BC%E5%85%A5Github%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<p>在网上搜索了一圈没有特别简单直白的方法，把我的步骤贴在下面。 ### 1. 建立空文件夹 在任意位置新建文件夹即可。 ### 2. 使用Git Bash命令拉取分支</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20210106093532520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 具体命令为：<strong>git clone -b dev </strong> 后面是仓库的url <img src="https://img-blog.csdnimg.cn/20210106093652418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ### 3. 在 idea 中打开此项目 有可能会出现爆红，<a href="https://www.pianshen.com/article/85591420566/">参考</a>这篇文章解决。</p>
]]></content>
      <categories>
        <category>SpringBoot学习</category>
      </categories>
  </entry>
  <entry>
    <title>全国高校计算机能力挑战赛</title>
    <url>/2020/11/30/%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%83%BD%E5%8A%9B%E6%8C%91%E6%88%98%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="真题">2020真题</h2>
<h4 id="题1-n整数中所有立方值的平方根为整数的数的个数">16题：1-N整数中所有立方值的平方根为整数的数的个数</h4>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 10</span><br><span class="line">输出： 3</span><br></pre></td></tr></table></figure>
<ul>
<li>输入是10，其中1* 1* 1 = 1，平方根是1，为整数 输入是4，其中4 * 4 * 4 = 64，平方根是8，为整数 输入是8，其中9 * 9 * 9 = 729，平方根是27，为整数 输出 3</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> mul = i * i * i;</span><br><span class="line">            <span class="keyword">int</span> sqrt = (<span class="keyword">int</span>)Math.sqrt(mul);</span><br><span class="line">            <span class="keyword">if</span>(sqrt * sqrt == mul)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题收到n个鸡蛋每个鸡蛋各有重量找出m个重量差距最小的鸡蛋摆出一盒出售输出最重一盒鸡蛋的总重量">17题：收到N个鸡蛋，每个鸡蛋各有重量，找出M个重量差距最小的鸡蛋摆出一盒出售，输出最重一盒鸡蛋的总重量。</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">8 4</span><br><span class="line">11 9 12 5 10 19 8 6  </span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">42</span><br></pre></td></tr></table></figure>
<ul>
<li>思路：要找出M个重量差距最小的放在一盒（即一组），可以先将所有鸡蛋的重量（数组中所有元素）从小到大排序，找出每组的<strong>最大值 - 最小值</strong>，其中差值最小的且数组元素总和最大的一组即为所求，输出这组的元素总和。</li>
<li>实现步骤：
<ul>
<li>将数组进行排序（采用了快速排序，具体讲解请见另一篇博文）</li>
<li>将N- M + 1组的差值保存在abs数组</li>
<li>找出abs数组的最小值（与排序后nums的索引相同）</li>
<li>上面找出的最小值可能有多个元素相同为最小值，从后向前遍历abs数组，找到最小值的那组nums元素，输出它们的和。</li>
<li>题目要求输入的N和M是整数，鸡蛋重量和最后的输出都是浮点型，输出结果保留两位小数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      String str1 = sc.nextLine();</span><br><span class="line">      String str2 = sc.nextLine();</span><br><span class="line">      String[] num = str1.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">      <span class="keyword">int</span> N = Integer.parseInt(num[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">int</span> M = Integer.parseInt(num[<span class="number">1</span>]);</span><br><span class="line">      String[] ff = str2.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">float</span>[] nums = <span class="keyword">new</span> <span class="keyword">float</span>[N];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">          nums[i] = Float.parseFloat(ff[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//        Arrays.sort(nums);</span></span><br><span class="line">      quickSort(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">float</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//M个重量差距最小 即找出最小差值</span></span><br><span class="line">      <span class="keyword">float</span>[] abs = <span class="keyword">new</span> <span class="keyword">float</span>[N - M + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - M + <span class="number">1</span>; i++)&#123;</span><br><span class="line">              abs[i] = nums[i + M - <span class="number">1</span>] - nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//找出abs中的最小值</span></span><br><span class="line">      <span class="keyword">float</span> min = abs[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; abs.length; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(abs[i] &lt; min)&#123;</span><br><span class="line">              min = abs[i];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回abs[i]中元素的和</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = abs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">          <span class="keyword">if</span>(min == abs[i])&#123;</span><br><span class="line">              <span class="comment">//3-6 N=8 M=4 i=6</span></span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> j = i + (N - M -<span class="number">1</span>); j &gt;= i ; j--)&#123;</span><br><span class="line">                  res += nums[j];</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//题目要求结果保留两位小数</span></span><br><span class="line">      DecimalFormat fnum  =   <span class="keyword">new</span>  DecimalFormat(<span class="string">&quot;##0.00&quot;</span>);</span><br><span class="line">      String dd = fnum.format(res);</span><br><span class="line">      System.out.println(dd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//快速排序</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">float</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//数组有多个元素进行排序</span></span><br><span class="line">      <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">          <span class="keyword">float</span> base = nums[start];<span class="comment">//以要进行排序数组第0个元素为base</span></span><br><span class="line">          <span class="keyword">int</span> left = start;<span class="comment">//左指针</span></span><br><span class="line">          <span class="keyword">int</span> right = end;<span class="comment">//右指针</span></span><br><span class="line">          <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">              <span class="comment">//从右向左找，比base大，right--</span></span><br><span class="line">              <span class="keyword">while</span> (left&lt; right &amp;&amp; nums[right] &gt;= base) &#123;</span><br><span class="line">                  right--;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//比base小，替换left所在位置的数字</span></span><br><span class="line">              nums[left] = nums[right];</span><br><span class="line">              <span class="comment">//从左向右找，比base小，left++</span></span><br><span class="line">              <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= base)&#123;</span><br><span class="line">                  left++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//比base大，替换right所在位置的数字</span></span><br><span class="line">              nums[right] = nums[left];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//交换base与此时left、right指向的元素</span></span><br><span class="line">          <span class="keyword">float</span> temp = nums[left];</span><br><span class="line">          nums[left] = base;<span class="comment">//此时left=right，用base替换这个位置的数字</span></span><br><span class="line">          base = temp;</span><br><span class="line">          <span class="comment">//排列比base小的数字的数组</span></span><br><span class="line">          quickSort(nums, start, left - <span class="number">1</span>);</span><br><span class="line">          <span class="comment">//排列比base大的数字的数组</span></span><br><span class="line">          quickSort(nums, left + <span class="number">1</span>, end);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行结果： <img src="https://img-blog.csdnimg.cn/20201130161528809.png" alt="在这里插入图片描述" /></li>
</ul>
<h4 id="题一种每瓶含奶粉15g茶粉5g另一种每瓶含奶粉10g茶粉10g设某天消耗的奶粉和茶粉分别为x和y-求当天饮料店两种饮料的销量">19题：一种每瓶含奶粉15g茶粉5g，另一种每瓶含奶粉10g茶粉10g。设某天消耗的奶粉和茶粉分别为x和y 求当天饮料店两种饮料的销量</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：400 300</span><br><span class="line">输出：10 25</span><br></pre></td></tr></table></figure>
<ul>
<li>方法一：数学方法，解一元二次方程组。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = sc.nextInt();</span><br><span class="line">    <span class="comment">//15 * m + 10 * n = 400   5 * m + 10 * n = 300</span></span><br><span class="line">    System.out.println((a - b) / <span class="number">10</span> + <span class="string">&quot; &quot;</span> + (<span class="number">3</span> * b - a) / <span class="number">20</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="模拟题">模拟题</h2>
<h4 id="题目1给定字符数组统计字母类型a-z数字类型0-9和符号类型除字母数字及空格以外的其他字符的字符出现次数">题目1：给定字符数组，统计字母类型（a-z）、数字类型（0-9）和符号类型（除字母、数字及空格以外的其他字符）的字符出现次数。</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Hello World!</span><br><span class="line">输出：</span><br><span class="line">a-z 10</span><br><span class="line">0-9 0</span><br><span class="line">others 1</span><br></pre></td></tr></table></figure>
<ul>
<li>ASCII 码一共规定了128个字符的编码，0-31及127是控制字符或通信专用字符，32-126是字符，其中：32为空格，48-57为0~9十个阿拉伯数字，65-90为26个大写英文字母，97-122为26个小写英文字母。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      String input = in.nextLine();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> count3 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> count4 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">          <span class="keyword">char</span> temp = input.charAt(i);</span><br><span class="line">          <span class="keyword">if</span> (<span class="number">65</span> &lt;= temp &amp;&amp; temp &lt;= <span class="number">90</span> || <span class="number">97</span> &lt;= temp &amp;&amp; temp &lt;= <span class="number">122</span>) &#123;</span><br><span class="line">              count1++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">48</span> &lt;= temp &amp;&amp; temp &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">              count2++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//空格</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(temp &lt;= <span class="number">32</span>)</span><br><span class="line">              count3++;</span><br><span class="line">          <span class="keyword">else</span> count4++;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;a-z&quot;</span> + <span class="string">&quot; &quot;</span> + count1);</span><br><span class="line">      System.out.println(<span class="string">&quot;0-9&quot;</span> + <span class="string">&quot; &quot;</span> + count2);</span><br><span class="line">      System.out.println(<span class="string">&quot;others&quot;</span> + <span class="string">&quot; &quot;</span> + count4);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="题目2输入第一行数组中元素的个数-第二行n个正整数空行隔开-输出3合数区间的个数连续3个元素均为合数的区间为3合数区间">题目2：输入第一行，数组中元素的个数 第二行，N个正整数，空行隔开 输出：3合数区间的个数。连续3个元素均为合数的区间为3合数区间</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">6 8 4 9 7 5 8</span><br><span class="line">输出：</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<ul>
<li>合数即 除了能被1和它本身整除，还能被其他数整除。与质数相对，质数也叫素数。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">     <span class="keyword">int</span> N = sc.nextInt();<span class="comment">//N个整数</span></span><br><span class="line">     <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">         nums[i] = sc.nextInt();</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!isPrime(nums[i]) &amp;&amp; !isPrime(nums[i + <span class="number">1</span>]) &amp;&amp; !isPrime(nums[i + <span class="number">2</span>])) count++;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(count);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//返回true,不是合数;返回false,是合数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="comment">//质数不小于2    2，3，5，7。。。</span></span><br><span class="line">     <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(n); i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="题目3统计1-n之间所有平方数的个数">题目3：统计1-N之间所有平方数的个数</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：50</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = (<span class="keyword">int</span>)Math.sqrt(i);</span><br><span class="line">        <span class="keyword">if</span>(m * m == i)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题目4由n个整数组成的数组连续k个元素构成一个区间称为k区间一个k区间内所有素数和记为sk输出所有k区间的最大sk值第一行是两个整数n和k第二行为n个数输出最大sk值">题目4：由N个整数组成的数组，连续K个元素构成一个区间，称为K区间。一个K区间内所有素数和记为Sk，输出所有K区间的最大Sk值。第一行是两个整数N和K，第二行为N个数，输出最大Sk值。</h4>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：8 2</span><br><span class="line">     12 23 27 34 19 17 45 8</span><br><span class="line">输出：36</span><br></pre></td></tr></table></figure>
<ul>
<li>方法一： 双重for循环。建立一个数组res存储所有K区间的Sk值。第一层遍历所有的N - K + 1个区间，第二层遍历区间的K个元素，如果有素数，加入到res[i]中，最后在结果数组res中取最大值。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2_19</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      <span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line">      <span class="keyword">int</span> K = sc.nextInt();</span><br><span class="line">      <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">          nums[i] = sc.nextInt();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//区间个数</span></span><br><span class="line">      <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[N - K + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - K + <span class="number">1</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + K; j++) &#123;</span><br><span class="line">              <span class="comment">//是素数</span></span><br><span class="line">              <span class="keyword">if</span> (isPrime(nums[j])) &#123;</span><br><span class="line">                  res[i] += nums[j];</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (res[i] &gt; max) &#123;</span><br><span class="line">              temp = max;</span><br><span class="line">              max = res[i];</span><br><span class="line">              res[i] = temp;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(max);</span><br><span class="line">      <span class="comment">//        Arrays.sort(res);</span></span><br><span class="line">      <span class="comment">//        System.out.println(res[N - K]);</span></span><br><span class="line">      ｝</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//判断是否是素数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">      	<span class="keyword">if</span> (a &lt; <span class="number">2</span>) &#123;<span class="comment">// 素数不小于2</span></span><br><span class="line">          	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         	 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(a); i++) &#123;</span><br><span class="line">              	<span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;<span class="comment">// 若能被整除，则说明不是素数，返回false</span></span><br><span class="line">                  flag = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">break</span>;<span class="comment">// 跳出循环</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> flag;</span><br><span class="line"> 	 &#125;</span><br><span class="line">  ｝</span><br></pre></td></tr></table></figure></li>
<li>测试 <img src="https://img-blog.csdnimg.cn/20201127150704668.PNG#pic_center" alt="在这里插入图片描述" /></li>
</ul>
<h4 id="题目5由n个整数组成的数组其中连续kk-200个元素构成一个区间称为k区间-一个k区间中任意两个数求其差值的绝对值其中最大的绝对值记为dk">题目5：由N个整数组成的数组，其中连续K（K &lt;= 200）个元素构成一个区间，称为K区间。 一个K区间中任意两个数求其差值的绝对值其中最大的绝对值记为Dk。</h4>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：8 2</span><br><span class="line">     12 23 27 34 35 36 8 45</span><br><span class="line">输出：37</span><br></pre></td></tr></table></figure>
<ul>
<li>方法一：和另一道题类似，在双重循环中定义最大值max，最小值min为K区间首个元素，下面再进行判断是否还有比max大的重新确定为max，比min小的重新确定为min。max-min即为Dk，保存在数组res中，res长度为N - K + 1，输出即为res中的最大值。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> K = input.nextInt();</span><br><span class="line">        <span class="comment">//先划分为 N-K+1 个 K区间，在区间内排序，计算最大绝对值</span></span><br><span class="line">        <span class="comment">//N-K+1 数组的区间数</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            nums[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[N - K + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;<span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - K + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + K ; j++) &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                min = nums[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; max) &#123;</span><br><span class="line">                    max = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; min) &#123;</span><br><span class="line">                    min = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res[i] = max - min;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        Arrays.sort(res);</span></span><br><span class="line"><span class="comment">//        System.out.println(res[N - K]);</span></span><br><span class="line">        System.out.println(Dk(res));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//找到数组最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Dk</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)&#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试结果 <img src="https://img-blog.csdnimg.cn/20201127211427402.png" alt="在这里插入图片描述" /></li>
</ul>
<h4 id="题目6字母连连看给定一个由小写英文字母组成的字符串如果字符串中有两个连续的字母相同则这两个字母可同时消除并不断重复该操作直到不能消除为止">题目6：字母连连看，给定一个由小写英文字母组成的字符串，如果字符串中有两个连续的字母相同，则这两个字母可同时消除，并不断重复该操作，直到不能消除为止。</h4>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：abbcddcaba</span><br><span class="line">输出：YES</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：asdfghhgf</span><br><span class="line">输出：asd</span><br></pre></td></tr></table></figure>
<ul>
<li>方法一：借助辅助栈。
<ul>
<li>若栈为空，将输入字母入栈。否则，比较栈顶元素与下一个入栈的字母，若相等，则弹出栈顶元素；若不同，入栈。最后判断栈是否为空，若空，输出YES；若栈不为空，倒序输出栈中元素。</li>
<li>借助StringBuilder，将栈中元素加入，再逆序打印。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      String s = sc.next();</span><br><span class="line">      Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">          <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">          chars[i] = s.charAt(i);</span><br><span class="line">          <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (stack.peek() != chars[i]) &#123;</span><br><span class="line">                  stack.push(chars[i]);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> stack.pop();</span><br><span class="line">          &#125; <span class="keyword">else</span></span><br><span class="line">              stack.push(chars[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//判断</span></span><br><span class="line">      <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">          System.out.println(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">          <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">              sb.append(stack.pop());</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(sb.reverse());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>方法二：与上面思路类似，改为使用list实现。最后一步无需逆序打印，直接遍历输出结果。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">     String s = sc.next();</span><br><span class="line">     List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">         <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">         chars[i] = s.charAt(i);</span><br><span class="line">         <span class="keyword">if</span>(!list.isEmpty()) &#123;</span><br><span class="line">             <span class="keyword">if</span> (!list.contains(chars[i])) &#123;</span><br><span class="line">                 list.add(chars[i]);</span><br><span class="line">             &#125; <span class="keyword">else</span> list.remove(list.get(list.size() - <span class="number">1</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> list.add(chars[i]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (list.isEmpty()) System.out.println(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">char</span> a : list) &#123;</span><br><span class="line">             System.out.print(a);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>competitions</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer刷题—数组类</title>
    <url>/2020/11/09/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E2%80%94%E6%95%B0%E7%BB%84%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="剑指offer刷题数组类">剑指Offer刷题——数组类</h1>
<p>持续更新...好好总结，早日刷完！</p>
<p><a href="#03，easy">找出数组中重复的数字</a></p>
<p><a href="#04，middle">二维数组中的查找</a></p>
<p><a href="#11，easy">旋转数组的最小数字</a></p>
<p><a href="#12，middle">矩阵中的路径</a></p>
<p><a href="#21，easy">调整数组顺序使奇数位于偶数前面</a></p>
<p><a href="#39，easy">数组中出现次数超过一半的数字</a></p>
<p><a href="#57，easy">和为s的两个数字</a></p>
<a id="more"></a>
<h2 id="easy">03，easy</h2>
<h3 id="找出数组中重复的数字">找出数组中重复的数字</h3>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br></pre></td></tr></table></figure>
<p>输出：2 或 3</p>
<ul>
<li><p>方法一. 利用Arrays.Sort()方法排序，比较相邻两个数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">      Arrays.Sort(nums);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.length; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>])</span><br><span class="line">              <span class="keyword">return</span> nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法二. 把数组元素赋给新数组的索引，如果个数&gt;1,则返回-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] newNum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(++newNum[i] &gt; <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法三. 新建Set集合，利用Set的无序不可重复性，如果不能添加此元素，说明重复，返回此元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!set.add(i))</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="middle">04，middle</h2>
<h3 id="二维数组中的查找">二维数组中的查找</h3>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<ul>
<li><p>判空。matrix和其行列均不能为空</p></li>
<li><p>方法一：暴力查询。遍历二维数组，直到找到相同整数，返回true；或遍历完也没有找到，返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix)</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;<span class="comment">//列数</span></span><br><span class="line">        <span class="comment">//遍历此二维数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(target == matrix[i][j])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：</p>
<ul>
<li>思路：由此数组从左向右递增，从上向下递增的规律，比较target与右上角的数字，如果比它小(大)，则在左(右)边找，再与下一数字比较...直到找到相同整数，返回true；或遍历完也没有找到，返回false。</li>
<li>边界条件：遍历的行列指针i，j不能超过数组的行数rows，列数columns</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(matrix == <span class="keyword">null</span>|| matrix.length == <span class="number">0</span>|| matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;<span class="comment">//列数</span></span><br><span class="line">        <span class="comment">//从右上角开始比较</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = columns - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//target比此二维数组元素大,向下找，行指针++</span></span><br><span class="line">            <span class="keyword">if</span>(target &gt; matrix[i][j]) i++;</span><br><span class="line">            <span class="comment">//target比此二维数组元素小,向左找，列指针--</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; matrix[i][j]) j--;</span><br><span class="line">            <span class="comment">//相等</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="easy-1">11，easy</h2>
<h3 id="旋转数组的最小数字">旋转数组的最小数字</h3>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： <code>输入：[3,4,5,1,2] 输出：1</code> 示例 2： <code>输入：[2,2,2,0,1] 输出：0</code></p>
<ul>
<li><p>方法一：逐项查找，不考虑旋转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numbers.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[index] &gt; numbers [i])&#123;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：二分查找（减治思想），考虑旋转，比较nums[mid]与nums[right]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">      <span class="comment">//中间值大于最右边的值，说明旋转之后最小数字在mid右面</span></span><br><span class="line">        <span class="keyword">if</span>(numbers[middle] &gt; numbers[right])&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//中间值小于最右边的值，说明旋转之后最小的数字在mid或mid的左边</span></span><br><span class="line">        <span class="comment">//如[4,5,1⭐m,2,3] [5,1⭐,2m,3,4]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[middle] &lt; numbers[right])&#123;</span><br><span class="line">            right = middle ;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//中间值与最右边的值相等，不能判断最小数字在哪一边，可以缩小范围，right--</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[right];<span class="comment">//此时left,right指向同一数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>思考：为什么不能用最左边的值和middle比较？</p>
<p>举例：[3, 4, 5, 1, 2] 与 [1, 2, 3, 4, 5] ，此时，中间位置的值都比左边大，但最小值一个在后面，一个在前面，因此这种做法不能有效地减治。</p>
<h2 id="middle-1">12，middle</h2>
<h3 id="矩阵中的路径">矩阵中的路径</h3>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</p>
<p>路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],</p>
<p>[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],</p>
<p>[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p>示例 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [</span><br><span class="line">			   [&quot;a&quot;,&quot;b&quot;],</span><br><span class="line">               [&quot;c&quot;,&quot;d&quot;]</span><br><span class="line">              ],</span><br><span class="line"></span><br><span class="line">     word &#x3D; &quot;abcd&quot;</span><br><span class="line"></span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法一：回溯算法。（DFS+剪枝）</p>
<ul>
<li>深度优先遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li>
<li>剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="comment">//找回words的第0个元素</span></span><br><span class="line">                <span class="keyword">if</span>(dfs(board,words,i,j,<span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//board[i][j]表示矩阵元素，k表示字符串words的第k个元素</span></span><br><span class="line">        <span class="comment">//① 行或列索引越界 或 ② 当前矩阵元素与目标字符不同 或 ③ 当前矩阵元素已访问过 （③ 可合并至 ② ） 。</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != word[k])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//字符串 word 已全部匹配，即 k = len(word) - 1 。</span></span><br><span class="line">        <span class="keyword">if</span>(k  == word.length- <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//将 board[i][j] 值暂存于变量 tmp ，并修改为字符 &#x27;/&#x27; ，</span></span><br><span class="line">        <span class="comment">// 代表此元素已访问过，防止之后搜索时重复访问。</span></span><br><span class="line">        <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="comment">//从当前坐标的上下左右四个方向查找，只要有一个能查找到，就返回true</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board, word,i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word,i - <span class="number">1</span>, j, k + <span class="number">1</span>)|| dfs(board, word ,i ,j - <span class="number">1</span>, k + <span class="number">1</span>) || dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//恢复其本身值</span></span><br><span class="line">        board[i][j] = temp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="easy-2">21，easy</h2>
<h3 id="调整数组顺序使奇数位于偶数前面">调整数组顺序使奇数位于偶数前面</h3>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法一：遍历数组，因为不要求数字顺序，从数组索引为0开始++ 保存奇数，从末位开始-- 保存偶数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = nums.length - <span class="number">1</span>;<span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">         <span class="comment">//如果为偶数</span></span><br><span class="line">         <span class="keyword">if</span>(nums[i] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">             res[l--] = nums[i];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             res[m++] = nums[i];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>错误点：在for循环中<code>i &lt; l + 1</code>的写法是错误的，因为l在循环体中会变化。</strong></p>
<ul>
<li><p>方法二：双指针left，right。若为奇数，left++;若为偶数,right--。否则nums[left]和nums[right]交换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">             left++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(nums[right] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">             right--;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">             nums[left] = nums[right];</span><br><span class="line">             nums[right] = temp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="easy-3">39，easy</h2>
<h3 id="数组中出现次数超过一半的数字">数组中出现次数超过一半的数字</h3>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法一：先进行排序，若存在这样的数字，排序后一定位于数组中间位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        //数组先排序再找出现次数超过数组长度一半的数字</span></span><br><span class="line">       Arrays.sort(nums);<span class="comment">//1, 2, 2, 2, 2, 2, 3 ,4 , 5</span></span><br><span class="line">    <span class="comment">//    for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//        if(nums[i] == nums[i + nums.length / 2] )&#123;</span></span><br><span class="line">    <span class="comment">//            return nums[i];</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    return -1;</span></span><br><span class="line">        <span class="keyword">int</span> l = nums.length;</span><br><span class="line">        <span class="keyword">return</span> nums[l/<span class="number">2</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：借助map，key保存数组元素，value保存出现次数。遍历数组元素，如果keySet中包含此元素，用map.get(key)得到此时的value，并更新(+1)，判断若此时value &gt;= 数组长度的一半，返回此时的key；如果keySet中不包含此元素，加入map且使value为1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//用hashMap实现，key保存数组元素，value保存出现次数</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(nums[i]))&#123;</span><br><span class="line">             map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            value = map.get(nums[i]);</span><br><span class="line">            map.put(nums[i], value + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(value + <span class="number">1</span> &gt; nums.length / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="easy-4">57，easy</h2>
<h3 id="和为s的两个数字">和为s的两个数字</h3>
<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法一：左右双指针。</p>
<ul>
<li>如果两指针指向数字和 = target，返回这个数字构成的数组。</li>
<li>​ ... &lt; .... ，left 向右移。</li>
<li>​ ... &gt; .... ，right 向左移。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[left] &gt;= target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(nums[right] &gt; target)&#123;</span><br><span class="line">         right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] + nums[right] == target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[left], nums[right]&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &gt; target) right--;</span><br><span class="line">        <span class="keyword">else</span> left++;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：</strong> 数组遍历都可以用双指针想一想</p>
<p>​ 双指针固定套路：<code>while(left &lt; right)</code></p>
<p>​ if判断中先判断 == 再判断 &lt; , &gt;，有助于减少运行时间</p>
<ul>
<li><p>方法二：利用set的不可重复性，遍历数组将数组元素添加到set，如果set包含target - i，则返回两个元素构成的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">	Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">         set.add(i);</span><br><span class="line">         <span class="keyword">if</span> (set.contains(target - i)) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, target - i&#125;;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>刷题数组类</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组</title>
    <url>/2020/10/31/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="二维数组">二维数组</h2>
<p>最近做题总涉及到二维数组，觉得掌握还不熟悉，再复习一下。</p>
<h3 id="二维数组的创建">二维数组的创建</h3>
<p>在Java中二维数组被看作数组的数组，即二维数组为一个特殊的一维数组，其每个元素又是一个一维数组。声明二维数组的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">type array[][];</span><br></pre></td></tr></table></figure>
<p>其中，type 表示二维数组的类型，array 表示数组名称，第一个中括号表示行，第二个中括号表示列。</p>
<a id="more"></a>
<h3 id="二维数组的初始化">二维数组的初始化</h3>
<ul>
<li><p>第一种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">ints[i][j] =__; <span class="comment">//分别赋值</span></span><br></pre></td></tr></table></figure></li>
<li><p>第三种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line"><span class="keyword">int</span> a[ ][ ] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][ ]；</span><br><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="获取单个元素">获取单个元素</h3>
<p>当需要获取二维数组中元素的值时，也可以使用下标来表示。语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h3 id="二维数组的遍历">二维数组的遍历</h3>
<ul>
<li><p>第一种：双重for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rows = matrix.length;</span><br><span class="line"><span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++)&#123;</span><br><span class="line">       System.out.println(matrix[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种：增强for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] i : matrix)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j : i)&#123;</span><br><span class="line">       System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title>从JDBCUtils看代码简洁之道</title>
    <url>/2020/11/16/%E4%BB%8EJDBCUtils%E7%9C%8B%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<h1 id="从jdbcutils看代码简介之道">从JDBCUtils看代码简介之道</h1>
<h3 id="使用preparedstatement实现增删改查">使用PreparedStatement实现增删改查</h3>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPreparedStatement1</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">             System.out.println(<span class="string">&quot;请输入待修改的客户编号：&quot;</span>);</span><br><span class="line">             <span class="keyword">int</span> id = input.nextInt();</span><br><span class="line">             System.out.println(<span class="string">&quot;请输入新的客户姓名：&quot;</span>);</span><br><span class="line">             String name = input.next();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------连接数据库的步骤------------------------</span></span><br><span class="line"></span><br><span class="line">             Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">             info.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\jdbc1.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line">             String user = info.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">             String password = info.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">             String url = info.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">             String driver = info.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">             <span class="comment">//1.注册驱动</span></span><br><span class="line">             Class.forName(driver);</span><br><span class="line">             <span class="comment">//2.获取连接</span></span><br><span class="line">             Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">             <span class="comment">//3.执行修改</span></span><br><span class="line">             String sql = <span class="string">&quot;UPDATE customers SET name = ? WHERE id = ?&quot;</span>;</span><br><span class="line">             PreparedStatement statement = connection.prepareStatement(sql);</span><br><span class="line">             statement.setString(<span class="number">1</span>, name);</span><br><span class="line">             statement.setInt(<span class="number">2</span>, id);</span><br><span class="line">             <span class="keyword">int</span> i = statement.executeUpdate();<span class="comment">//执行增删改，返回受影响的行数</span></span><br><span class="line">             System.out.println(i &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line"></span><br><span class="line">             <span class="comment">//4.关闭</span></span><br><span class="line">             statement.close();</span><br><span class="line">             connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工具类jdbcutils">工具类JDBCUtils</h3>
<p>由于每次都要加载配置文件，读取配置信息，注册驱动，获取连接，想到封装成工具类JDBCUtils。功能：</p>
<ul>
<li>1、获取连接</li>
<li>2、释放资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：获取可用的连接对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">        info.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\jdbc1.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line">        String user = info.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = info.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String url = info.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String driver = info.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.注册驱动</span></span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        <span class="comment">//2.获取连接</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 功能：释放资源</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet set, Statement statement,Connection connection)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set != <span class="keyword">null</span>) set.close();</span><br><span class="line">        <span class="keyword">if</span>(statement != <span class="keyword">null</span>) statement.close();</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="keyword">null</span>) connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在getConnection()方法中仍有可以提出的部分，使用静态代码块只执行一次加载配置文件，读取配置信息，注册驱动的步骤，使代码更加简洁，效率更高。注意：提出的步骤需要处理异常。将user\url。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">static</span> String url ;</span><br><span class="line">    <span class="keyword">static</span> String driver;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">        info.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\jdbc1.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line">        user = info.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        password = info.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        url = info.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        driver = info.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.注册驱动</span></span><br><span class="line"></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);<span class="comment">//编译时异常转为运行时异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：获取可用的连接对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.获取连接</span></span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 功能：释放资源</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet set, Statement statement,Connection connection)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set != <span class="keyword">null</span>) set.close();</span><br><span class="line">        <span class="keyword">if</span>(statement != <span class="keyword">null</span>) statement.close();</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="keyword">null</span>) connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="改进之后">改进之后</h3>
<p>有了JDBCUtils工具类，再看改进后的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPrepasredStatementByUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入待修改的客户编号：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> id = input.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入新的客户姓名：&quot;</span>);</span><br><span class="line">        String name = input.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----------------------连接数据库的步骤----------------</span></span><br><span class="line">        <span class="comment">//1.获取连接</span></span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        <span class="comment">//2.执行修改</span></span><br><span class="line">        String sql = <span class="string">&quot;UPDATE customers SET name = ? WHERE id = ?&quot;</span>;</span><br><span class="line">        PreparedStatement statement = connection.prepareStatement(sql);</span><br><span class="line">        statement.setString(<span class="number">1</span>, name);</span><br><span class="line">        statement.setInt(<span class="number">2</span>, id);</span><br><span class="line">        <span class="keyword">int</span> i = statement.executeUpdate();<span class="comment">//执行增删改，返回受影响的行数</span></span><br><span class="line">        System.out.println(i &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭</span></span><br><span class="line">        JDBCUtils.close(<span class="keyword">null</span>,statement,connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用工具类中的方法就简洁多啦！</p>
<p>再体会一下编译时异常变为运行时异常：</p>
<p>如果不抛异常，会报错</p>
<p><img src="/images/2020.11.16/1.png" /></p>
<p>对JDBCUtils工具类中的getConnection()方法进行try-catch处理，将编译时异常转为运行时异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取连接</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此时将不会报编译时错误</p>
<p><img src="/images/2020.11.16/2.png" /></p>
<p>对另一个close方法的处理也一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet set, Statement statement,Connection connection)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (set != <span class="keyword">null</span>) set.close();</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="keyword">null</span>) statement.close();</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPrepasredStatementByUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入待修改的客户编号：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> id = input.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入新的客户姓名：&quot;</span>);</span><br><span class="line">        String name = input.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----------------------连接数据库的步骤----------------</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement statement = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取连接</span></span><br><span class="line">            connection = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//2.执行修改</span></span><br><span class="line">            String sql = <span class="string">&quot;UPDATE customers SET name = ? WHERE id = ?&quot;</span>;</span><br><span class="line">            statement = connection.prepareStatement(sql);</span><br><span class="line">            statement.setString(<span class="number">1</span>, name);</span><br><span class="line">            statement.setInt(<span class="number">2</span>, id);</span><br><span class="line">            <span class="keyword">int</span> i = statement.executeUpdate();<span class="comment">//执行增删改，返回受影响的行数</span></span><br><span class="line">            System.out.println(i &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//3.关闭</span></span><br><span class="line">            JDBCUtils.close(<span class="keyword">null</span>, statement, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序算法</title>
    <url>/2020/11/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>几种经典的排序算法会慢慢总结，今天先总结一下快速排序算法。</p>
<h2 id="图文详解快速排序算法及java实现">【图文详解】快速排序算法及Java实现</h2>
<h3 id="基本思想">基本思想：</h3>
<p>采用“分治”的思想，对于一组数据，选择一个基准元素（base），通常选择第一个或最后一个元素，通过第一轮扫描，比base小的元素都在base左边，比base大的元素都在base右边，再有同样的方法递归排序这两部分，直到序列中所有数据均有序为止。</p>
<h3 id="图文详解">图文详解 :</h3>
<a id="more"></a>
<p>以 <strong>[3,4,6,1,2,4,7]</strong> 为例，以第一个元素<strong>3</strong>为base，定义左右两个指针（小熊<strong>l</strong>，小熊<strong>r</strong>），分别从两端开始扫描。从右向左找比<strong>3</strong>小的数，替换<strong>l</strong>所在位置的元素。再从左往右找比<strong>3</strong>大的数，然后替换r所在位置的元素。重复此过程直至两个小熊重合（两个指针指向同一元素），base替换此元素，此时第一轮结束。再递归排序base左右两部分的元素。</p>
<p>刚开始的时候让🐻<strong>l</strong> 指向序列的最左边，指向数字<strong>3</strong>。让🐻<strong>r</strong> 指向序列的最右边，指向数字 <strong>7</strong>。</p>
<p><img src="/images/qs1.jpg" /></p>
<p>首先🐻<strong>r</strong>出动，一步步向左移，直到找到比base小的数停下来，替换此时🐻<strong>l</strong>所在位置的元素</p>
<p><img src="/images/qs2.jpg" /></p>
<p>替换后的序列为 <strong>[2,4,6,1,2,4,7]</strong></p>
<p><img src="/images/qs3.jpg" /></p>
<p>🐻<strong>l</strong>出动，向右移直到找到比base大的数停下来，替换此时🐻<strong>r</strong>所在位置的元素</p>
<p><img src="/images/qs4.jpg" /></p>
<p>替换后的序列为 [2,4,6,1,4,4,7]，🐻r再次出动，重复上述步骤</p>
<p><img src="/images/qs5.jpg" /></p>
<p>比base小，替换🐻<strong>l</strong>所在位置的元素</p>
<p><img src="/images/qs6.jpg" /></p>
<p>替换后的序列为[2,1,6,1,4,4,7]，🐻l再次出动</p>
<p><img src="/images/qs7.jpg" /></p>
<p>比base大，替换🐻<strong>r</strong>所在位置的元素</p>
<p><img src="/images/qs8.jpg" /></p>
<p>替换后的序列为[2,1,6,6,4,4,7]，🐻r再次出动</p>
<p><img src="/images/qs9.jpg" /></p>
<p>此时🐻<strong>l</strong>、🐻<strong>r</strong>指向同一元素</p>
<p><img src="/images/qs10.jpg" /></p>
<p>base替换此元素</p>
<p><img src="/images/qs11.jpg" /></p>
<p>第一轮扫描完成，序列为 [2,1,3,6,4,4,7]，此时base(3)左边的元素都比它小，右边的元素都比它大，再对这两部分进行上述操作。</p>
<p><img src="/images/qs12.jpg" /></p>
<h3 id="代码实现">代码实现 :</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组有多个元素进行排序</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> base = nums[start];<span class="comment">//以要进行排序数组第0个元素为base</span></span><br><span class="line">        <span class="keyword">int</span> left = start;<span class="comment">//左指针</span></span><br><span class="line">        <span class="keyword">int</span> right = end;<span class="comment">//右指针</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//从右向左找，比base大，right--</span></span><br><span class="line">            <span class="keyword">while</span> (left&lt; right &amp;&amp; nums[right] &gt;= base) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比base小，替换left所在位置的数字</span></span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="comment">//从左向右找，比base小，left++</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= base)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比base大，替换right所在位置的数字</span></span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = base;<span class="comment">//此时left=right，用base替换这个位置的数字</span></span><br><span class="line">        <span class="comment">//排列比base小的数字的数组</span></span><br><span class="line">        quickSort(nums, start, left - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//排列比base大的数字的数组</span></span><br><span class="line">        quickSort(nums, left + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单例设计模式不同实现（秀恩爱版）</title>
    <url>/2020/11/03/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%A7%80%E6%81%A9%E7%88%B1%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h2 id="java设计模式单例设计模式秀恩爱版">Java设计模式—单例设计模式（秀恩爱版）</h2>
<p>对于系统中的某些类来说，只有一个实例很重要。<em>就像男朋友（类）只有一个ChaoWang(对象)。</em></p>
<p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。</p>
<a id="more"></a>
<h3 id="实现">实现：</h3>
<p>①. 私有化类的构造器</p>
<p>②. 提供一个自身的静态私有成员变量</p>
<p>③. 提供公共静态方法，返回当前类的对象。</p>
<p><strong>通常单例模式在Java语言中，有两种构建方式：</strong></p>
<ul>
<li>懒汉式。指全局的单例实例在<strong>第一次被使用时构建</strong>。</li>
<li>饿汉式。指全局的单例实例<strong>在类装载时构建</strong>，<strong>实例在整个程序周期都存在</strong>。</li>
</ul>
<p>单例模式有很多种写法，大部分写法都或多或少有一些不足。下面将分别对这几种写法进行介绍。</p>
<h3 id="饿汉式">1.饿汉式</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyFriend</span> </span>&#123;</span><br><span class="line">    <span class="comment">//①.私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BoyFriend</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//②.提供静态私有成员变量（我的男朋友ChaoW）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BoyFriend ChaoW = <span class="keyword">new</span> BoyFriend();</span><br><span class="line">    <span class="comment">//③. 提供公共静态方法，返回当前类的对象。   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BoyFriend <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ChaoW;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉式的<strong>好处</strong>是只<strong>在类加载的时候创建一次实例</strong>，不会存在多个线程创建多个实例的情况，<strong>避免了多线程同步的问题</strong>。但它的<strong>缺点</strong>也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就被创建，<strong>内存就被浪费</strong>了。</p>
<h3 id="懒汉式">2.懒汉式</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyFriend</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BoyFriend</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BoyFriend ChaoW;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BoyFriend <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//还未创建过对象</span></span><br><span class="line">        <span class="keyword">if</span>(ChaoW == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ChaoW = <span class="keyword">new</span> BoyFriend();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ChaoW;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>懒汉式<strong>单例是在需要的时候才去创建的</strong>，如果单例已经创建，再次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象。但<strong>缺点</strong>是此写法<strong>不安全</strong>，如果两个线程同时运行到判断ChaoW是否为null的if语句，并且ChaoW的确没有被创建时，那么两个线程都会创建一个实例，此时类型BoyFriend就不再满足单例模式的要求了。</p>
<h3 id="懒汉式改进加锁">3.懒汉式改进(加锁)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyFriend</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BoyFriend</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BoyFriend ChaoW;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> BoyFriend <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ChaoW == <span class="keyword">null</span>)&#123;  <span class="comment">//Single Checked</span></span><br><span class="line">            ChaoW = <span class="keyword">new</span> BoyFriend();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ChaoW;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样<strong>每次调用getName()方法时都被synchronized关键字锁住</strong>，可能会引起线程阻塞，影响程序的性能。</p>
<h3 id="懒汉式改进双重检验锁">4.懒汉式改进（双重检验锁）</h3>
<blockquote>
<p>为了在多线程环境下，不影响程序的性能，不让线程每次调用getName()方法时都加锁，而只是在实例未被创建时再加锁，在<strong>加锁处理里面还需要判断一次实例是否已存在</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyFriend</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BoyFriend</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BoyFriend ChaoW;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BoyFriend <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// 先判断实例是否存在，若不存在再对类对象进行加锁处理</span></span><br><span class="line">        <span class="keyword">if</span>(ChaoW == <span class="keyword">null</span>)&#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (BoyFriend.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ChaoW == <span class="keyword">null</span>)&#123; </span><br><span class="line">                    ChaoW = <span class="keyword">new</span> BoyFriend();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ChaoW;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面在同步代码块外多了一层ChaoW为空的判断。由于单例对象只需要创建一次，如果后面再次调用getName()只需要直接返回单例对象。因此，大部分情况下，调用getName()都不会执行到同步代码块，从而提高了程序性能。</p>
<h3 id="静态内部类">5.静态内部类</h3>
<blockquote>
<p>加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyFriend</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BoyFriend</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个私有的静态内部类，用于初始化一个静态final实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyFriendHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BoyFriend ChaoW = <span class="keyword">new</span> BoyFriend();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BoyFriend <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BoyFriendHolder.ChaoW;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式同样利用了<strong>类加载机制</strong>来保证只创建一个instance实例。它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。不一样的是，它是在内部类里面去创建对象实例。这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式<strong>可以同时保证延迟加载和线程安全</strong>。</p>
<h3 id="枚举">6.枚举</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyFriend</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyLove</span></span>&#123;</span><br><span class="line">    LOVE;</span><br><span class="line">    <span class="keyword">private</span> BoyFriend ChaoW;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyLove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ChaoW = <span class="keyword">new</span> BoyFriend();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BoyFriend <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ChaoW;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取实例的方式很简单，<code>MyLove.LOVE.getName()</code></p>
<p>单例是如何被保证的：</p>
<ul>
<li>首先，在枚举中我们<strong>明确了构造方法限制为私有</strong>，在我们访问枚举实例时会执行构造方法。</li>
<li>同时每个<strong>枚举实例都是<code>static final</code>类型的</strong>，也就表明只能被实例化一次。在调用构造方法时，我们的单例被实例化。</li>
<li>也就是说，因为enum中的实例被保证只会被实例化一次，所以我们的<code>LOVE</code>也被保证实例化一次。</li>
</ul>
<h3 id="单例模式的线程安全性">单例模式的线程安全性</h3>
<p>单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。总结一下：</p>
<p>（1）饿汉式：线程安全</p>
<p>（2）懒汉式：非线程安全</p>
<p>（3）双检锁：线程安全</p>
<p>（4）静态内部类：线程安全</p>
<p>（5）枚举：线程安全</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>递归与回溯</title>
    <url>/2020/11/15/%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h1 id="递归与回溯">递归与回溯</h1>
<h4 id="一句话讲递归与回溯">一句话讲递归与回溯</h4>
<p>递归：自己调用自己。本质就是找到前后的联系，找到递归的公式。</p>
<p>回溯：执行一次深度优先遍历（DFS），一条路走到底，走不通的时候，返回回来，继续执行，一直这样下去，直到回到起点。</p>
<a id="more"></a>
<h3 id="递归">递归</h3>
<h4 id="一般情况为">一般情况为：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;        </span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">recursion(参数<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="例子阶乘">例子：阶乘</h4>
<ol type="1">
<li><p>阶乘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//调用自己</span></span><br><span class="line">    <span class="keyword">return</span> n * recursion(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归过程：</p>
<p><img src="/images/递归.PNG" /></p></li>
</ol>
<p>求f(5)的时候，只需要求出f(4)即可，如果求f(4)我们要求出f(3)……，一层一层的调用，当n=1的时候，我们直接返回1，然后再一层一层的返回，直到返回f(5)为止。</p>
<h4 id="一些较实际的情况">一些较实际的情况：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;       </span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line">&#125;</span><br><span class="line">可能有一些逻辑运算   </span><br><span class="line">recursion(参数<span class="number">1</span>);    </span><br><span class="line">可能有一些逻辑运算    </span><br><span class="line">recursion(参数<span class="number">2</span>);            </span><br><span class="line">……    </span><br><span class="line">recursion(参数n);</span><br><span class="line">可能有一些逻辑运算</span><br></pre></td></tr></table></figure>
<h4 id="例子反转链表">例子：反转链表</h4>
<ol start="2" type="1">
<li><p>反转链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseList</span><span class="params">(ListNode root)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//（终止条件）</span></span><br><span class="line">     <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">       <span class="comment">//（递归调用）先打印下一个</span></span><br><span class="line">     reverseList(root.next);</span><br><span class="line">       <span class="comment">//（逻辑处理）把后面的都打印完了在打印当前节点</span></span><br><span class="line">     System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p></li>
</ol>
<p><img src="/images/reverse.PNG" /></p>
<h3 id="回溯">回溯</h3>
<p>回溯的本质，其实是在递归基础上进行了改进</p>
<h4 id="一般情况为-1">一般情况为：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(不满足继续递归查找的条件，通常为界限判断)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(满足查找条件)</span><br><span class="line">    <span class="keyword">return</span> 这个值/节点;</span><br><span class="line">递归左边</span><br><span class="line">递归右边</span><br><span class="line">递归结果-回溯</span><br></pre></td></tr></table></figure>
<h4 id="例子矩阵中的路径剑指offer12">例子：矩阵中的路径（剑指Offer12）</h4>
<p>判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [</span><br><span class="line">			   [&quot;a&quot;,&quot;b&quot;],</span><br><span class="line">               [&quot;c&quot;,&quot;d&quot;]</span><br><span class="line">              ],</span><br><span class="line">     word &#x3D; &quot;abcd&quot;</span><br><span class="line"></span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：回溯算法（DFS+剪枝）。遍历矩阵中所以字符，先朝一个方向搜索到底，再回溯至上个节点，再沿另一方向搜索，以此类推。在搜索中，遇到匹配不成功（如索引越界、此元素已访问、此矩阵元素和目标字符不同）的情况就立即返回。</p></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, words, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边界条件（越界、与目标元素不同）</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] != word[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//全部匹配完成</span></span><br><span class="line">        <span class="keyword">if</span>(k == word.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//将当前元素标记为&#x27;\0&#x27;,不可再被访问</span></span><br><span class="line">        <span class="comment">//递归上下左右</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) ||dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || dfs(board, word, i , j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        board[i][j] = temp;<span class="comment">//恢复其本身值</span></span><br><span class="line">        <span class="comment">//递归结果判断-回溯</span></span><br><span class="line">        <span class="keyword">return</span> res;<span class="comment">//上面4个方向，只要有一个能查找到，就返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="例子二叉搜索树的最近公共祖先剑指offer68-">例子：二叉搜索树的最近公共祖先(剑指Offer68-Ⅱ)</h4>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="/images/OFfer68.PNG" /></p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思想：通过递归对二叉树进行后序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p, q 在节点 root 的异侧时，节点root 即为最近公共祖先，则向上返回 root 。</p>
<p>p,q和root有三种情况： 1). p,q在root左右，返回root 2). p,q都在root左，返回<code>lowestCommonAncestor( root.left, TreeNode p, TreeNode q)</code> 3). p,q都在root右，返回<code>lowestCommonAncestor( root.right, TreeNode p, TreeNode q)</code></p>
<ul>
<li><p>递归终止条件 if(root == null) return null;//越过叶子节点，返回null if(root == p) return p;//找到p，返回p if(root == q) return q;//找到q，返回q</p></li>
<li><p>递归体 递归左子节点，返回值为left <code>TreeNode left = lowestCommonAncestor( root.left, TreeNode p, TreeNode q);</code> 递归右子节点，返回值为right <code>TreeNode right = lowestCommonAncestor( root.right, TreeNode p, TreeNode q);</code></p></li>
<li><p>递归结果 1).left == null &amp;&amp; right == null 两边都没找到，返回null 2).left == null 右边找到，返回right 3). right == null 右边找到，返回left 4).left != null &amp;&amp; right != null 说明p,q在root两侧，返回root</p></li>
</ul></li>
<li><p>图文过程详解</p>
<p><img src="/images/Offer68/1.PNG" /></p>
<p><img src="/images/Offer68/2.PNG" /></p>
<p><img src="/images/Offer68/3.PNG" /></p>
<p><img src="/images/Offer68/4.PNG" /></p>
<p><img src="/images/Offer68/5.PNG" /></p>
<p><img src="/images/Offer68/6.PNG" /></p>
<p><img src="/images/Offer68/7.PNG" /></p>
<p><img src="/images/Offer68/8.PNG" /></p>
<p><img src="/images/Offer68/9.PNG" /></p>
<p><img src="/images/Offer68/10.PNG" /></p>
<p><img src="/images/Offer68/11.PNG" /></p>
<p><img src="/images/Offer68/12.PNG" /></p>
<p><img src="/images/Offer68/13.PNG" /></p>
<p><img src="/images/Offer68/14.PNG" /></p>
<p><img src="/images/Offer68/15.PNG" /></p>
<p><img src="/images/Offer68/16.PNG" /></p>
<p><img src="/images/Offer68/17.PNG" /></p>
<p><img src="/images/Offer68/18.PNG" /></p></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归体</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor( root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor( root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归结果判断-回溯</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<!--2020/11/24更新-->
<p>与上一题相似的<strong>机器人运动范围</strong>问题</p>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法一：递归回溯（DFS）。与上一题类似。</p>
<ul>
<li>递归出口： ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过</li>
<li>递归体：将[i,j]状态设为true，代表已走过，在回溯之后继续走的时候需要避开已走过的方格</li>
<li>回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];        </span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,visited);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算两个数的位数和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> si = <span class="number">0</span>, sj = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">          si += i % <span class="number">10</span>;</span><br><span class="line">          i/=<span class="number">10</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">0</span>)&#123;</span><br><span class="line">            sj += j % <span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> si + sj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS+回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">boolean</span>[][] visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口： ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 </span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n || sum(i,j) &gt; k || visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将【i,j】状态设为true，代表已走过，在回溯之后继续走的时候需要避开已走过的方格</span></span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, m, n, k, visited) + dfs(i, j + <span class="number">1</span>, m, n, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<!--2020/11/26更新-->
<p><strong>礼物的最大价值</strong></p>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法一：递归回溯。每次只能向右或向下，对每一格的来源只有向左或向上。从右下角开始递归，定义helper方法找到当前位置的礼物最大值。</p>
<ul>
<li>递归出口： ① 行列索引越界 ，返回 0（礼物最小为1） ② 当前元素已访问过 ，返回当前结果</li>
<li>递归体：比较左边格子与上边格子的返回结果，取最大值，与当前位置的价值加和。将visited[i,j]状态设为true，代表已走过，在回溯之后继续走的时候需要避开已走过的方格。</li>
<li>回溯返回值： 返回 当前位置加和后的结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;<span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">int</span> n ;<span class="comment">//列数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(grid.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> helper(grid, m - <span class="number">1</span>, n - <span class="number">1</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口：边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || j &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;         </span><br><span class="line">        <span class="comment">//如果已访问过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(visited[i][j] == <span class="keyword">true</span>) <span class="keyword">return</span> grid[i][j];</span><br><span class="line">        <span class="comment">//递归比较当前位置的左边格子与上边格子的返回结果，取最大值</span></span><br><span class="line">        grid[i][j] += Math.max(helper(grid, i - <span class="number">1</span>, j, visited),helper(grid, i, j - <span class="number">1</span>, visited));</span><br><span class="line">        <span class="comment">//并把当前元素状态设为true</span></span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> grid[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：动态规划。</p></li>
</ul>
<h3 id="结束语">结束语</h3>
<p>算法小白对递归和回溯的理解只到这里，希望随着刷的题越来越多，理解也越来越清晰透彻，到时再来分享！</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>递归与回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先遍历</title>
    <url>/2020/10/28/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="深度优先遍历">深度优先遍历</h2>
<h3 id="思想">思想：</h3>
<p>对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。</p>
<a id="more"></a>
<h3 id="二叉树的深度优先遍历">二叉树的深度优先遍历</h3>
<p>二叉树的深度优先遍历分为前序遍历，中序遍历和后续遍历。</p>
<ul>
<li>前序遍历：先访问根，在访问左子树，最后访问右子树，总结就是“根左右”；</li>
<li>中序遍历：先访问左子树，再访问根，最后访问右子树，总结就是“左根右”；</li>
<li>后序遍历：先访问左子树，再访问右子树，最后访问根，总结就是“左右根”；</li>
</ul>
<p>通常采用<strong>递归</strong>的方式实现遍历，非递归方式需要结合<strong>栈</strong>（后进先出）的特点实现。</p>
<p>以前序遍历为例：</p>
<h4 id="非递归方式实现栈">1. 非递归方式实现（栈）</h4>
<p><img src="/images/dfs1.PNG" /></p>
<p>1.1 二叉树结构定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>1.2 创建上图的树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">initTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode node1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    TreeNode node2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode node3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode node4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    TreeNode node5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">    TreeNode node6 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">    TreeNode node7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">    TreeNode node8 = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">    TreeNode node9 = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    node1.left = node2;</span><br><span class="line">    node1.right = node3;</span><br><span class="line">    node2.left = node4;</span><br><span class="line">    node2.right = node5;</span><br><span class="line">    node3.left = node6;</span><br><span class="line">    node3.right = node7;</span><br><span class="line">    node5.right = node8;</span><br><span class="line">    node7.left = node9;</span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.3 非递归方式实现dfs</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//栈先进后出，先将右子节点压入栈</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>1.4 测试及结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        dfs(initTree());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/dfs2.PNG" /></p>
<h4 id="递归方式实现">2.递归方式实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="图的深度优先遍历">图的深度优先遍历</h3>
<p>同样有两种实现方式：递归和非递归。</p>
<p>递归好理解一点，非递归还没摸透，等弄懂了再来填坑~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从第i个节点开始深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 标记第i个节点已遍历</span></span><br><span class="line">    vertex[i].visited = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 打印当前遍历的节点</span></span><br><span class="line">    System.out.println(vertex[i].getValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历邻接矩阵中第i个节点的直接联通关系</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt; vertex.length;j++)&#123;</span><br><span class="line">        <span class="comment">// 目标节点与当前节点直接联通，并且该节点还没有被访问，递归</span></span><br><span class="line">        <span class="keyword">if</span>(adjMat[i][j]==<span class="number">1</span> &amp;&amp; vertex[j].visited==<span class="keyword">false</span>)&#123;</span><br><span class="line">            traverse(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的深度优先遍历（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化节点遍历标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">        vertex[i].visited = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从没有被遍历的节点开始深度遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; vertex.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vertex[i].visited == <span class="keyword">false</span>)&#123;</span><br><span class="line">            <span class="comment">// 若是连通图，只会执行一次</span></span><br><span class="line">            traverse(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Java-MySQL学生管理系统</title>
    <url>/2020/11/19/Java-MySQL%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="javamysql学生管理系统">Java+MySQL学生管理系统</h1>
<p>源码：https://github.com/ruiwang-97/StudentManagement.git</p>
<p><a href="需求分析" class="uri">需求分析</a></p>
<p><a href="设计思路" class="uri">设计思路</a></p>
<p><a href="具体实现" class="uri">具体实现</a></p>
<p><a href="测试效果" class="uri">测试效果</a></p>
<h2 id="需求分析">需求分析</h2>
<p>这是一个学生管理系统，以管理员身份登录，实现对学员以及年级信息的增删改查操作。</p>
<p>具体需要实现的功能有：</p>
<a id="more"></a>
<p>1、统计学生人数。</p>
<p>2、查看学生名单。</p>
<p>3、按学号查询学生姓名。</p>
<p>4、按姓名查询学生信息。</p>
<p>5、删除学生记录。</p>
<p>6、修改学生年级。</p>
<p>7、添加学生。</p>
<p>8、退出。</p>
<p>分析：</p>
<p>其中1，2，3，4为查询操作，1、3返回单个值，调用dao包中BasicDao中的<code>scalar()</code>方法，2返回多个对象，调用BasicDao中的<code>queryMulti()</code>方法，3返回单个对象，调用BasicDao中的<code>querySingle()</code>方法。5，6，7为增删改，调用<code>update()</code>方法。</p>
<h2 id="设计思路">设计思路</h2>
<p>分为五个模块：dao、domain、service、view、utils。其中</p>
<ul>
<li><p>dao包访问数据类，包括BasicDao，StuDao，ManagerDao。提供对数据的增删改查的通用方法。</p></li>
<li><p>domain包实体类，包括Manager，Student。</p></li>
<li><p>service包业务类，包括managerService提供登录验证方法，stdentService提供增删改查方法。</p></li>
<li><p>view包界面类，stuView提供主界面，TSUtility封装控制台操作。</p></li>
<li><p>utils包数据库连接类，通过德鲁伊数据库连接池获取连接对象。</p></li>
</ul>
<h2 id="具体实现">具体实现</h2>
<h3 id="mysql部分">MySQL部分</h3>
<ol type="1">
<li><p>建库<code>studentm</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE studentm;</span><br></pre></td></tr></table></figure></li>
<li><p>建表</p>
<ul>
<li><p>manager表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE manager(</span><br><span class="line">id INT(11)PRIMARY KEY ,</span><br><span class="line">username VARCHAR(20) NOT NULL,</span><br><span class="line">pword VARCHAR(20) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>stu表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">id INT(11)PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">stunumber VARCHAR(20) NOT NULL,</span><br><span class="line">stuname VARCHAR(20) NOT NULL,</span><br><span class="line">gender VARCHAR(20) NOT NULL,</span><br><span class="line">grade VARCHAR(20) NOT NULL,</span><br><span class="line">tel INT(20) NOT NULL,</span><br><span class="line">email VARCHAR(20) NOT NULL,</span><br><span class="line">birth VARCHAR(20) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>设置管理员用户名、密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO &#96;manager&#96; VALUES(1,&#39;john&#39;,8888);</span><br></pre></td></tr></table></figure></li>
<li><p>可以先加入一些学生用于测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO &#96;stu&#96; VALUES(1,&#39;S0018&#39;,&#39;梅小凤&#39;,&#39;女&#39;,&#39;B2&#39;,158111876544,&#39;xiaofeng@qq.com&#39;,&#39;1998-3-3&#39;),(2,&#39;S0035&#39;,&#39;晓梅&#39;,&#39;女&#39;,&#39;B3&#39;,156091875566,&#39;xiaomei@qq.com&#39;,&#39;1996-2-16&#39;),(</span><br><span class="line">3,&#39;S0025&#39;,&#39;王小锐&#39;,&#39;女&#39;,&#39;B5&#39;,18345278844,&#39;rui97@qq.com&#39;,&#39;1997-9-16&#39;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="java部分">Java部分</h3>
<ol type="1">
<li><p>导入jar包和druid.properties(注意修改库名)，utils包下的JDBCUtilsByDruid类与数据库建立连接和关闭连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sm.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.ECField;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 此类是通过德鲁伊数据库连接池获取连接对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/17$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtilsByDruid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> DataSource ds;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\druid.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1.创建一个指定参数的数据流连接池</span></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从数据库连接池中获取可用的连接对象</span></span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> statement</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet set, Statement statement, Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (set != <span class="keyword">null</span>) &#123;</span><br><span class="line">                set.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>建立dao包，定义一个用来被继承的对数据库进行基本操作的BasicDao，提供通用的增删改查方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sm.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.DbUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"><span class="keyword">import</span> sm.utils.JDBCUtilsByDruid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供通用的增删改查方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/18$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能：通用的增删改方法，针对于任何表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    QueryRunner qr = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql, Object... params)</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> update = qr.update(connection, sql, params);</span><br><span class="line">            <span class="keyword">return</span> update;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：返回单个对象，针对于任何表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">querySingle</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... params)</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line"><span class="comment">//        QueryRunner qr = new QueryRunner();</span></span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> BeanHandler&lt;T&gt;(clazz), params);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：返回多个对象，针对于任何表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">queryMulti</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... params)</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line"><span class="comment">//            QueryRunner qr = new QueryRunner();</span></span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> BeanListHandler&lt;T&gt;(clazz), params);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：返回单个值，针对于任何表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">scalar</span><span class="params">(String sql, Object... params)</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line"><span class="comment">//            QueryRunner qr = new QueryRunner();</span></span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> ScalarHandler(), params);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StuDao和ManagerDao继承于BasicDao。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sm.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sm.domain.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuDao</span> <span class="keyword">extends</span> <span class="title">BasicDao</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sm.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sm.domain.Manager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerDao</span> <span class="keyword">extends</span> <span class="title">BasicDao</span>&lt;<span class="title">Manager</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>建立domain包，Manager类和Student对应MySQL中的表定义属性及其类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sm.domain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 管理员类 id,username,pword</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/18$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String pword;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(<span class="keyword">int</span> id, String username, String pword)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.pword = pword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPword</span><span class="params">(String pword)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pword = pword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Manager&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pword=&#x27;&quot;</span> + pword + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sm.domain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 学生类  id,stunumber,stuname,gender,grade,tel,email,birth</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/18$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String stunumber;<span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">private</span> String stuname;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String grade;<span class="comment">//年级</span></span><br><span class="line">    <span class="keyword">private</span> String tel;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String birth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String stunumber, String stuname, String gender, String grade, String tel, String email, String birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.stunumber = stunumber;</span><br><span class="line">        <span class="keyword">this</span>.stuname = stuname;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">        <span class="keyword">this</span>.tel = tel;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStunumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stunumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStunumber</span><span class="params">(String stunumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stunumber = stunumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStuname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuname</span><span class="params">(String stuname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuname = stuname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(String grade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTel</span><span class="params">(String tel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirth</span><span class="params">(String birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stunumber + <span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                 stuname + <span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                 gender + <span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                 grade + <span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                 tel + <span class="string">&quot;\t&quot;</span>+</span><br><span class="line">                 email + <span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                 birth;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>建立service包，其中managerService类提供管理员登录验证的方法，studentService类用于提供学生增删改查的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sm.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sm.dao.ManagerDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 提供管理员登录验证的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/18$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">managerService</span> </span>&#123;</span><br><span class="line">    ManagerDao dao = <span class="keyword">new</span> ManagerDao();</span><br><span class="line"><span class="comment">//登录验证</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username,String password)</span></span>&#123;</span><br><span class="line"><span class="comment">//此处易出现java.lang.ClassCastException异常，Long型不可强转为Boolean型</span></span><br><span class="line">        Long count =  (Long)dao.scalar(<span class="string">&quot;select count(*) from manager where username=? and pword=?&quot;</span>, username,password);</span><br><span class="line">        <span class="keyword">return</span> count &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sm.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sm.dao.StuDao;</span><br><span class="line"><span class="keyword">import</span> sm.domain.Student;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此类用于提供学生增删改查的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/18$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">studentService</span> </span>&#123;</span><br><span class="line">    StuDao dao = <span class="keyword">new</span> StuDao();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、统计学生人数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nums</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long longnums = (Long) dao.scalar(<span class="string">&quot;select count(*) from stu&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> nums = longnums.intValue();</span><br><span class="line">        <span class="keyword">return</span> nums ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、查看学生名单-返回学生列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getAllStudents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Student&gt; students = dao.queryMulti(<span class="string">&quot;select * from stu&quot;</span>,Student.class);</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、按学号查询学生姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryByStuNumber</span><span class="params">(String stunumber)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String) dao.scalar(<span class="string">&quot;select stuname from stu where stunumber = ?&quot;</span>, stunumber);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4、按姓名查询学生信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">queryByStuName</span><span class="params">(String stuName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.querySingle(<span class="string">&quot;select * from stu where stuname like ?&quot;</span>, Student.class, <span class="string">&quot;%&quot;</span>+stuName+<span class="string">&quot;%&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.删除学生记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteStu</span><span class="params">(String stunumber)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.update(<span class="string">&quot;delete from stu where stunumber = ?&quot;</span>, stunumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.修改学生年级</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">changeStu</span><span class="params">(String stunumber,String newGrade)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> dao.update(<span class="string">&quot;update stu set grade = ? where stunumber = ?&quot;</span>,newGrade,stunumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.添加学生</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addStu</span><span class="params">(<span class="keyword">int</span> id, String stunumber, String stuname, String gender, String grade, String tel, String email, String birth)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> dao.update(<span class="string">&quot;insert into stu values(?,?,?,?,?,?,?,?)&quot;</span>,id,stunumber,stuname,gender,grade,tel,email,birth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>建立view包，其中TSUtility工具类用于读取控制台操作，stuView用于主界面的显示。首先是登陆界面，输入正确的用户名和密码后进入主菜单，控制台输入相应功能序号调取相应方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sm.view;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sm.domain.Student;</span><br><span class="line"><span class="keyword">import</span> sm.service.managerService;</span><br><span class="line"><span class="keyword">import</span> sm.service.studentService;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 主界面显示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wang Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/18$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">stuView</span> </span>&#123;</span><br><span class="line">    managerService ms = <span class="keyword">new</span> managerService();</span><br><span class="line">    studentService ss = <span class="keyword">new</span> studentService();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> stuView().login();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录界面显示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">        String username = input.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        String password = input.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ms.login(username, password))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            showMainMenu();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：显示主菜单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showMainMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> loopFlag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">char</span> key = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            init();</span><br><span class="line">            key = TSUtility.readMenuSelection();</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;当前学生人数为：&quot;</span> + ss.nums());</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">                    listStudents();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">                    queryByStuNumber();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">                    queryByStuName();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">                    deleteByStuName();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">                    changeGrade();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">                    addStudent();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;确认是否退出(Y/N)：&quot;</span>);</span><br><span class="line">                    <span class="keyword">char</span> yn = TSUtility.readConfirmSelection();</span><br><span class="line">                    <span class="keyword">if</span> (yn == <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">                        loopFlag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (loopFlag);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始显示主菜单</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================请选择操作键================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1、统计学生人数&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2、查看学生名单&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3、按学号查询学生姓名&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4、按姓名查询学生信息&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5、删除学生记录&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6、修改学生年级&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7、添加学生&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8、退出&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示当前学生列表方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------学生列表-----------------------------&quot;</span>);</span><br><span class="line">        List&lt;Student&gt; allStudents = ss.getAllStudents();</span><br><span class="line">        <span class="keyword">if</span> (allStudents.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有客户记录！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;学号\t姓名\t性别\t年级\t电话\t邮箱\t出生日期&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student e : allStudents) &#123;</span><br><span class="line">            System.out.println(e.getStunumber() + <span class="string">&quot;\t&quot;</span> + e.getStuname()  + <span class="string">&quot;\t&quot;</span> + e.getGender() + <span class="string">&quot;\t&quot;</span></span><br><span class="line">                    + e.getGrade() + <span class="string">&quot;\t&quot;</span> + e.getTel() + <span class="string">&quot;\t&quot;</span> + e.getEmail() + <span class="string">&quot;\t&quot;</span> + e.getBirth());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按学号查询学生姓名方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queryByStuNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================查询操作================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生学号：&quot;</span>);</span><br><span class="line">        String s = TSUtility.readString();</span><br><span class="line">        String s1 = ss.queryByStuNumber(s);</span><br><span class="line">        <span class="keyword">if</span> (s1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询失败,请重新操作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按姓名查询学生信息方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queryByStuName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================查询操作================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生姓名：&quot;</span>);</span><br><span class="line">        String s = TSUtility.readString();</span><br><span class="line">        Student s1 = ss.queryByStuName(s);</span><br><span class="line">        <span class="keyword">if</span> (s1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;学号\t姓名\t性别\t年级\t电话\t邮箱\t出生日期&quot;</span>);</span><br><span class="line">            System.out.println(s1);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;查询失败，请重新操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除学生记录方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteByStuName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================删除操作================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生学号：&quot;</span>);</span><br><span class="line">        String s = TSUtility.readString();</span><br><span class="line">        System.out.print(<span class="string">&quot;确认是否删除(Y/N)：&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> yn = TSUtility.readConfirmSelection();</span><br><span class="line">        <span class="keyword">if</span> (yn == <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(yn == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ss.deleteStu(s) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">&quot;输入信息错误，请重新操作！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败，请重新操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改学生年级方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeGrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================修改操作================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生学号：&quot;</span>);</span><br><span class="line">        String s = TSUtility.readString();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入修改后的年级：&quot;</span>);</span><br><span class="line">        String newGrade = TSUtility.readString();</span><br><span class="line">        <span class="keyword">if</span> (ss.changeStu(s,newGrade) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;确认是否修改(Y/N)：&quot;</span>);</span><br><span class="line">            <span class="keyword">char</span> yn = TSUtility.readConfirmSelection();</span><br><span class="line">            <span class="keyword">if</span> (yn == <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;修改失败，请重新操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加学生方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================添加操作================&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生序号：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> id = TSUtility.readInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生学号：&quot;</span>);</span><br><span class="line">        String stuNumber = TSUtility.readString();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生姓名：&quot;</span>);</span><br><span class="line">        String stuName = TSUtility.readString();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生性别：&quot;</span>);</span><br><span class="line">        String gender = TSUtility.readString();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生年级：&quot;</span>);</span><br><span class="line">        String grade = TSUtility.readString();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生电话：&quot;</span>);</span><br><span class="line">        String tel = TSUtility.readString();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生邮箱：&quot;</span>);</span><br><span class="line">        String email = TSUtility.readString();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生出生日期:&quot;</span>);</span><br><span class="line">        String birth = TSUtility.readString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ss.addStu(id,stuNumber, stuName, gender, grade, tel, email, birth) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;确认是否添加(Y/N)：&quot;</span>);</span><br><span class="line">            <span class="keyword">char</span> yn = TSUtility.readConfirmSelection();</span><br><span class="line">            <span class="keyword">if</span> (yn == <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;添加失败，请重新操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="测试效果">测试效果</h2>
<ol type="1">
<li><p>登陆界面</p>
<ul>
<li><p>如果用户名密码输入正确，显示“登陆成功！”</p>
<p><img src="/images/SM/1.PNG" /></p></li>
<li><p>如果用户名密码输入不正确，显示“登陆失败！”</p>
<p><img src="/images/SM/2.PNG" /></p></li>
</ul></li>
<li><p>功能1、统计学生人数</p>
<p><img src="/images/SM/3.PNG" /></p></li>
<li><p>功能2、查看学生名单</p>
<p><img src="/images/SM/4.PNG" /></p></li>
<li><p>功能3、按学号查询学生姓名</p>
<ul>
<li><p>如果输入学号正确</p>
<p><img src="/images/SM/5.PNG" /></p></li>
<li><p>如果输入学号不正确</p>
<p><img src="/images/SM/6.PNG" /></p></li>
</ul></li>
<li><p>功能4、按姓名查询学生信息</p>
<ul>
<li><p>如果输入名字正确（可以模糊查询）</p>
<p><img src="/images/SM/7.PNG" /></p></li>
<li><p>如果输入名字不正确</p>
<p><img src="/images/SM/8.PNG" /></p></li>
</ul></li>
<li><p>功能5、删除学生记录</p>
<ul>
<li><p>如果输入学号正确</p>
<ul>
<li><p>确认删除(Y)</p>
<p><img src="/images/SM/9.PNG" /></p>
<p>删除后查看学生列表，确定已删除</p>
<p><img src="/images/SM/10.PNG" /></p></li>
<li><p>不确认(N)</p>
<p>自动退出，重新回到主菜单</p></li>
</ul></li>
<li><p>如果输入学号不正确</p>
<p><img src="/images/SM/11.PNG" /></p></li>
</ul></li>
<li><p>功能6、修改学生年级</p>
<p>例如将学号为S0018的学生年级改为B1</p>
<ul>
<li><p>确认修改(Y)</p>
<p><img src="/images/SM/12.PNG" /></p>
<p>修改后查看学生列表，确定已修改</p>
<p><img src="/images/SM/15.PNG" /></p></li>
<li><p>不确认(N)</p>
<p>自动退出，重新回到主菜单</p></li>
</ul></li>
<li><p>功能7、添加学生</p>
<p>输入学生序号、学号、姓名、性别、年级、电话、邮箱、出生日期</p>
<ul>
<li><p>确认添加(Y)</p>
<p><img src="/images/SM/13.PNG" /></p>
<p>添加后查看学生列表，确定已添加</p>
<p><img src="/images/SM/14.PNG" /></p></li>
<li><p>不确认(N)</p>
<p>自动退出，重新回到主菜单</p></li>
</ul></li>
<li><p>功能8、退出</p>
<ul>
<li><p>确认退出(Y)</p>
<p><img src="/images/SM/16.PNG" /></p></li>
<li><p>不确认(N)</p>
<p>自动退出，重新回到主菜单</p></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>Java Mysql</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—递归解决树</title>
    <url>/2020/12/16/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3%E6%A0%91/</url>
    <content><![CDATA[<p>对于树，经常用的算法有递归，回溯，BFS，DFS等。下面是一些用递归算法来解的题： <a href="#104，二叉树的最大深度，easy">104，二叉树的最大深度，easy</a></p>
<p><a href="#110，平衡二叉树，easy">110，平衡二叉树，easy</a></p>
<p><a href="#543，二叉树的直径，easy">543，二叉树的直径，easy</a></p>
<p><a href="#226，翻转二叉树，easy">226，翻转二叉树，easy</a></p>
<p><a href="#617，合并二叉树，easy">617，合并二叉树，easy</a></p>
<p><a href="#112，路径总和，easy">112，路径总和，easy</a></p>
<p><a href="#113，路径总和Ⅱ，midium">113，路径总和Ⅱ，midium</a></p>
<p><a href="#572，另一个树的子树，easy">572，另一个树的子树，easy</a></p>
<p><a href="#101，对称二叉树，easy">101，对称二叉树，easy</a></p>
<p><a href="#111，二叉树的最小深度，easy">111，二叉树的最小深度，easy</a></p>
<p><a href="#404，左叶子之和，easy">404，左叶子之和，easy</a></p>
<p><a href="#687，最长同值路径，medium">687，最长同值路径，medium</a></p>
<p><a href="#671，二叉树中第二小的节点，easy">671，二叉树中第二小的节点，easy</a></p>
<a id="more"></a>
<h5 id="二叉树的最大深度easy">104，二叉树的最大深度，easy</h5>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例： 给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre>
<p>返回它的最大深度 3 。</p>
<ul>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftDepth &gt;= rightDepth ? leftDepth + <span class="number">1</span> : rightDepth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="平衡二叉树easy">110，平衡二叉树，easy</h5>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<p>示例 1：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/341009251c7788edc838975732064bf1.png" alt="img" /><figcaption>img</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/bce64ca4c0e80b345a5a286122112851.png" alt="img" /><figcaption>img</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思想：先判断root 为根节点的树是不是平衡二叉树，（即比较左右子树的高度差是否不超过1），再判断以root.left 和 root.right 为根节点的树是不是平衡二叉树。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">int</span> l = depth(root.left);</span><br><span class="line">         <span class="keyword">int</span> r = depth(root.right);</span><br><span class="line">    	 <span class="comment">//判断当前根节点的树是否为平衡二叉树</span></span><br><span class="line"> 	    <span class="keyword">if</span>(Math.abs(l - r) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> (isBalanced(root.left) &amp;&amp; isBalanced(root.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取整棵树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(root.left),depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="二叉树的直径easy">543，二叉树的直径，easy</h5>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p>示例 : 给定二叉树</p>
<pre><code>      1
     / \
    2   3
   / \     
  4   5    </code></pre>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p>
<ul>
<li><p>方法：DFS递归。</p></li>
<li><p>思路：直径 = 任意两个结点路径长度中的最大值，可以看做树内的某一节点的左子树节点数l + 右子树节点数r - 1，所有节点的l + r - 1中的最大值即为直径。定义一个递归函数计算经过的左右子树的节点数l + r，函数返回给定节点为根的子树的深度。递归搜索每个节点并设一个全局变量 ans 记录 l + r 的最大值，最后返回 ans 即为树的直径。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回最大的 L+R</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> r = depth(root.right);</span><br><span class="line">        ans = Math.max(ans, l + r);<span class="comment">//找到最大直径</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;<span class="comment">//树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="翻转二叉树easy">226，翻转二叉树，easy</h5>
<p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9</code></pre>
<p>输出：</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1</code></pre>
<ul>
<li><p>方法一：递归。</p></li>
<li><p>思路：分别对左右子树都进行翻转，再交换。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode leftTree = root.left;<span class="comment">//保存原来的左子树</span></span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(leftTree);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：借助栈（DFS）。</p></li>
<li><p>思路：先将根节点压入栈。栈非空时，弹出栈顶节点，如果弹出节点的左右子节点有非空，将其压入栈，并进行交换，重复此过程直到栈空。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode temp = node.right;</span><br><span class="line">            node.right = node.left;</span><br><span class="line">            node.left = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="合并二叉树easy">617，合并二叉树，easy</h5>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">     1                           2 </span><br><span class="line">   &#x2F;   \                       &#x2F;   \</span><br><span class="line">  3     2                     1     3</span><br><span class="line"> &#x2F;                             \     \</span><br><span class="line">5                               4     7                               </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>
<p>注意: 合并必须从两个树的根节点开始。</p>
<ul>
<li><p>方法一：递归。(dfs)</p></li>
<li><p>思路：新建一棵树，如果原来两棵树的节点都存在，直接相加；如果有一个不存在，返回另一个节点。递归节点的左右子节点，作为新树的左右子树。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1 == <span class="keyword">null</span> ? t2 : t1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode newTree = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">        newTree.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">        newTree.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> newTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="路径总和easy">112，路径总和，easy</h5>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例: 给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1</code></pre>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子- 方法一：递归（dfs）</p>
<ul>
<li><p>思路：以当前根节点为例，如果为null，返回false；如果为叶子节点，判断当前节点值是否与sum相等并返回；如果不是叶子节点，递归搜索左右子节点。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.val == sum;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="路径总和midium">113，路径总和Ⅱ，midium</h5>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例: 给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \    / \
    7    2  5   1</code></pre>
<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法：递归回溯（dfs）。</p></li>
<li><p>思路：</p>
<ul>
<li>回溯条件：
<ol type="1">
<li>节点为空— 如果当前节点为空，说明节点没有孩子，循着这条路径，已经找不到符合条件的路径。</li>
<li>节点为叶子节点— 如果当前节点是叶子节点并且它的值满足题目要求，则它所在的路径就是满足要求的。</li>
</ol></li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        dfs(root, sum, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//把当前节点值加入到list中</span></span><br><span class="line">         list.add(root.val);</span><br><span class="line">        <span class="comment">//叶子节点且此节点值=sum</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) res.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//还没到叶子节点，继续从左右节点向下找</span></span><br><span class="line">        dfs(root.left, sum - root.val, res, list);</span><br><span class="line">        dfs(root.right, sum - root.val, res, list);</span><br><span class="line">        <span class="comment">//防止分支污染，遍历完当前节点的左子树、右子树，说明经过这个节点的路径已经被遍历完，因此要回溯到当前节点的父节点</span></span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0ODMyNDk0Mw==&amp;mid=2247487910&amp;idx=1&amp;sn=2670aec7139c6b98e83ff66114ac1cf7&amp;chksm=fb418286cc360b90741ed54fecd62fd45571b2caba3e41473a7ea0934f918d4b31537689c664&amp;scene=21#wechat_redirect">关于递归与回溯的详解</a></p></li>
</ul>
<h5 id="另一个树的子树easy">572，另一个树的子树，easy</h5>
<p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<p>示例 1: 给定的树 s:</p>
<pre><code>         3
        / \
       4   5
      / \    
     1   2   </code></pre>
<p>给定的树 t：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>
<p>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
<p>示例 2: 给定的树 s：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \    </span><br><span class="line">1   2 </span><br></pre></td></tr></table></figure>
<p>给定的树 t：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>
<p>返回 false。</p>
<ul>
<li><p>方法：建立一个递归函数，判断两棵树是否相等。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第二棵树为空，一定是子树</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//第一棵树为空，没有子树</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//递归比较t是否是s的左子树和右子树的一部分，或s与t是两棵相同的树</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t) || isSameTree(s, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断两棵树是否相同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode s, TreeNode t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果其中有一个节点为空或两节点值不相等时，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span> || s.val != t.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//递归比较左子树和右子树是否相同</span></span><br><span class="line">        <span class="keyword">return</span> isSameTree(s.left, t.left) &amp;&amp; isSameTree(s.right, t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="对称二叉树easy">101，对称二叉树，easy</h5>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3</code></pre>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>    1
   / \
  2   2
   \   \
   3    3</code></pre>
<ul>
<li><p>方法一：递归。</p></li>
<li><p>思路：建立一个递归函数，移动两个指针遍历这棵树，判断根节点的左右子树是否对称。在主函数调用此递归函数，参数为根的左子节点和右子节点。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> check(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用两个指针检查树是否对称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span> || p.val != q.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="二叉树的最小深度easy">111，二叉树的最小深度，easy</h5>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明：叶子节点是指没有子节点的节点。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/6d8500c55fe3ebe98dc781d7b62a3bbf.png" alt="img" /><figcaption>img</figcaption>
</figure>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法一：递归。</p>
<ul>
<li>结束条件：当root为空，返回0</li>
<li>递归体：若左右子树皆空，返回1；若左子树和右子树有非空的，记录其最小路径，最后返回结果为最小路径 ➕ 1</li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1.当root的左右子树都为空</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mindep = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//2.root的左子树或右子树有不为空，计算其最小路径</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            mindep = Math.min(minDepth(root.left), mindep);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            mindep = Math.min(minDepth(root.right), mindep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回最小路径+1</span></span><br><span class="line">        <span class="keyword">return</span> mindep + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>错误原因：想法是dfs 来递归左右子树找它们的最小路径，然后取最小。但这样可能在 [2,null,3,null,4,null,5,null,6] 结构中不成立，因为root的左子树为空，所以要加一个判断。</p></li>
</ul>
<h5 id="左叶子之和easy">404，左叶子之和，easy</h5>
<p>计算给定二叉树的所有<strong>左叶子</strong>之和。</p>
<p>示例：</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre>
<p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p>
<ul>
<li><p>方法一：递归dfs</p></li>
<li><p>思路：所有左叶子节点之和，需要遍历整棵树，采用dfs。</p>
<ul>
<li><p>递归出口：节点为空或为叶子节点</p></li>
<li><p>递归条件：</p>
<ul>
<li>如果左子树不为空，判断左子节点是否为叶子节点：若不是，递归调用左子节点
<ul>
<li>如果右子树为空，结果不变；若不为空，上面的结果＋ 递归调用右子节点</li>
</ul></li>
<li>否则左子树为空，右子树一定不为空，只需判断右子节点是不是叶子节点，若不是，递归调用右子节点</li>
<li>最后返回结果</li>
</ul></li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || isLeaf(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || isLeaf(root)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res = isLeaf(root.left) ? root.left.val : dfs(root.left);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            res += isLeaf(root.right) ? <span class="number">0</span> : dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res = isLeaf(root.right) ? <span class="number">0</span> : dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更简洁的版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLeaf(root.left)) <span class="keyword">return</span> root.left.val + sumOfLeftLeaves(root.right);</span><br><span class="line">    <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>另一题：一棵树所有左子节点的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">           res = sumOfLeftLeaves(root.left) + root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res = sumOfLeftLeaves(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res = sumOfLeftLeaves(root.left) + root.left.val + sumOfLeftLeaves(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="最长同值路径medium">687，最长同值路径，medium</h5>
<p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p>
<p>注意：两个节点之间的路径长度由它们之间的边数表示。</p>
<p>示例 1:</p>
<p>输入:</p>
<pre><code>          5
         / \
        4   5
       / \   \
      1   1   5</code></pre>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<p>输入:</p>
<pre><code>          1
         / \
        4   5
       / \   \
      4   4   5</code></pre>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法一：递归。（dfs）</p></li>
<li><p>思路：</p></li>
</ul>
<figure>
<img src="https://img-blog.csdnimg.cn/20201214162048997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<ul>
<li><p>最长路径分为2种情况：</p>
<ol type="1">
<li>以root为起点，经过左子树或右子树，如(2)</li>
<li>不以root为起点，root为中间点，如(1)</li>
</ol></li>
<li><p>辅助函数helper，计算以每一个节点为起点的最长同值路径maxLength，在过程中可以得到以root为根节点的树的最长同值路径ans。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="comment">//以root为根节点的树的最长同值路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以root为起点的最长同值路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//以左、右子节点为起点的最长同值路径</span></span><br><span class="line">        <span class="keyword">int</span> leftLength = helper(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightLength = helper(root.right);</span><br><span class="line">        <span class="comment">//如果左、右子树都非空 且 root.val == root.left.val == root.right.val，更新ans</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span> &amp;&amp; root.val == root.left.val  &amp;&amp; root.val == root.right.val)&#123;</span><br><span class="line">            ans = Math.max(ans, leftLength + rightLength + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftPath = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightPath = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果左右子树有非空且子节点的值与root的值相等，以根节点为起点的最长同值路径为leftPath,rightPath中的最大值</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.left.val == root.val)&#123;</span><br><span class="line">            leftPath  = leftLength + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span> &amp;&amp; root.right.val == root.val)&#123;</span><br><span class="line">            rightPath = rightLength + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取左右子树的最长同值路径的最大值</span></span><br><span class="line">        maxLength = Math.max(leftPath,rightPath);</span><br><span class="line">        <span class="comment">//更新ans</span></span><br><span class="line">        ans = Math.max(ans, maxLength);</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简洁版：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = dfs(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root.right);</span><br><span class="line">    <span class="keyword">int</span> leftPath = root.left != <span class="keyword">null</span> &amp;&amp; root.left.val == root.val ? left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightPath = root.right != <span class="keyword">null</span> &amp;&amp; root.right.val == root.val ? right + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    path = Math.max(path, leftPath + rightPath);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftPath, rightPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="二叉树中第二小的节点easy">671，二叉树中第二小的节点，easy</h5>
<p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p>
<p>更正式地说，<code>root.val = min(root.left.val, root.right.val)</code> 总成立。</p>
<p>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p>
<p>示例 1：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/0bcc8d1bfd49276663468ef8e4c20907.png" alt="img" /><figcaption>img</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [2,2,5,null,null,5,7]</span><br><span class="line">输出：5</span><br><span class="line">解释：最小的值是 2 ，第二小的值是 5 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/ac58c17f14a23e31dd1aa6a7c40abcc6.png" alt="img" /><figcaption>img</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [2,2,2]</span><br><span class="line">输出：-1</span><br><span class="line">解释：最小的值是 2, 但是不存在第二小的值。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>题意解析：每个树的根节点的值都为这棵树所有节点最小的值，所有节点中第二小的值即只比根节点大的值。</p></li>
<li><p>方法一：递归。</p>
<ul>
<li>递归出口：节点为空，返回 -1。</li>
<li>递归体：
<ul>
<li>左右子节点都为空，返回 -1。</li>
<li>根节点取的是左子节点的值，递归左子节点得到只比这个值大的值（或 -1，即此节点为叶子节点）</li>
<li>根节点取的是右子节点的值，递归右子节点得到只比这个值大的值（或 -1，即此节点为叶子节点）</li>
</ul></li>
<li>结果：
<ul>
<li>left 、right 如果都不为 -1，取最小值并返回</li>
<li>left 不为 -1(right 为 -1)，返回left</li>
<li>否则（left为 -1），返回right(-1 或 root.right.val或递归结果)</li>
</ul></li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = root.left.val;</span><br><span class="line">        <span class="comment">//如果左子节点是最小值，递归左子节点，得到以左子节点为根的树的第二小的值 或 -1</span></span><br><span class="line">        <span class="keyword">if</span>(left == root.val)&#123;</span><br><span class="line">            left = findSecondMinimumValue(root.left);<span class="comment">//-1 或 以root.left为根的树的第二小的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = root.right.val;</span><br><span class="line">        <span class="comment">//如果右子节点是最小值，递归右子节点，得到以右子节点为根的树的第二小的值 或 -1</span></span><br><span class="line">        <span class="keyword">if</span>(right == root.val)&#123;</span><br><span class="line">            right = findSecondMinimumValue(root.right);<span class="comment">//-1 或 以root.right为根的树的第二小的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果两边的树递归结果都不为-1（都正常），返回它们的最小值，即在root为根的树中只比root.val大</span></span><br><span class="line">        <span class="keyword">if</span>(left != -<span class="number">1</span> &amp;&amp; right != -<span class="number">1</span>) <span class="keyword">return</span> Math.min(left,right);</span><br><span class="line">        <span class="comment">//如果左子树正常，返回左子树</span></span><br><span class="line">        <span class="keyword">if</span>(left != -<span class="number">1</span>) <span class="keyword">return</span> left; </span><br><span class="line">        <span class="comment">//否则返回右子树递归值（-1 或 以root.right为根的树的第二小的值）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> right;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—动态规划（一）</title>
    <url>/2020/12/29/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>跟着 labuladong 和 CS-Notes 对动态规划做题、总结，形成自己的模板。 ## 引入动态规划 动态规划问题的一般形式就是求最值。求解动态规划的核心问题是穷举。</p>
<p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p>
<p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p>
<p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p>
<h3 id="解题步骤">解题步骤：</h3>
<a id="more"></a>
<ol type="1">
<li>定义子问题</li>
<li>写出子问题的递推关系</li>
<li>确定 DP 数组的计算顺序（一般采用<strong>自底向上</strong>）</li>
<li>空间优化（可选） ## 第一类题型：斐波那契数列。 <a href="#509，斐波那契数列，easy">509，斐波那契数列，easy</a></li>
</ol>
<p><a href="#70，爬楼梯，easy">70，爬楼梯，easy</a></p>
<p><a href="#198，打家劫舍，easy">198，打家劫舍，easy</a></p>
<p><a href="#213，打家劫舍Ⅱ，medium">213，打家劫舍Ⅱ，medium</a></p>
<p><a href="#信件错排问题">信件错排问题</a></p>
<p><a href="#母牛生产">母牛生产</a> 通过「斐波那契数列问题」明白什么是<strong>重叠子问题</strong>（斐波那契数列没有求最值，所以严格来说不是动态规划问题）。 #### 509，斐波那契数列，easy</p>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
<p>给定 N，计算 F(N)。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1.</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法一：暴力递归。</p>
<p>此解法最好理解，但效率不高，这是因为效率低，由下面的递归树不难发现<strong>存在大量重复计算</strong>，这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。 <img src="https://img-blog.csdnimg.cn/20201223113149629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们想办法解决这个问题。</p></li>
<li><p>方法二：带备忘录的自顶向下</p>
<p>先<strong>计算存储子问题的答案，</strong>然后利用子问题的答案计算当前斐波那契数的答案。我们将递归计算，但是通过记忆化<strong>不重复计算</strong>已计算的值。</p>
<p>可以用数组 或 HashMap 存储已计算过的值。</p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            memo[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(memo, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] memo, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//已经计算过则直接取出</span></span><br><span class="line">        <span class="keyword">if</span>(memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">		<span class="comment">//没有计算过</span></span><br><span class="line">        memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
再次画出递归树。 <img src="https://img-blog.csdnimg.cn/img_convert/a627c1fa67c57265d1588257c847dbc5.png" alt="img" /> 通过剪枝，极大减少了子问题（即递归图中节点）的个数。 <img src="https://img-blog.csdnimg.cn/20201223130552783.png" alt="在这里插入图片描述" /></li>
<li><p>方法三：迭代（自底向上）</p>
<p>可以把这个「备忘录」独立出来成为一张表，发现计算index = n 的值只与前两个有关，则<strong>自底</strong> 建立前两个元素。</p></li>
<li><p>代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">int</span> second = <span class="number">1</span>;</span><br><span class="line">       	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">           	sum = first + second;</span><br><span class="line">           	first = second;</span><br><span class="line">           	second = sum;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> first;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> 另一种： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">      	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">      	dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">         		dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]; </span><br><span class="line">      	&#125;</span><br><span class="line">      <span class="keyword">return</span> dp[n];</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure> #### 70，爬楼梯，easy</p></li>
</ul>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">   1. 1 阶 + 1 阶</span><br><span class="line">   2. 2 阶</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">   1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">   2.  1 阶 + 2 阶</span><br><span class="line">   3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：</p>
<ul>
<li><p>我们用 f(x) 表示<strong>爬到第 xx 级台阶的方案数</strong>，考虑<strong>最后一步</strong>可能跨了<strong>一级</strong>台阶，也可能跨了两级台阶，所以我们可以列出如下式子：</p>
<p>f(x) = f(x - 1) + f(x - 2)</p>
<p>它意味着爬到第 x 级台阶的方案数是爬到<strong>第 x−1 级台阶的方案数</strong>和爬到<strong>第 x−2 级台阶的方案数</strong>的<strong>和</strong>。</p></li>
<li><p>与斐波那契数列的递推式相同，区别在于 f(0) = 1。</p></li>
<li><p>爬楼梯的过程自底向上。</p></li>
</ul></li>
<li><p>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//f(n) = f(n - 1) + f(n - 2)</span></span><br><span class="line"><span class="comment">//1 1 2 3 5 8 ...</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     	<span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">     	<span class="keyword">int</span> second = <span class="number">1</span>;</span><br><span class="line">    	 	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">     	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">         	sum = first + second;</span><br><span class="line">         	first = second;</span><br><span class="line">         	second = sum;</span><br><span class="line">    	 	&#125;</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> 另一种： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    	dp[<span class="number">0</span>] = <span class="number">1</span>;dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        	dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    	&#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上面两道题可以很好的理解动态规划的重叠子问题，递推关系也很简单，下面通过具体例子理解解题步骤：</p></li>
<li>定义子问题</li>
<li>写出子问题的递推关系</li>
<li>确定 DP 数组的计算顺序</li>
<li><p>空间优化（可选） #### 198，打家劫舍，easy</p></li>
</ul>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果<strong>两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>解题步骤：</p>
<ol type="1">
<li><p>定义子问题</p>
<p>原问题是【全部房子偷到的最大金额】，子问题是【小偷到第 k 间房屋时偷到的最大金额】</p>
<p>理解：</p>
<p>子问题是<strong>参数化</strong>的，我们定义的子问题中有参数 k。假设一共有 n 个房子的话，就一共有 n 个子问题。动态规划实际上就是通过求这一堆子问题的解，来求出原问题的解。这要求子问题需要具备两个性质：</p>
<ul>
<li>原问题要能由子问题表示。例如这道小偷问题中，k=n 时实际上就是原问题。否则，解了半天子问题还是解不出原问题，那子问题岂不是白解了。</li>
<li>一个子问题的解要能通过其他子问题的解求出。例如这道小偷问题中，f(k) 可以由 f(k−1) 和 f(k−2) 求出，具体原理后面会解释。这个性质就是教科书中所说的“最优子结构”。如果定义不出这样的子问题，那么这道题实际上没法用动态规划解。</li>
</ul></li>
<li><p>子问题递推关系</p>
<ul>
<li><p>base case</p>
<p>首先考虑最简单的情况。</p>
<p>1). 只有一间房屋，则偷窃的最高金额为此房屋的金额</p>
<p>2). 只有两间房屋，不能挨着偷，选择金额较高的房屋偷。</p>
<p>用 <span class="math inline">\(dp[k]\)</span> 表示前 k 间房屋能偷窃到的最高总金额</p>
<p><span class="math inline">\(dp[0] = nums[0]\)</span></p>
<p><span class="math inline">\(dp[1] = max(nums[0],nums[1])\)</span></p></li>
<li><p>状态转移方程</p>
<p>房屋数量大于两间，对第 k (k &gt; 2) 间房屋，有两个选择</p>
<p>1). 偷第 k 间，那么就不能偷第 k - 1 间，偷窃总金额为 前 k - 2 间房屋的最高金额 与 第 k 间房屋金额 之和。</p></li>
</ul>
<figure>
<img src="https://img-blog.csdnimg.cn/20201223131417241.png#pic_center" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure></li>
</ol></li>
</ul>
<p>​ 2). 不偷第 k 间，偷窃总金额为 前 k - 1 间房屋的最高金额。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20201223131424947.png#pic_center" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>​ 在两个选项中选择最大的一项即为答案。</p>
<p>​ 那么就有如下的状态转移方程：</p>
<p>​ <span class="math inline">\(dp[k] = max(dp[k - 1],dp[k - 2] + nums[k])\)</span></p>
<p>​ 3. 确定 DP 数组的计算顺序</p>
<p>动态规划有两种计算顺序，一种是自顶向下的、使用备忘录的递归方法，一种是自底向上的、使用 dp 数组的循环方法。不过在普通的动态规划题目中，99% 的情况我们都不需要用到备忘录方法，所以我们最好坚持用<strong>自底向上的 dp 数组</strong>。</p>
<p>此题中 <span class="math inline">\(dp[k]\)</span> 依赖 <span class="math inline">\(dp[k-1]\)</span> 和 <span class="math inline">\(dp[k-2]\)</span>，采用自底向上。</p>
<ul>
<li>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">       	<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">       	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n]; </span><br><span class="line">       	<span class="comment">//base case</span></span><br><span class="line">       	dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">       	dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">          		dp[i] = Math.max(dp[i - <span class="number">1</span>], nums[i] + dp[i - <span class="number">2</span>]); </span><br><span class="line">       	&#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="打家劫舍medium">213，打家劫舍Ⅱ，medium</h4>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</strong></p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够<strong>偷窃到的最高金额。</strong></p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：</p>
<ul>
<li><p>与上一题的区别在于所有房屋相连，即 第一间房屋 和 最后一间房屋 不能同时偷窃。</p>
<p>可简化为两个单排列问题：</p>
<ol type="1">
<li><p>不偷第一间房屋，偷窃金额的最大值由从 第二间房（nums[1]）到 最后一间房（nums[n - 1]）的数组来确定。</p></li>
<li><p>不偷最后一间房屋，偷窃金额的最大值由从 第一间房（nums[0]）到 倒数第二间房（nums[n - 2]）的数组来确定。</p>
<p>再由上面两种情况得到的结果取最大值。</p></li>
</ol></li>
<li><p>由上题思路，只需在主函数 构造两个新的数组 进行 动态规划，再取最大值即为最后结果。</p></li>
<li><p>主函数的边界条件：</p>
<p><code>nums.length = 0</code> 返回 0</p>
<p><code>nums.length = 1</code> 返回 nums[0]</p></li>
</ul></li>
<li><p>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   	<span class="keyword">int</span> n;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       	n = nums.length;</span><br><span class="line">       	<span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">       </span><br><span class="line">       	<span class="comment">//不偷 第一间</span></span><br><span class="line">       	<span class="keyword">int</span>[] nums1 = <span class="keyword">new</span> <span class="keyword">int</span>[n - <span class="number">1</span>];</span><br><span class="line">       	<span class="comment">//不偷 最后一间</span></span><br><span class="line">       	<span class="keyword">int</span>[] nums2 = <span class="keyword">new</span> <span class="keyword">int</span>[n - <span class="number">1</span>];</span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">           	nums1[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">           	nums2[i] = nums[i];</span><br><span class="line">       	&#125;</span><br><span class="line">       <span class="keyword">return</span> Math.max(rob_init(nums1), rob_init(nums2));</span><br><span class="line">   	&#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob_init</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       	n = nums.length;</span><br><span class="line">       	<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">       	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n]; </span><br><span class="line">       	<span class="comment">//base case</span></span><br><span class="line">      	 	dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">       	dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">          		dp[i] = Math.max(dp[i - <span class="number">1</span>], nums[i] + dp[i - <span class="number">2</span>]); </span><br><span class="line">       	&#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> #### 信件错排问题</p></li>
</ul>
<p>有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p>示例3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 4</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：</p>
<ol type="1">
<li><p>定义子问题</p>
<p>原问题是【N 个信和信封的错装方式数量】，子问题是【第 i 个信和信封的错装方式数量】</p></li>
<li><p>子问题递推关系</p>
<ul>
<li><p>base case</p>
<p>首先考虑最简单的情况。用 <span class="math inline">\(dp[k]\)</span> 表示前 i 个信和信封的错装方式数量。</p>
<p>1). N = 0，数量为 0 =&gt; <span class="math inline">\(dp[0] = 0\)</span></p>
<p>2). N = 1，数量为 0 =&gt; <span class="math inline">\(dp[1] = 0\)</span></p>
<p>3). N = 2，数量为 1 =&gt; <span class="math inline">\(dp[2] = 1\)</span></p></li>
<li><p>状态转移方程</p>
<p>i &gt; 2 时，信封错装方式有两种可能。</p>
<p>1). 对信件 i 和 信件 j，如果 信件 i 装入信封 j，信件 j 装入信封 i，i 、j 互换后正确。其余 i - 2 个信件装错的数量为 <span class="math inline">\(dp[i - 2]\)</span>，j 的选择有$ (i - 1)$ 种。此情况的错装方式数量为 <span class="math inline">\((i - 1) * dp[i - 2]\)</span> <img src="https://img-blog.csdnimg.cn/2020122313191830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p>
<p>2). 对信件 i 和 信件 j，如果 信件 i 装入信封 j，信件 j 装入信封 k，i 、j 互换后只有 j 正确。其余 i - 1 个信件装错的数量为 <span class="math inline">\(dp[i - 1]\)</span>，j 的选择有$ (i - 1)$ 种。此情况的错装方式数量为 <span class="math inline">\((i - 1) * dp[i - 1]\)</span> <img src="https://img-blog.csdnimg.cn/20201223131928987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p>
<p>那么就有如下的状态转移方程：</p>
<p><span class="math inline">\(dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2])\)</span></p></li>
</ul></li>
</ol></li>
<li><p>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MailerrorNums</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       	<span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">       	dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">0</span>; dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">           	dp[i] = (i - <span class="number">1</span>) * dp[i - <span class="number">2</span>] + (i - <span class="number">1</span>) * dp[i - <span class="number">1</span>];</span><br><span class="line">       	&#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> #### 母牛生产</p></li>
</ul>
<p> 假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 1</span><br><span class="line">输出：1 </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 2</span><br><span class="line">输出：2 </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 4</span><br><span class="line">输出：4 </span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：</p>
<ol type="1">
<li><p>定义子问题</p>
<p>原问题为【N 年后牛的数量】，子问题是【第 i 年的牛数量】</p></li>
<li><p>子问题递推关系</p>
<ul>
<li><p>base case</p>
<p>i &lt;= 4 时，只有 第一头母牛 和 它生的小母牛。设 <span class="math inline">\(dp[i]\)</span> 为 第 i 年的牛数量。</p>
<p><span class="math inline">\(dp[0] = 0\)</span>、<span class="math inline">\(dp[1] = 1\)</span>、<span class="math inline">\(dp[2] = 2\)</span>、<span class="math inline">\(dp[3] = 3\)</span></p></li>
<li><p>状态转移方程</p>
<p>i &gt; 4 时，第一头母牛 生产的小母牛 也开始生产。此时 牛的数量为 上一年牛的数量 <span class="math inline">\(dp[i - 1]\)</span> 加上 三年前牛的数量（即 第 i 年有生产能力的牛 的数量）<span class="math inline">\(dp[i - 3]\)</span>，即</p>
<p><span class="math inline">\(dp[i] = dp[i - 1] + dp[i - 3]\)</span></p></li>
</ul></li>
</ol></li>
<li><p>代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cowNums</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       	<span class="keyword">if</span>(n &lt; = <span class="number">4</span>) <span class="keyword">return</span> n;</span><br><span class="line">       	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">       	dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>; dp[<span class="number">3</span>] = <span class="number">3</span>; dp[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">           	dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">3</span>];</span><br><span class="line">       	&#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—链表</title>
    <url>/2020/12/08/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="leetcode刷题">LeetCode刷题</h1>
<h2 id="数据结构">数据结构：</h2>
<h3 id="一链表">一、链表</h3>
<p><a href="#160，相交链表，easy">160，相交链表，easy</a></p>
<p><a href="#206，反转链表，easy">206，反转链表，easy</a></p>
<p><a href="#21，合并两个有序链表，easy">21，合并两个有序链表，easy</a></p>
<p><a href="#83，删除排序链表中的重复元素，easy">83，删除排序链表中的重复元素，easy</a></p>
<p><a href="#83-Ⅱ.删除排序链表中的重复元素，middle">83-Ⅱ.删除排序链表中的重复元素，middle</a></p>
<a id="more"></a>
<p><a href="#19，删除链表的倒数第N个节点，middle">19，删除链表的倒数第N个节点，middle</a></p>
<p><a href="#24，两两交换链表中的节点，middle">24，两两交换链表中的节点，middle</a></p>
<p><a href="#445，两数相加Ⅱ，middle">445，两数相加Ⅱ，middle</a></p>
<p><a href="#234，回文链表，easy">234，回文链表，easy</a></p>
<p><a href="#725，分隔链表，middle">725，分隔链表，middle</a></p>
<p><a href="#328，奇偶链表，middle">328，奇偶链表，middle</a></p>
<h4 id="相交链表easy">160，相交链表，easy</h4>
<p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201116222545595.png" alt="image-20201116222545595" style="zoom:67%;" /></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201116222612234.png" alt="image-20201116222612234" style="zoom:67%;" /></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201116222642573.png" alt="image-20201116222642573" style="zoom:67%;" /></p>
<ul>
<li>方法：双指针。
<ul>
<li>思路：定义节点pA指向headA，节点pB指向headB。
<ul>
<li>如果两链表长度相同
<ul>
<li>有交点，返回此交点</li>
<li>没有交点，返回null</li>
</ul></li>
<li>如果两链表长度不同，先走完的指针指向另一个链表的头节点（如示例2的pB先走完，则指向headA），两指针再次出发，直到后走完的指针也走完了当前链表，使其指向另一链表（即pA走完，指向headB），两指针再次出发，直到找到交点或没有交点走完两链表。</li>
</ul></li>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针，pA与pB如果能相遇，说明两个链表长度相同且有交点；第一遍不能相遇，pA转移到pB,pB转移到pA</span></span><br><span class="line">        <span class="comment">//再次遍历，如果能相遇说明有交点</span></span><br><span class="line"></span><br><span class="line">        ListNode pA = headA;</span><br><span class="line">        ListNode pB = headB;</span><br><span class="line"><span class="comment">//判别两个链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (pA == <span class="keyword">null</span> || pB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//长度不同会有先走完链表的</span></span><br><span class="line">        <span class="keyword">while</span>(pA != <span class="keyword">null</span> &amp;&amp; pB != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//A先走完,转向headB pB同理</span></span><br><span class="line">        <span class="keyword">if</span>(pA == <span class="keyword">null</span>)&#123;</span><br><span class="line">            pA = headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pB = headA;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//再次同时走，A继续向前，B转为headA        </span></span><br><span class="line">        <span class="keyword">while</span>(pA != <span class="keyword">null</span> &amp;&amp; pB != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pA == <span class="keyword">null</span>)&#123;</span><br><span class="line">            pA = headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pB = headA;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//pA在B链表，pB在A链表，同时向前找交点</span></span><br><span class="line">        <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode pA = headA;</span><br><span class="line">        ListNode pB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">            pA = pA == <span class="keyword">null</span> ? headB:pA.next;</span><br><span class="line">            pB = pB == <span class="keyword">null</span> ? headA:pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意点：边界条件的判断：两链表可能为空。</li>
</ul>
<h4 id="反转链表easy">206，反转链表，easy</h4>
<p>反转一个单链表。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法一：递归。</p>
<ul>
<li>思路：先递归到底, 找到最后一个节点, 然后从最后一个节点开始, 把箭头方向掉转。</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201203164846365.png" alt="image-20201203164846365" style="zoom: 67%;" /></p>
<ul>
<li><p>递归出口：链表为空或递归到链表的尾节点</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201203164821559.png" alt="image-20201203164821559" style="zoom: 67%;" /></p></li>
<li><p>递归体：假如归到节点2，</p>
<figure>
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201203164342559.png" alt="image-20201203164342559" /><figcaption>image-20201203164342559</figcaption>
</figure></li>
<li><p>代码：</p></li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//方法一：递归</span></span><br><span class="line">        <span class="comment">//终止条件：链表为空或递归到链表的尾节点时</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode cur = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法二：迭代。</p>
<ul>
<li>思路：构建新链表，将原链表加入新链表，并调转顺序。</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201203165433510.png" alt="image-20201203165433510" style="zoom:67%;" /></p>
<p>直到head = null</p>
<ul>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    	ListNode newHead = <span class="keyword">null</span>; <span class="comment">//null</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = head.next;<span class="comment">//保存后面用的新链表 2—&gt;3-&gt;4-&gt;null</span></span><br><span class="line">            head.next = newHead;      <span class="comment">//null&lt;-1</span></span><br><span class="line">            newHead = head;           <span class="comment">//更新结果链表 1为newHead</span></span><br><span class="line">            head = temp;              <span class="comment">//更新原链表 2—&gt;3-&gt;4-&gt;null中的2为head</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="合并两个有序链表easy">21，合并两个有序链表，easy</h4>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<ul>
<li>方法一：迭代。
<ul>
<li>思路：建立新节点（值为0），再定义一个临时节点temp存储链表。比较 l1.val 与 l2.val 。如果 l1.val &lt; l2.val，temp的下个节点设为l1，并将l1 向右移；如果 l1.val &gt;= l2.val，对 l2 进行上述操作。如果一个链表全部存完为空，将另一个链表剩余节点加入temp.next。最后返回newHead.next。</li>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法一、迭代。新建链表</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp = newHead;</span><br><span class="line">        <span class="comment">//l1与l2都不为空，较小的加入新链表</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                temp.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l1.val &gt;= l2.val)&#123;</span><br><span class="line">                temp.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.next = l2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.next = l1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：递归。思路和上面一致。</li>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            newHead = l1;</span><br><span class="line">            newHead.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1.val &gt;= l2.val)&#123;</span><br><span class="line">            newHead = l2;</span><br><span class="line">            newHead.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除排序链表中的重复元素easy">83，删除排序链表中的重复元素，easy</h4>
<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>
<ul>
<li>方法一：直接法。
<ul>
<li>思路：定义辅助单指针temp = head，比较temp与temp.next的值，如果相同，<code>temp.next = temp.next.next</code>，即<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201205102048317.png" alt="image-20201205102048317" style="zoom:67%;" /></li>
</ul></li>
</ul>
<p>​ 如果不同，<code>temp = temp.next</code>，指针右移。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     	ListNode temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span> &amp;&amp; temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.val == temp.next.val)&#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：双指针。
<ul>
<li>思路：快慢指针。快指针用于探路，慢指针为结果链表指针。快指针如果与慢指针的值相等，快指针右移；不相等，保存到慢指针快指针再右移。</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode right = head.next;</span><br><span class="line">        ListNode left = head;</span><br><span class="line">        <span class="keyword">while</span>(right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right.val != left.val)&#123;</span><br><span class="line">                left.next = right;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//断开与后面重复元素的连接</span></span><br><span class="line">        left.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法三：递归。
<ul>
<li>思路：把链表看成 头节点-&gt;没有重复元素的排序链表，则比较头节点与子链表的头节点，如果相同，返回子链表的头节点；否则，返回head。</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//递归出口 空链表和链表只有头节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode newHead = deleteDuplicates(head.next);</span><br><span class="line">        head.next = newHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.val == newHead.val ? newHead : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除排序链表中的重复元素middle">83-Ⅱ.删除排序链表中的重复元素，middle</h4>
<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">输出: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">输出: 2-&gt;3</span><br></pre></td></tr></table></figure>
<ul>
<li>方法一：递归。
<ul>
<li>思路：和上面那道题思路类似，但要判断头节点与后面元素是否相同。如果相同，找到第一个不重复的元素开始递归；如果不同，与上面题类似。</li>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//如果head与后面的节点重复，找到第一个不重复的节点，进行递归。</span></span><br><span class="line">        <span class="keyword">if</span>(head.val == head.next.val)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.next != <span class="keyword">null</span> &amp;&amp; head.val == head.next.val)&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode newHead = deleteDuplicates(head.next);</span><br><span class="line">            head.next = newHead;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：双指针-快慢指针。
<ul>
<li>思路：建立虚拟头节点dummy，双指针left指向dummy，right指向head，判断left.next 与 right.val是否相等。如果不相等，两指针右移；如果相等，right需要跳过所有重复数字，再令left的下一位为 right.next（第一个不重复的数字）。最后返回dummy之后的节点。</li>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//双指针，建立虚拟头节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode left = dummy;</span><br><span class="line">        ListNode right = head;</span><br><span class="line">        <span class="keyword">while</span>(right != <span class="keyword">null</span> &amp;&amp; right.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.next.val != right.next.val)&#123;</span><br><span class="line">                left = left.next;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(right != <span class="keyword">null</span> &amp;&amp; right.next != <span class="keyword">null</span> &amp;&amp; left.next.val == right.next.val)&#123;</span><br><span class="line">                    right = right.next;<span class="comment">//right右移直到right.next不是重复数字</span></span><br><span class="line">                &#125;</span><br><span class="line">                left.next = right.next;<span class="comment">//left下一位是去掉重复数字之后的数字</span></span><br><span class="line">                right = right.next;<span class="comment">//继续右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除链表的倒数第n个节点middle">19，删除链表的倒数第N个节点，middle</h4>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
<ul>
<li>方法一：先求出链表长度，就可以找到要删除节点的前一个节点，再使他指向后一个节点即可。
<ul>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//先得到长度，再单指针跳过倒数第n个元素 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode temp = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = getLength(head);</span><br><span class="line">        <span class="keyword">if</span>(length == n) <span class="keyword">return</span> head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = temp.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(head.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：双指针-快慢指针。
<ul>
<li>思路：令快指针先走 n 步，慢指针再与快指针同时出发，直到快指针走到链表尾部，此时慢指针走到要删除节点的前一个节点，跳过即可。<em>有些类似第160题.相交链表</em></li>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="comment">//快指针先走n步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果此时fast为空，说明删除的是头节点</span></span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fast走到头，此时slow走到要删除节点的前一个</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两两交换链表中的节点middle">24，两两交换链表中的节点，middle</h4>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201206195646801.png" alt="image-20201206195646801" style="zoom:80%;" /></p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<ul>
<li>方法一：递归。
<ul>
<li>思路：两个相邻节点看为一组，组间节点交换（递归实现），再调整组间顺序。</li>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//两个相邻节点为一组，使后一个节点的指针指向前一个，组间指向也需要调整</span></span><br><span class="line">        <span class="comment">//先保存节点2</span></span><br><span class="line">        ListNode temp = head.next;</span><br><span class="line">        <span class="comment">//头节点下一个节点为递归的结果（1-&gt;4-&gt;3）</span></span><br><span class="line">        head.next = swapPairs(head.next.next);</span><br><span class="line">        <span class="comment">//2-&gt;1-&gt;4-&gt;3</span></span><br><span class="line">        temp.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：迭代。
<ul>
<li>思路：定义一个虚拟头节点dummy，三个指针：left、right用于进行交换，temp用于连接两次迭代之间的节点。</li>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode left = dummy;</span><br><span class="line">        ListNode right = dummy; </span><br><span class="line">        ListNode temp = dummy;</span><br><span class="line">        <span class="keyword">while</span>(right != <span class="keyword">null</span> &amp;&amp; right.next != <span class="keyword">null</span> &amp;&amp; right.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//分别向前走一步、两步</span></span><br><span class="line">            left = left.next; <span class="comment">// 1</span></span><br><span class="line">            right = right.next.next; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//使下次循环的1指向4</span></span><br><span class="line">            temp.next = right;</span><br><span class="line">            left.next = right.next;</span><br><span class="line">            right.next = left;</span><br><span class="line">            <span class="comment">//2-&gt;1-&gt;3-&gt;4</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//再使temp、right都指向1.下次迭代时left为3，right为4</span></span><br><span class="line">            temp = left;</span><br><span class="line">            right = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两数相加middle">445，两数相加Ⅱ，middle</h4>
<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>进阶：</p>
<p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出： 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>
<ul>
<li>题目说明：题目中说明<strong>最高位位于链表头部</strong>，即 7243 + 564 = 7807，最后输出的即7 -&gt; 8 -&gt; 0 -&gt; 7。</li>
<li>方法一：借助栈。
<ul>
<li>思路：逆序先想到栈来存储链表节点的值，相加后再弹出，存储到一个新的链表。注意要记录进位，加到下一位。</li>
<li>图解：<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201207160650072.png" alt="image-20201207160650072" style="zoom:80%;" /></li>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//法一：栈+取和的个位</span></span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//相加的进位</span></span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//有非空栈或carry &gt; 0就进行相加操作</span></span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty() || !stack2.isEmpty() || carry &gt; <span class="number">0</span>)&#123; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> sum = carry;<span class="comment">//两数的和</span></span><br><span class="line">            sum += stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">            sum += stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line"></span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line"></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：while条件里添加carry &gt; 0是为了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:(5) + (5)</span><br><span class="line">输出: 1-&gt;0</span><br></pre></td></tr></table></figure>
<p>也可以单独判断carry，如果stack1、stack2都为空了但还有进位，则创建新节点加入结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!stack1.isEmpty() || !stack2.isEmpty() )&#123; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> sum = carry;<span class="comment">//两数的和</span></span><br><span class="line">            sum += stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">            sum += stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line"></span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line"></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ListNode node1 = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            node1.next = head;</span><br><span class="line">            head = node1;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：反转链表。
<ul>
<li>思路：因为要从链尾开始相加，所以先反转链表，两个链表从头开始相加节点的值，再将新的链表反转，得到结果。</li>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//法二：反转链表 3-&gt;4-&gt;2-&gt;7 4-&gt;6-&gt;5  7 -&gt; 0 -&gt; 8 -&gt;7反转输出结果</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line">        ListNode newl1 = reverse(l1);</span><br><span class="line">        ListNode newl2 = reverse(l2);</span><br><span class="line">       </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">while</span>(newl1 != <span class="keyword">null</span> || newl2 != <span class="keyword">null</span> || carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry;</span><br><span class="line">            sum += newl1 == <span class="keyword">null</span> ? <span class="number">0</span> : newl1.val;</span><br><span class="line">            sum += newl2 == <span class="keyword">null</span> ? <span class="number">0</span> : newl2.val;</span><br><span class="line"></span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = node;</span><br><span class="line"></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(newl1 != <span class="keyword">null</span>) newl1 = newl1.next;</span><br><span class="line">            <span class="keyword">if</span>(newl2 != <span class="keyword">null</span>) newl2 = newl2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res = reverse(dummy.next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode node = reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>扩展：另一道类似题</p>
<figure>
<img src="https://pic.leetcode-cn.com/7208a246263722b9757ec7fd94a7c3bf7c17e6f55f2395eae8592f4f5e29323a-image-20200805204018584.png" alt="image-20200805204018584.png" /><figcaption>image-20200805204018584.png</figcaption>
</figure>
<ul>
<li>题目说明：逆序存储，即<strong>链尾为高位</strong>，相加得到结果仍要逆序输出。</li>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry;</span><br><span class="line">            sum += l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            sum += l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = node;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="回文链表easy">234，回文链表，easy</h4>
<p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<ul>
<li>方法一：借助栈。
<ul>
<li>思路：将链表节点值放入栈并统计链表长度，循环 l/2 次（只需比较前一半节点值），如果链表的头部值与栈弹出的值不相等，返回false；否则节点右移，最终返回true。</li>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="comment">//将节点值放入栈</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(temp.val);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        length /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(length-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.pop() != head.val)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：将链表节点值转为集合存储，再使用双指针-头尾指针。
<ul>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!list.get(left).equals(list.get(right)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>错误点：<code>if(list.get(left) != list.get(right))</code> 错误
<ul>
<li>Integer是对象，比较两个对象相等要用equals</li>
<li>使用 == 比较Integer类型时，默认缓存 -128 ~ 127，超过此范围会new新对象，两个对象地址不一样则返回false</li>
</ul></li>
<li>方法三：快慢指针。
<ul>
<li>思路：找到中间节点，将后半段链表进行反转，再比较反转后的链表与原链表前半段的值。</li>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode middle = getMiddle(head);<span class="comment">//链表中点，如果长度是偶数，返回第 l/2 - 1 个节点</span></span><br><span class="line">        ListNode newHead = reverse(middle.next);<span class="comment">//反转后半部分链表</span></span><br><span class="line">        <span class="comment">//比较前半部分和后半部分链表的节点值</span></span><br><span class="line">        <span class="keyword">while</span>(newHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val != newHead.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">                newHead = newHead.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getMiddle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode left = head;</span><br><span class="line">        ListNode right = head;</span><br><span class="line">        <span class="keyword">while</span>(right.next != <span class="keyword">null</span> &amp;&amp; right.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            left = left.next;</span><br><span class="line">            right = right.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回链表的中间节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode temp = reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分隔链表middle">725，分隔链表，middle</h4>
<p>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</p>
<p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p>
<p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p>
<p>返回一个符合上述规则的链表的列表。</p>
<p>举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">root &#x3D; [1, 2, 3], k &#x3D; 5</span><br><span class="line">输出: [[1],[2],[3],[],[]]</span><br><span class="line">解释:</span><br><span class="line">输入输出各部分都应该是链表，而不是数组。</span><br><span class="line">例如, 输入的结点 root 的 val&#x3D; 1, root.next.val &#x3D; 2, \root.next.next.val &#x3D; 3, 且 root.next.next.next &#x3D; null。</span><br><span class="line">第一个输出 output[0] 是 output[0].val &#x3D; 1, output[0].next &#x3D; null。</span><br><span class="line">最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">root &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k &#x3D; 3</span><br><span class="line">输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span><br><span class="line">解释:</span><br><span class="line">输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法一：拆分链表。</p>
<ul>
<li>思路：分类讨论。
<ul>
<li>如果链表为空，返回 k 个空节点组成的节点数组。</li>
<li>如果链表长度l &lt;= k，前 l 个元素是单个节点，后 l - k 个元素为空。</li>
<li>如果链表长度l &gt; k，每部分至少有 l / k 个节点，前 l % k 部分节点数 + 1。再将原链表分部分存储在结果数组中，每部分为一个链表，部分之间要断开连接。</li>
</ul></li>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        <span class="keyword">int</span> length = getLength(root);</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; )&#123;</span><br><span class="line">                ListNode temp = root.next;</span><br><span class="line">                root.next = <span class="keyword">null</span>;</span><br><span class="line">                res[i++] = root;</span><br><span class="line">                root = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = length; i &lt; k; i++)&#123;</span><br><span class="line">                res[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(length &gt; k)&#123;</span><br><span class="line">        <span class="comment">//length 比 k 大时 每部分存放 l/k 个节点 , 前 l%k 部分存放 l/k+1 个节点</span></span><br><span class="line">        <span class="keyword">int</span> n = length / k;</span><br><span class="line">        <span class="keyword">int</span> m = length % k;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//记录每部分存储元素个数，[4][3][3]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            counts[i] = m-- &gt; <span class="number">0</span> ? n + <span class="number">1</span>: n;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = root;</span><br><span class="line">        <span class="comment">//将节点存储到数组中 counts[0]=4</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            res[i] = cur;</span><br><span class="line">            <span class="comment">//跳到每部分最末节点 1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; counts[i] - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//断开每部分之间的连接</span></span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">            cur = temp;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="奇偶链表middle">328，奇偶链表，middle</h4>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p>
<ul>
<li>方法一：双指针，分离链表为奇链表、偶链表，再合并。
<ul>
<li>代码：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode odd = head;</span><br><span class="line">        ListNode evenHead = head.next;</span><br><span class="line">        ListNode even = evenHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            odd.next = odd.next.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = even.next.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>一文看清背包套路</title>
    <url>/2021/01/08/%E4%B8%80%E6%96%87%E7%9C%8B%E6%B8%85%E8%83%8C%E5%8C%85%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<p>刷了几道背包问题，用了一周时间，动态规划的难真的领会到了。但再难总有规律可循，总结中刷题，刷题中总结。</p>
<p>关于0-1背包的问题有：</p>
<ul>
<li><p>416，分割等和子集</p></li>
<li><p>494，目标和</p></li>
<li><p>474，一和零</p></li>
</ul>
<p>关于完全背包的问题有：</p>
<ul>
<li>322，零钱兑换</li>
</ul>
<a id="more"></a>
<ul>
<li><p>518，零钱兑换Ⅱ</p></li>
<li><p>377，组合总和Ⅳ</p></li>
<li><p>139，单词拆分</p></li>
</ul>
<h2 id="一0-1背包问题">一、0-1背包问题</h2>
<h5 id="引入">引入</h5>
<p>一个可装载重量为<code>W</code>的背包和<code>N</code>个物品，每个物品有重量和价值两个属性。怎么装使这个背包装下物品的价值最大？</p>
<p><strong>套路</strong>：</p>
<ol type="1">
<li><p><strong>子问题</strong>：<strong>二维 <code>dp</code> 数组</strong> <span class="math inline">\(dp[i][j]\)</span>—对于前 <code>i</code> 个物品，当前背包容量为 <code>j</code>，这种情况下可以装的最大价值是 <span class="math inline">\(dp[i][j]\)</span>。</p>
<p>比如说，如果 <span class="math inline">\(dp[3][5] = 6\)</span>，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。 根据这个定义，我们想求的<strong>最终答案就是 <code>dp[N][W]</code></strong>。</p></li>
<li><p><strong>base case</strong>： 当没有物品 或 背包没有容量时，<span class="math inline">\(dp[0][...] = dp[...][0] = 0\)</span></p></li>
<li><p><strong>状态转移</strong>：</p>
<p>物品 i 有两种选择—装进背包和不装，设第 i 件物品体积为 w，价值为 v。</p>
<ul>
<li>物品 i 不装进背包，最大价值 <span class="math inline">\(dp[i][j] = dp[i - 1][j]\)</span></li>
<li>物品 i 装进背包，最大价值 <span class="math inline">\(dp[i][j] = dp[i - 1][j - w] + v\)</span></li>
</ul>
<p>因此，0-1 背包的状态转移方程为：</p>
<p><span class="math inline">\(dp[i][j] = Math.max(dp[i - 1][j],dp[i - 1][j - w] + v)\)</span></p></li>
</ol>
<p><strong>代码：</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// W 为背包总体积</span></span><br><span class="line"><span class="comment">// N 为物品数量</span></span><br><span class="line"><span class="comment">// weights 数组存储 N 个物品的重量</span></span><br><span class="line"><span class="comment">// values 数组存储 N 个物品的价值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] values)</span></span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]表示装 i 个物品背包容量为 j</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//默认初始化都为0，从第1行和第1列开始赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//物品从weight[0]开始添加，w表示第i个物品的体积，v表示第i个物品的价值</span></span><br><span class="line">        <span class="keyword">int</span> w = weight[i - <span class="number">1</span>]; <span class="keyword">int</span> v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; W + <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= w)</span><br><span class="line">            	dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - w] + v);</span><br><span class="line">            <span class="comment">// 当前背包容量装不下，只能选择不装入背包</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到 <span class="math inline">\(dp[i][j]\)</span> 都是通过上一行 <span class="math inline">\(dp[i-1][..]\)</span> 转移过来的，之前的数据都不会再使用了。 所以，我们可以进行状态压缩，将二维 dp 数组压缩为一维，节约空间复杂度，可见下一题。</p>
<h5 id="分割等和子集medium">416，分割等和子集，medium</h5>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:</p>
<p>每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure>
<ul>
<li><p>题意分析：</p>
<p>看起来和背包没关系，实际是<strong>背包问题的变体：子集背包问题</strong>。原背包问题的二维数组 <span class="math inline">\(v = dp[i][j]\)</span> 表示 对于前 <code>i</code> 个物品，当前背包容量为 <code>j</code>，这种情况下可以装的最大价值是 <span class="math inline">\(v\)</span>。</p>
<p>此题中，要把数组分割成两个等和子集，即背包容量：数组的和 <code>sum</code>的一半，物品：数组元素。如果遍历数组，部分元素的和恰好为 背包容量，则剩余元素的和也恰好为 <code>sum / 2</code>，返回true。</p></li>
<li><p>思路：</p>
<p><strong>特殊情况：</strong></p>
<p><code>nums</code> 数组的元素和 <code>sum</code> 若为奇数，则无法分割，返回false。</p>
<p>如果 <code>n &lt; 2</code>，数组无法分割，返回false。</p></li>
</ul>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(x = dp[i][j]\)</span> 表示 对于数组<code>nums</code> 的前 <code>i</code> 个元素，当前元素和是否为 <code>j</code>， 若为 j ，<span class="math inline">\(x = true\)</span>；否则，<span class="math inline">\(x = false\)</span>。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0][...] = false\)</span> 数组中没有元素可选取，返回false。</p>
<p><span class="math inline">\(dp[...][0] = true\)</span> 目标元素和为 0，不选取元素即可。</p></li>
<li><p>状态转移方程</p>
<p>当前元素 <code>num = nums[i - 1]</code>（从数组的 第 0 个元素开始遍历）</p>
<p>①. <code>j &gt;= num</code></p>
<ul>
<li><p>不将 <code>num</code> 算入，能否恰好等于 j ,<span class="math inline">\(dp[i][j]\)</span>取决于 <span class="math inline">\(dp[i - 1][j]\)</span></p></li>
<li><p>将 <code>num</code> 算入，能否恰好等于 j ,<span class="math inline">\(dp[i][j]\)</span>取决于 <span class="math inline">\(dp[i - 1][j - num]\)</span></p>
<p>理解：如果装入第 i 个元素，要看剩余元素和 <code>j - num</code> 限制下是否恰好装满。</p></li>
</ul>
<p>②.<code>j &lt; num</code></p>
<p>要达到的元素和 比 当前元素值 小，无法加入。</p>
<p>总结： <img src="https://img-blog.csdnimg.cn/20210107152332640.png#pic_center" alt="在这里插入图片描述" /></p></li>
</ol>
<ul>
<li><p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//dp[i][j]— [0, i]元素 元素是否为 j</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][target + <span class="number">1</span>];<span class="comment">//初始化都为false</span></span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; target + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//要达到的元素和 比 当前元素值 小，无法加入</span></span><br><span class="line">                <span class="keyword">if</span>(j &lt; num) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>降维</p>
<p><span class="math inline">\(dp[i][j]\)</span> 都是通过上一行 <span class="math inline">\(dp[i-1][..]\)</span> 转移过来的，可以进行状态压缩，将二维 dp 数组压缩为一维，但要注意 <strong>j 应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果。</strong></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = nums.length;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">          sum += num; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//特殊：</span></span><br><span class="line">      <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      sum = sum / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum + <span class="number">1</span>];</span><br><span class="line">      dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> num = nums[i - <span class="number">1</span>];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = sum; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">              <span class="keyword">if</span>(j &gt;= num)</span><br><span class="line">                  dp[j] = dp[j] | dp[j - num];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[sum];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结<strong>做题步骤</strong>：</p></li>
</ul>
<ol type="1">
<li><p><strong>理解题意</strong>，判定此题为 0-1背包问题</p></li>
<li><p>此题是否有<strong>特殊情况</strong></p></li>
<li><p><strong>动态规划</strong>正常做法 1. 子问题：确定背包和物品指代什么，<span class="math inline">\(dp[i][j]\)</span> 返回值是什么 2. base case：通常为 <span class="math inline">\(dp[0][...]、dp[...][0]、dp[0][0]\)</span> 3. 状态转移方程： 先遍历物品，再遍历背包。每个物品只有装和不装两个选择。</p>
<pre><code>组合问题公式   dp[i] += dp[i - num]
True、False问题公式    dp[i] = dp[i] or dp[i - num]
最大最小问题公式    dp[i] = min(dp[i], dp[i - num]+1) 或 dp[i] =  max(dp[i], dp[i - num]+1)</code></pre></li>
<li><p>最终<strong>返回结果</strong></p></li>
<li><p><strong>状态压缩</strong>至一维（可不进行）</p></li>
</ol>
<h5 id="目标和medium">494，目标和，medium</h5>
<p>给定一个非负整数数组<code>a1, a2, ..., an</code> 和一个目标数 S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"> 数组非空，且长度不会超过 20 。</span><br><span class="line">   初始的数组的和不会超过 1000 。</span><br><span class="line">  保证返回的最终结果能被 32 位整数存下。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>题意分析： <img src="https://img-blog.csdnimg.cn/20210107155801985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 则转换为 0-1背包问题：给定一个数组 和一个容量为 target 的背包，求多少种方式将背包填满。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(x = dp[i][j]\)</span> 表示 对于数组<code>nums</code> 的前 <code>i</code> 个元素，放进容量 <code>j</code> 的背包，装满方式为 x。</p></li>
</ol>
<p><strong>特殊情况：</strong></p>
<p><code>S + sum</code> 必须为偶数才可分解，<code>S &lt; sum</code> 才可使数组 <code>nums</code> 元素得到 <code>S</code>。</p></li>
</ul>
<ol start="2" type="1">
<li><p>base case</p>
<p><span class="math inline">\(dp[0][0] = 1\)</span> 没有元素，所以只能不选，和为0</p></li>
<li><p>状态转移方程</p>
<p>当前元素 <code>num = nums[i - 1]</code>（从数组的 第 0 个元素开始遍历）</p>
<p>①. <code>j &gt;= num</code></p>
<p>将 当前 <code>num = nums[i-1]</code> 放入或不放入背包，<span class="math inline">\(dp[i][j] = dp[i-1][j]+dp[i-1][j-num]\)</span></p>
<p>②. <code>j &lt; num</code></p>
<p>不能放入，取决于上一状态，<span class="math inline">\(dp[i][j] = dp[i-1][j]\)</span></p></li>
</ol>
<ul>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(S &gt; sum || (sum + S) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> target = (sum + S) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>][target + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; target + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= num)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对base case 的理解：</p>
<p><strong>注意</strong>与0-1背包的区别：</p>
<p>对于0-1 背包，物品大小为正数，可以先对二维数组初始化第0行（除<span class="math inline">\([0][0]\)</span> 位置外全为0）和第0列（全为1）。然后 i 和 j 都从1开始遍历。 对于该问题，列表中可能存在为 0 的元素，因此<strong>选不选这个0，都能将容量为0的背包装满</strong>。如，<code>nums=&#123;0,0&#125;,target=0,dp[2][0]≠1</code>。</p>
<p>所以base case 只有 <span class="math inline">\(dp[0][0]=1\)</span>, 剩下的第0列的其他位置的值用状态转移方程确定 （而不能将 <span class="math inline">\(dp[i][0]\)</span>初始化为1） 。即 i 从1开始遍历，j 从0开始遍历。</p></li>
<li><p>优化：将二维<code>dp</code>数组压缩为一维，<strong><code>dp[i][j]</code>都是通过上一行<code>dp[i-1][..]</code>转移过来的</strong>，之前的数据都不会再使用了。需要注意的是 <code>j</code>应该从后往前反向遍历，因为每个物品（数字）只能用一次，以免之前的结果影响其他的结果。</p>
<ol type="1">
<li><p>子问题：</p>
<p><span class="math inline">\(x = dp[i]\)</span> 表示数组 <code>nums</code> 的元素 装满 容量为 i 的背包，有 x 种装法。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0] = 1\)</span> 全部不装，一种装法。</p></li>
<li><p>状态转移方程</p>
<p>由上面的二维可得$ dp[j] = dp[j] + dp[j - num]$</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(S &gt; sum || (sum + S) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> target = (sum + S) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">//base case//放入背包重量为0的方案数为1，不选</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= num)</span><br><span class="line">                    dp[j] = dp[j] + dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>另一种方法：递归</p>
<p>对于第 i 个数，可以 ‘+’ 或 '-'，分别递归搜索两种操作，当搜索完一遍，如果元素和sum等于S，count+1。、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="number">0</span>, S);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> sum, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(i == nums.length)&#123;</span><br><span class="line">          <span class="keyword">if</span>(sum == S)</span><br><span class="line">              count++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//还没全部搜索完，递归两种情况</span></span><br><span class="line">          helper(nums, i + <span class="number">1</span>, sum + nums[i], S);</span><br><span class="line">          helper(nums, i + <span class="number">1</span>, sum - nums[i], S);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="一和零medium">474，一和零，medium</h5>
<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 m 和 n 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p>
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m &#x3D; 5, n &#x3D; 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m &#x3D; 1, n &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= <code>strs.length</code>&lt;= 600 1 &lt;= <code>strs[i].length</code> &lt;= 100 <code>strs[i]</code> 仅由 '0' 和 '1' 组成 1 &lt;= m, n &lt;= 100</p>
<ul>
<li><p>题目解析：</p>
<p>仍然是 0-1背包问题，但此题的背包有两个，一个放0，一个放1，称为背包0 和 背包1。物品：字符串数组中的字符。为最大最小问题。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i][j][k]\)</span> — 前 i 个字符串将 背包0容量为 j，背包1容量为k 的最大子集大小</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0][...][...]=0\)</span> 如果不使用任何一个字符串，则背包能装的字符串数就为0。</p>
<p><span class="math inline">\(dp[...][0][0]=0\)</span> 如果背包0，背包1的容量都为0，它能装的字符串数也为0。</p></li>
<li><p>状态转移方程</p>
<p>当前字符串str</p>
<ul>
<li><p>如果字符串<code>str</code>不装入背包，受上一状态影响。</p>
<p><span class="math inline">\(dp[i][j][k]=dp[i-1][j][k]\)</span></p></li>
<li><p>如果字符串<code>str</code> 装入背包，则与不装入的选择取最大值。</p>
<p><span class="math inline">\(dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-count_0][j-count_1] + 1)\)</span></p></li>
</ul>
<p>边界条件为 j 与 <code>str</code> 中0 的数量 的大小关系，k 与 <code>str</code> 中 1 的数量的大小关系。</p></li>
<li><p>返回 <span class="math inline">\(dp[len][m][n]\)</span></p></li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>][m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//base case dp[0][...][...]=0、dp[...][0][0]=0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先循环物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            String str = strs[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n + <span class="number">1</span>; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j &lt; count_0(str) || k &lt; count_1(str))</span><br><span class="line">                    dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    dp[i][j][k] = Math.max(dp[i - <span class="number">1</span>][j][k], dp[i - <span class="number">1</span>][j - count_0(str)][k - count_1(str)] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len][m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计str中0和1的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count_0</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str_c = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str_c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count_1</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str_c = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str_c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>状态压缩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            String str = strs[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= count_0(str); j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = n; k &gt;= count_1(str); k--)&#123;</span><br><span class="line">                    dp[j][k] = Math.max(dp[j][k], dp[j - count_0(str)][k - count_1(str)] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计str中0和1的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count_0</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str_c = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str_c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count_1</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str_c = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str_c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>思考：为什么背包0 和 背包1的 j、k要从 0 开始遍历？</p>
<p>字符串数组中如果存在“00”，“00”，选择也是不同的，会影响<span class="math inline">\(dp\)</span> 数组的结果。可参考494题中对 base case 的理解。</p></li>
</ul>
<h5 id="背包总结">0-1背包总结</h5>
<p>做题步骤：</p>
<ol type="1">
<li><p><strong>理解题意</strong>，判定此题为 0-1背包问题</p></li>
<li><p>此题是否有<strong>特殊情况</strong></p></li>
<li><p><strong>动态规划</strong>正常做法 1. 子问题：确定背包和物品指代什么，<span class="math inline">\(dp[i][j]\)</span> 返回值是什么 2. base case：通常为 <span class="math inline">\(dp[0][...]、dp[...][0]、dp[0][0]\)</span> 3. 状态转移方程： 先遍历物品，再遍历背包。每个物品只有装和不装两个选择。</p>
<p>组合问题公式 dp[i] += dp[i - num] True、False问题公式 dp[i] = dp[i] or dp[i - num] 最大最小问题公式 dp[i] = min(dp[i], dp[i - num]+1) 或 dp[i] = max(dp[i], dp[i - num]+1)</p></li>
<li><p>最终<strong>返回结果</strong></p></li>
<li><p><strong>状态压缩</strong>至一维（可不进行）</p></li>
</ol>
<p>套模板还是有用的，难的部分在于理清题意再转化到模板。base case 的情况容易混淆，分不清的时候先写出多维dp数组，再进行降维可能还有助于做题。 完全背包问题请见下一节总结内容。</p>
<h2 id="二完全背包问题">二、完全背包问题</h2>
<h5 id="完全背包问题引入">完全背包问题引入</h5>
<ul>
<li><p>完全背包的特点：物品可以无限次选取，且<strong>不考虑顺序</strong>。</p></li>
<li><p>与0-1背包不同在：</p>
<ul>
<li><p>0-1背包考虑当前物品装入或不装入背包，物品<strong>只有一件</strong>。</p></li>
<li>完全背包考虑当前物品装入或不装入背包，物品的数量<strong>无限</strong>，只要背包容量还有剩余就可以一直拿同一种物品。</li>
</ul></li>
<li><p>完全背包的变体问题：物品可以无限次选取，且<strong>考虑物品放入的顺序</strong>。</p></li>
</ul>
<p>下面在具体题目中进行总结。</p>
<h5 id="零钱兑换medium">322，零钱兑换，medium</h5>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 &#x3D; 5 + 5 + 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：coins &#x3D; [1], amount &#x3D; 0</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：coins &#x3D; [1], amount &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line">输入：coins &#x3D; [1], amount &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= <code>coins.length</code> &lt;= 12 1 &lt;= <code>coins[i]</code> &lt;= 231 - 1 0 &lt;= <code>amount</code> &lt;= 104</p>
<h6 id="解法一二维先遍历物品再遍历背包">解法一：二维（先遍历物品，再遍历背包）</h6>
<ul>
<li><p>题目解析：</p>
<p>数组的元素可以使用多次，对顺序没有要求，完全背包问题。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i][j]\)</span> 前 i 个硬币组成总金额 j，所需最少硬币个数。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[..][0] = 0\)</span> 金额为0，不取硬币。</p>
<p><strong>特殊情况：</strong></p>
<p>此题中若无法组成总金额，需返回 -1。思考怎么实现呢？</p>
<p>把二维数组 <span class="math inline">\(dp\)</span> 初始化成最大值 <code>amount + 1</code>（硬币面额最少为1），如果发现没更新则说明无法取硬币组成总金额，返回 -1。</p></li>
<li><p>递推关系</p>
<p>最小问题，取min。当前coin = coins[i-1]</p>
<ul>
<li><p>不选 coin，最少硬币个数不变，总金额不变。</p>
<p><span class="math inline">\(dp[i][j] = dp[i - 1][j]\)</span></p></li>
<li><p>选 coin，最少硬币个数 + 1。因为完全背包问题可以<strong>多次选取同一物品，所以为 <span class="math inline">\(dp[i][j - coin]\)</span></strong>，与 0-1背包的区别就体现在此。</p>
<p><span class="math inline">\(dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - coin] + 1)\)</span></p></li>
</ul></li>
</ol></li>
<li><p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化dp表，默认值为极大值，代表无解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i], amount + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//base case</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> coin = coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= coin)</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - coin] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                     dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][amount] &gt; amount ? -<span class="number">1</span>: dp[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>状态压缩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">         Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> coin = coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= coin)</span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span>: dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="解法二一维先遍历背包再遍历物品">解法二：一维（先遍历背包，再遍历物品）</h6>
<ul>
<li><p>题目解析：</p>
<p>数组的元素可以使用多次，对顺序没有要求，完全背包问题。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i]\)</span> 硬币组成金额为 i ，所需最少硬币个数。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0] = 0\)</span> 金额为0，不取硬币。</p></li>
<li><p>递推关系</p>
<p>以 coins=[1,2,5] amount = 11 为例</p>
<p>k 枚硬币 <code>a1，... ,ak</code> 总和为 11，即 <span class="math inline">\(dp[11] = k\)</span>，上一状态就是 <span class="math inline">\(dp[11-ak] = k-1\)</span></p>
<p>状态转移方程为：</p>
<p><span class="math inline">\(dp[i]=min(dp[i-coin])+1\)</span>，<code>for coin in coins  and if  i &gt;= coin</code></p></li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特殊判断，可有可无</span></span><br><span class="line">        <span class="keyword">if</span>(coins.length == <span class="number">1</span> &amp;&amp; amount % coins[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">              </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//硬币面额至少为1，最多为amount</span></span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//外循环为dp数组从1开始的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//内循环为 coins 数组元素值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> coin = coins[j];</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= coin)</span><br><span class="line">                    <span class="comment">//得到上一状态的最小值</span></span><br><span class="line">                    dp[i] = Math.min((dp[i - coin] + <span class="number">1</span>), dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">       <span class="comment">//如果dp[amount]没更新，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span>: dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="零钱兑换medium-1">518，零钱兑换Ⅱ，medium</h5>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: amount &#x3D; 5, coins &#x3D; [1, 2, 5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;2+2+1</span><br><span class="line">5&#x3D;2+1+1+1</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: amount &#x3D; 3, coins &#x3D; [2]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 只用面额2的硬币不能凑成总金额3。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: amount &#x3D; 10, coins &#x3D; [10] </span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<p>你可以假设：</p>
<p>0 &lt;= amount (总金额) &lt;= 5000 1 &lt;= coin (硬币面额) &lt;= 5000 硬币种类不超过 500 种 结果符合 32 位符号整数</p>
<ul>
<li><p>题目解析：</p>
<p>数组的元素可以使用多次，对顺序没有要求，完全背包问题。组合问题。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i][j]\)</span> — 前 i 个硬币组成金额 j 的组合数。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[..][0] = 1\)</span> 全部都不拿，只有这一种拿法。</p></li>
<li><p>递推关系</p>
<p><span class="math inline">\(dp[i][j]\)</span> 取决于是否选择 coin = coins[i-1]</p>
<ul>
<li>如果不选（即不将 coin 装入背包），<span class="math inline">\(dp[i][j] = dp[i - 1][j]\)</span></li>
<li>如果选（即将 coin 装入背包），<span class="math inline">\(dp[i][j] = dp[i][j-coin]\)</span>，注意<strong>此处与 0-1背包 不同，硬币还可再选取。</strong></li>
</ul>
<p>要得到总的组合数，状态转移方程为：</p>
<p><span class="math inline">\(dp[i][j] = dp[i - 1][j] + dp[i][j-coin]\)</span></p></li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> coin = coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= coin)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coin];</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>状态压缩：通过观察可以发现，<code>dp</code>数组的转移只和<code>dp[i][..]</code>和<code>dp[i-1][..]</code>有关，所以可以压缩状态，进一步降低算法的空间复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> coin = coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= coin)</span><br><span class="line">                    dp[j] += dp[j - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>下面两题为完全背包的变体：物品可以无限次选取，且<strong>考虑物品放入背包的顺序</strong>。</p>
<h5 id="组合总和medium">377，组合总和Ⅳ，medium</h5>
<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">target &#x3D; 4</span><br><span class="line"></span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line">因此输出为 7。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>题意分析</p>
<p>完全背包问题的变体：</p>
<p>数组的每个元素可以使用多次，直到等于target。</p>
<p>不同于完全背包：顺序不同的序列被视作不同的组合。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i]\)</span> —数组的元素组合为 i 的个数。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0] = 1\)</span> 所有数都不选，只有一种。</p></li>
<li><p>状态转移方程</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/00df062b020fa03ff81e0a7000b1f3df.png" alt="image.png" /><figcaption>image.png</figcaption>
</figure>
<p>以 <code>nums =[1,2,3]，target = 4</code> 为例，</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210108113212272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>即将 <code>target = 4</code> 拆分为 <code>nums[i]</code> 和 <code>dp[target - nums[i]]</code>，最终得到 <span class="math inline">\(dp[4] = dp[3] + dp[2] + dp[1]\)</span></p>
<p>则状态转移方程为：</p>
<p><span class="math inline">\(dp[i] = sum(dp[i - num])\)</span> <code>for num in nums and if i &gt;= num</code></p></li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= i)&#123;</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="单词拆分medium">139，单词拆分，medium</h5>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<ul>
<li><p>题意分析</p>
<p>完全背包问题的变体：物品(<code>wordDict</code>中的单词)可以无限使用，直到填满背包（字符串s）。TRUE / False 问题。</p></li>
<li><p>思路</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i]\)</span> 字符串前 i 个字符组成的字符串 s[0,i-1] 能否拆分为 <code>wordList</code> 中的单词</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0] = 0\)</span> 表示空串且合法。</p></li>
<li><p>递推关系</p>
<p>对于物品（<code>wordDict</code> 中的单词），要求有顺序放入背包（字符串s），则将物品迭代置于内循环，将背包迭代放在外循环，这样才能让物品按一定顺序放入背包中。</p>
<p>如果有单词 等于 字符串s的一部分，需要检查后面的字符串是否能放入背包。</p>
<p><span class="math inline">\(dp[i] = dp[i] | dp[i - len];\)</span><img src="https://img-blog.csdnimg.cn/20210108114808230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210108114808238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p></li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//s 为背包</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String word : wordDict)&#123;</span><br><span class="line">                <span class="keyword">int</span> len = word.length();</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= len &amp;&amp; word.equals(s.substring(i-len, i)))</span><br><span class="line">                    dp[i] = dp[i] | dp[i - len];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="完全背包问题总结">完全背包问题总结</h5>
<p><strong>做题步骤</strong>：</p>
<ol type="1">
<li><p><strong>理解题意</strong>，判定此题为 完全背包问题 或 完全背包问题的变体。根据所求分为组合问题，True/False问题，最大最小问题。通常用<strong>一维 <span class="math inline">\(dp\)</span> 数组</strong>解题。</p></li>
<li><p>此题是否有<strong>特殊情况</strong></p></li>
<li><p><strong>动态规划</strong>正常做法</p>
<ol type="1">
<li><p>子问题：确定背包和物品指代什么，<span class="math inline">\(dp[i]\)</span> 返回值是什么</p>
<ol start="2" type="1">
<li>base case：通常为 <span class="math inline">\(dp[0]\)</span></li>
</ol></li>
<li><p>状态转移方程： <strong>先遍历背包，再遍历物品。</strong>这样才能保证放入顺序。</p></li>
</ol>
<p>组合问题公式 dp[i] += dp[i - num] True/False问题公式 dp[i] = dp[i] or dp[i - num] 最大最小问题公式 dp[i] = min(dp[i], dp[i - num]+1) 或 dp[i] = max(dp[i], dp[i - num]+1)</p></li>
<li><p>最终<strong>返回结果</strong></p></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LeetCode刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>一文解决股票交易问题</title>
    <url>/2021/01/12/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>终于到动态规划的最后一部分啦，完结撒花~</p>
<p>这一篇总结【股票交易问题】，参考的是<a href="#https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/qi-ta-jing-dian-wen-ti/tuan-mie-gu-piao-wen-ti">labuladong的文章</a></p>
<p><strong>相关问题有：</strong></p>
<a id="more"></a>
<ul>
<li><p>121，买卖股票的最佳时机</p></li>
<li><p>122，买卖股票的最佳时机Ⅱ</p></li>
<li><p>309，最佳买卖股票时机含冷冻期</p></li>
<li><p>714，最佳买卖股票时机含手续费</p></li>
<li><p>123，买卖股票的最佳时机Ⅲ</p></li>
<li><p>188，买卖股票的最佳时机Ⅲ</p></li>
</ul>
<h5 id="做题思路">做题思路</h5>
<p>对股票，每天有三种选择：<strong>买入、卖出、保持不变</strong>。注意卖出必须在买入之后，买入必须在卖出之后，保持不变分为两种状态：一种是买入之后的持有股票，一种是卖出之后的不持有股票。</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i][k][s]\)</span> — 在第 i 天，交易次数最多为 k，持有状态为 s 的最大利润。其中，0 =&lt; i &lt;= n - 1 , k &gt;= 1，s = 0 或 1。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[-1][k][0] = 0\)</span></p>
<p>解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。</p>
<p><span class="math inline">\(dp[-1][k][1] = -infinity\)</span></p>
<p>解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</p>
<p><span class="math inline">\(dp[i][0][0] = 0\)</span></p>
<p>解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。</p>
<p><span class="math inline">\(dp[i][0][1] = -infinity\)</span></p>
<p>解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</p></li>
<li><p>状态转移方程</p>
<p><span class="math inline">\(dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\)</span></p>
<p>解释：今天没有持有股票，有两种可能：</p>
<p>要么是昨天就没有持有，然后今天保持不变；要么是昨天持有股票，但是今天卖出了，所以今天没有持有股票。</p>
<p><span class="math inline">\(dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\)</span></p>
<p>解释：今天持有着股票，有两种可能：</p>
<p>要么昨天就持有着股票，然后今天保持不变；要么昨天本没有持有，但今天买入，所以今天就持有股票了。</p></li>
<li><p>返回值</p>
<p><span class="math inline">\(dp[n - 1][k][0]\)</span> — 最后一天，最多允许 K 次交易，最多获得多少利润。[0] 表示手上的股票已经卖出去了，很显然最后一天不持有股票得到的利润一定更大。</p></li>
</ol>
<p>再将此思路运用到下面题目：</p>
<h5 id="买卖股票的最佳时机easy">121，买卖股票的最佳时机，easy</h5>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：</p>
<p>按照套路模板， k = 1时状态转移方程为：</p>
<p><span class="math inline">\(dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\)</span></p>
<p><span class="math inline">\(dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) =max(dp[i-1][1][1], -prices[i])\)</span></p>
<p>k 对状态转移没有影响，可简化为两个状态。</p>
<ol type="1">
<li><p>子问题</p>
<p>$ dp[i][s]$ — 第 i 天 持有状态为 s = 0 或 1 的 最大利润。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0][0] = 0\)</span> 最开始一天，没有持有股票，利润为0。</p>
<p><span class="math inline">\(dp[0][1] = - prices[0]\)</span> 最开始一天，持有股票，利润为 - 买入价钱。</p></li>
<li><p>状态转移方程</p>
<p>从第二天开始遍历</p>
<p><span class="math inline">\(dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])\)</span></p>
<p><span class="math inline">\(dp[i][1] = max(dp[i-1][1], -prices[i])\)</span></p></li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">// int price = prices[i];</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>关于base case 的解释：</p>
<p>i ∈[0, n - 1]，在循环中可能会出现 i 为 -1 的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要对 <code>i - 1 == -1</code> 进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> == -<span class="number">1</span>) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 解释：</span></span><br><span class="line">        <span class="comment">//   dp[i][0] </span></span><br><span class="line">        <span class="comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span></span><br><span class="line">        <span class="comment">// = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">        <span class="comment">//解释：</span></span><br><span class="line">        <span class="comment">//   dp[i][1] </span></span><br><span class="line">        <span class="comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span></span><br><span class="line">        <span class="comment">// = max(-infinity, 0 - prices[i]) </span></span><br><span class="line">        <span class="comment">// = -prices[i]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>放在 i = 0开始的循环中判断。为了简化将 i = 0提出，再从 i = 1 第二天开始循环，即上面所示代码。</p></li>
</ul></li>
<li><p>状态压缩</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">// int price = prices[i];</span></span><br><span class="line">            dp[<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其他方法：一次遍历，<em>找到最低点买入，卖出一定在买入之后，即找到最大差值时卖出。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];<span class="comment">//最低点</span></span><br><span class="line">        <span class="keyword">int</span> maxPro = <span class="number">0</span>;<span class="comment">//最大利润</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min &gt; prices[i]) </span><br><span class="line">                min = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(maxPro &lt; prices[i] - min) </span><br><span class="line">                maxPro = prices[i] - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="买卖股票的最佳时机easy-1">122，买卖股票的最佳时机Ⅱ，easy</h5>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：</p>
<p>与上面的区别仅在于 k = + 无穷，就可以认为 <code>k = k - 1</code>。模板的状态转移方程为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">            = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>
<p>可以压缩为两个状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>状态压缩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], dp[<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="最佳买卖股票时机含冷冻期medium">309，最佳买卖股票时机含冷冻期，medium</h5>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：</p>
<p>与上一题相同在 k = + 无穷，不同在 卖出股票的第二天不能进行交易。</p>
<ul>
<li><p>状态转移方程</p>
<p>在上一题的状态转移方程上 <span class="math inline">\(dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\)</span>、<span class="math inline">\(dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\)</span> 修改。如果今天持有股票，可能前一天持有保持不变，也可能之前没有股票，今天买入。但题中一天的冷静期说明今天持有的状态要在冷静期之前的状态上改变，则 <span class="math inline">\(dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\)</span></p></li>
<li><p>base case</p>
<p>如果按照上面从第二天开始循环，会出现 <span class="math inline">\(dp[-1]\)</span> 的情况，所以要多处理个 $dp[1] $</p></li>
</ul></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = Math.max(<span class="number">0</span>, prices[<span class="number">1</span>] - prices[<span class="number">0</span>]);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = Math.max(-prices[<span class="number">0</span>], -prices[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="最佳买卖股票时机含手续费medium">714，最佳买卖股票时机含手续费，medium</h5>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<p>与122题相同在 k = +无穷，不同在 卖出股票需要支付手续费。</p>
<ul>
<li><p>状态转移方程</p>
<p>在上一题的状态转移方程上 <span class="math inline">\(dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\)</span>、<span class="math inline">\(dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\)</span> 修改。一次交易需要支付一次手续费，则只在卖出时考虑交费，则 <span class="math inline">\(dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)\)</span></p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>状态压缩</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], dp[<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="买卖股票的最佳时机hard">123，买卖股票的最佳时机Ⅲ，hard</h5>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：</p>
<p>此题与上面的题不同在于：上面的题目中 k 都被化简掉了。但此题 k 由于没有消掉 k 的影响，所以必须要对 k 进行穷举，除了遍历 i，还要遍历 k。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> max_k = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[0][1][0] = 0;</span></span><br><span class="line">        <span class="comment">// dp[0][2][0] = 0;</span></span><br><span class="line">        <span class="comment">// dp[0][1][1] = -prices[0];</span></span><br><span class="line">        <span class="comment">// dp[0][2][1] = -prices[0];</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                处理base <span class="keyword">case</span></span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][<span class="number">1</span>][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    dp[i][<span class="number">2</span>][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) = max(0,-无穷) = 0</span></span><br><span class="line">                    <span class="comment">//dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i]) = max(0,-无穷) = 0</span></span><br><span class="line">                    <span class="comment">//dp[i][1][1] = max(dp[i-1][1][1],dp[i-1][0][0] - prices[i]) = max(-无穷, -prices[i]) = -prices[i]</span></span><br><span class="line">                    <span class="comment">//dp[i][2][1] = max(dp[i-1][2][1],dp[i-1][0][0] - prices[i]) = max(-无穷, -prices[i]) = -prices[i]</span></span><br><span class="line">                &#125;</span><br><span class="line">               dp[i][k][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">               dp[i][k][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="买卖股票的最佳时机hard-1">188，买卖股票的最佳时机Ⅲ，hard</h5>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：</p>
<p>与上一题区别在于完成 k 笔交易，有了上一题的铺垫，此题的代码很好解决。但按照上面的思路，k 太大会出现超出内存限制。思考：交易数k 最大有多大呢？</p>
<p>一次交易分为买入和卖出，至少需要两天。所以有效的限制 <code>k  &lt;= n / 2</code>，如果超过，就没有约束作用了，相当于 k = +无穷（即第122题）。</p></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span> || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k &gt; n / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfit(prices);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j &gt;= <span class="number">1</span>; j--)&#123;</span><br><span class="line">                <span class="comment">//处理base case</span></span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">               dp[i][j][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">0</span>], dp[i-<span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">               dp[i][j][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>股票交易</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—数组（二分法）</title>
    <url>/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h3 id="二分查找">二分查找</h3>
<p>目录如下：</p>
<p><a href="#引入">1. 二分查找基本框架</a></p>
<p><a href="#一、寻找左侧边界的二分搜索">2. 二分查找左边界</a></p>
<p><a href="#二、寻找右侧边界的二分查找">3. 二分查找右边界</a></p>
<a id="more"></a>
<p>相关题目：</p>
<p>704，二分查找</p>
<p>34，在排序数组中查找元素的第一个和最后一个位置</p>
<p>278，第一个错误的版本</p>
<p>875，爱吃香蕉的可可</p>
<p>1011，在D天内送达包裹的能力</p>
<p>69，x的平方根</p>
<p>744，寻找比目标字母大的最小字母</p>
<p>153，寻找旋转排序数组中的最小值</p>
<h4 id="引入">引入</h4>
<p>常用的二分查找场景：寻找一个数、寻找重复数的左侧边界、寻找重复数的右侧边界。</p>
<h6 id="二分查找框架">二分查找框架</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;        </span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;        		<span class="keyword">if</span> (nums[mid] == target) &#123;            </span><br><span class="line">            ...        </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;            				left = ...                           </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;            			  right = ...        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析二分查找的一个技巧是：不要出现 else，而是把<strong>所有情况用</strong> <strong>else if</strong> 写清楚，这样可以清楚地展现所有细节。</p>
<h5 id="二分查找easy">704，二分查找，easy</h5>
<p>给定一个升序数组<code>nums</code>和一个目标值<code>target</code>，搜索 <code>nums</code>中的<code>target</code>，如果存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>你可以假设 <code>nums</code> 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 <code>nums</code> 的每个元素都将在 [-9999, 9999]之间。</p>
<p><strong>题解：</strong></p>
<p>此题是二分查找最简单的场景。通过代码理解上面框架的细节。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] ==  target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong>：</p>
<ol type="1">
<li><p>while 内的循环条件为什么是 <code>&lt;=</code> 而不是<code>&lt;</code> ?</p>
<p>答：初始化 <code>right</code> 的索引为 <code>nums.length - 1</code>，相当于两端都闭区间 <code>[left, right]</code>，<strong>这个区间其实就是每次进行搜索的区间</strong>。</p>
<p>当找到目标值（<code>nums[mid] ==  target</code>）停止搜索，如果没找到，就需要while循环终止，然后返回 -1 。</p>
<p>那 while 循环什么时候应该终止？<strong>搜索区间为空的时候应该终止</strong>，意味着没得找了，就等于没找到。</p>
<p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p>
<p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[right, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，<strong>这时候区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p>
<p>如果非要用 <code>while(left &lt; right)</code> 也可以，我们已经知道了出错的原因，就打个补丁好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <strong><code>right = mid</code></strong> 或者 <code>left = mid</code>，没有这些加加减减，到底怎么回事，怎么判断？</p>
<p>答：本题中搜索区间的<strong>两端都是闭</strong>的，<code>[left, right]</code>。当索引 <code>mid</code> 对应元素不是<code>target</code>，需要改变<code>left</code> 和 <code>right</code>重新搜索，搜索区间变为 <code>[left, mid - 1]</code> 或者 <code>[mid + 1, right]</code> 。</p></li>
<li><p>此算法的缺陷？</p>
<p>答：当一个有序数组中含有多个目标值时，无法处理。例如：有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引是 2。</p></li>
</ol>
<h4 id="引入-1">引入</h4>
<p>上面题目说明了在有序数组中找到元素 <code>target</code> 的方法，下面介绍 搜索左右边界 的方法。</p>
<h6 id="一寻找左侧边界的二分搜索">一、寻找左侧边界的二分搜索</h6>
<ul>
<li>下面是最常见的代码形式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>细节：</p>
<ol type="1">
<li><p><strong>while 内的循环条件为什么是 <code>&lt;</code> 而不是<code>&lt;=</code> ?</strong></p>
<p>答：因为 <code>right = nums.length</code>，搜索区间是 <code>[left,right)</code>左闭右开。</p>
<p>while终止的条件是 <code>left == right</code>，此时搜索区间是 <code>[left,left)</code>为空，可以正确终止。</p></li>
<li><p><strong>为什么</strong> <code>left = mid + 1</code>，<code>right = mid</code><strong>？</strong></p>
<p>答：由于搜索区间左闭右开，遍历到<code>nums[mid]</code>之后，重新分成的两个区间应该为 <code>[mid + 1, right)</code> 和 <code>[left, mid)</code>。</p></li>
<li><p><strong>为什么返回的是 left 而不是 -1 ?</strong></p>
<p>答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Qt9xu791-1611046986289)(https://gblobscdn.gitbook.com/assets%2F-MQPy5wekRlwH59Y-EnB%2Fsync%2Fda0a55ba889b5c1682dee99f8180d2bfcea66610.jpg?alt=media)]</p>
<p>对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：<code>nums</code> 中小于 2 的元素有 1 个。</p>
<p>比如对于有序数组 <code>nums = [2,3,5,7]</code>, <code>target = 1</code>，算法会返回 0，含义是：<code>nums</code> 中小于 1 的元素有 0 个。</p>
<p>再比如说 <code>nums = [2,3,5,7], target = 8</code>，算法会返回 4，含义是：<code>nums</code> 中小于 8 的元素有 4 个。</p>
<p>综上可以看出，函数的返回值（即 <code>left</code> 变量的值）取值区间是闭区间 <code>[0, nums.length]</code>，所以我们简单添加两行代码就能在正确的时候 return -1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// target 比所有数都大</span></span><br><span class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 类似之前算法的处理方式</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>另外，返回left 或 right 都可以，因为while终止的条件是 <code>left == right</code>。</p></li>
</ol></li>
<li><p><strong>最终代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// target 比所有数都大</span></span><br><span class="line">	<span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 类似之前算法的处理方式</span></span><br><span class="line">	<span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="二寻找右侧边界的二分查找">二、寻找右侧边界的二分查找</h6>
<p>与上面思想类似。</p>
<ul>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">//向右收缩</span></span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>;<span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>细节：</p>
<ol type="1">
<li><p><strong>为什么找右边界</strong> <code>left = mid + 1</code> ？</p>
<p>答：当 <code>nums[mid] == target</code> 时，增大搜索区间 的下界 left，使区间向右收缩。由于搜索区间为<code>[left,right)</code>，则向右收缩时，新的下界为 <code>left = mid + 1</code>。寻找左边界向左收缩时，新的上界 <code>right = mid</code>。</p></li>
<li><p><strong>为什么最后返回 <code>left - 1</code> 而不像左边界 返回</strong> <code>left</code> ？</p>
<p>答：while终止条件 <code>left == right</code>，也就是返回 <code>right - 1</code>。</p>
<p><img src="https://gblobscdn.gitbook.com/assets%2F-MQPy5wekRlwH59Y-EnB%2Fsync%2Fa360ba87672e68434224884dfc1393a6039f8130.jpg?alt=media" alt="img" style="zoom:80%;" /></p>
<p>因为对 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，（也就是 <code>mid = left - 1</code>），while 循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。</p></li>
<li><p><strong>为什么没有返回 -1 的操作？如果</strong> <strong><code>nums</code></strong> <strong>中不存在</strong> <strong><code>target</code></strong> <strong>这个值，怎么办</strong>？</p>
<p>答：类似之前的左侧边界搜索，因为 while 的终止条件是 <code>left == right</code>，就是说 <code>left</code> 的取值范围是 <code>[0, nums.length]</code>，所以可以添加两行代码，正确地返回 -1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//注意</span></span><br><span class="line"><span class="keyword">return</span> nums[left-<span class="number">1</span>] == target ? (left-<span class="number">1</span>) : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p><strong>最终代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">//向右收缩</span></span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// target 比所有数都小</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> nums[left-<span class="number">1</span>] == target ? (left-<span class="number">1</span>) : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="在排序数组中查找元素的第一个和最后一个位置medium">34，在排序数组中查找元素的第一个和最后一个位置，medium</h5>
<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 [-1, -1]。</p>
<p>进阶：</p>
<p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [], target &#x3D; 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>0 &lt;= <code>nums.length</code> &lt;= 10<sup>5</sup> -10<sup>9</sup> &lt;= <code>nums[i]</code> &lt;= 10<sup>9</sup> <code>nums</code> 是一个非递减数组 -10<sup>9</sup> &lt;= <code>target</code> &lt;= 10<sup>9</sup></p>
<p><strong>题解：</strong></p>
<p>思路就是找 target 的左右边界，如果找不到就返回 [-1, -1]。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftBound = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightBound = -<span class="number">1</span>;</span><br><span class="line">        leftBound = getLeftBound(nums, target);</span><br><span class="line">        rightBound = getRightBound(nums, target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;leftBound, rightBound&#125;;</span><br><span class="line">    &#125; </span><br><span class="line">   <span class="comment">//左边界</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="comment">//左闭右开 [left,right)</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="comment">//向左收缩</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == n) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[left] == target? left : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右边界</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="comment">//左闭右开 [left,right)</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ( right - left)/ <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="comment">//向右收缩</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[left - <span class="number">1</span>] == target? (left - <span class="number">1</span>): -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h5 id="第一个错误的版本easy">278，第一个错误的版本，easy</h5>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 n &#x3D; 5，并且 version &#x3D; 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。 </span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>利用二分法找第一个错误的版本，搜索范围为 <span class="math inline">\([1,n)\)</span>，左边界。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class="line"><span class="comment">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="爱吃香蕉的可可medium">875，爱吃香蕉的可可，medium</h5>
<p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p>
<p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。</p>
<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>
<p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: piles &#x3D; [3,6,7,11], H &#x3D; 8</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: piles &#x3D; [30,11,23,4,20], H &#x3D; 5</span><br><span class="line">输出: 30</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: piles &#x3D; [30,11,23,4,20], H &#x3D; 6</span><br><span class="line">输出: 23</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= piles.length &lt;= 10^4 piles.length &lt;= H &lt;= 10^9 1 &lt;= piles[i] &lt;= 10^9</p>
<p><strong>题解：</strong></p>
<p>题中求在 H 小时吃掉全部香蕉的最小速度 K，即在所有可能吃完的速度中找到左边界 K，就转换为 二分法寻找左边界的问题。</p>
<p>对于吃的速度来说，最小为 1，最大为 max(piles)，因为每小时只能选一堆香蕉吃。</p>
<p>应用上面寻找左边界的框架，并根据实际场景修改。</p>
<ul>
<li>先找到数组的最大元素 <code>maxPile</code></li>
<li>在 <code>[1, maxPile]</code> 范围内使用二分法找 K，<code>target</code> 为是否能吃完香蕉。
<ul>
<li>如果当前速度能吃完，向左收缩继续找。</li>
<li>如果当前速度不能吃完，向右找。 <strong>代码</strong>：</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxPile = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : piles)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxPile) maxPile = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = maxPile + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(canEat(piles, mid, H))&#123;</span><br><span class="line">                <span class="comment">//能吃完就向左收缩</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//target：当前速度是否能吃完</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canEat</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> speed, <span class="keyword">int</span> H)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile : piles)&#123;</span><br><span class="line">            time += timeOf(pile, speed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time &lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">timeOf</span><span class="params">(<span class="keyword">int</span> pile, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向上取整</span></span><br><span class="line">        <span class="keyword">return</span> pile / speed + (pile % speed &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在d天内送达包裹的能力medium">1011，在D天内送达包裹的能力，medium</h5>
<p>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p>
<p>传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [3,2,2,4,1,4], D &#x3D; 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,1,1], D &#x3D; 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= D &lt;= weights.length &lt;= 50000 1 &lt;= weights[i] &lt;= 500</p>
<p><strong>题解：</strong></p>
<p>与上一题相同，是二分法在实际问题的应用。</p>
<p>搜索范围是 能在D天内将所有包裹送达的运载能力 <code>[max(weights)，sum(weights)]</code>。</p>
<p>寻找左边界。</p>
<p>target：以此运载能力 <code>cap</code>可以在D天全部送达</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : weights)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : weights)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxWeight) i = maxWeight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = maxWeight;</span><br><span class="line">        <span class="keyword">int</span> right = sum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(canTrans(weights, D, mid))&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前运输能力为K，能否在D天运完</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canTrans</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span> D, <span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">        <span class="comment">//运送物品个数</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历D天，如果运送物品个数 = w数组元素个数，表示可以运完</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">0</span>; day &lt; D; day++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxCap = cap;</span><br><span class="line">            <span class="keyword">while</span> ((maxCap -= w[i]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (i == w.length)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="x的平方根easy">69，x的平方根，easy</h5>
<p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>
<p><strong>题解：</strong></p>
<p>很容易想到 x 的平方根比 <code>x / 2</code> 小，但事实如此吗？</p>
<p>解方程 <span class="math inline">\(√x &lt; x / 2\)</span> ，得 $x &gt; 4 $，即 <span class="math inline">\(x = 1,2,3\)</span> 时，平方根为 1。在写代码时就要考虑这一特殊情况。</p>
<p>还要注意此题向下取整，具体怎么做在代码中体现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//有测试用例是 2147395599，求得 mid 平方会超过 int 范围，因此需要将平方结果转为 long </span></span><br><span class="line">            <span class="keyword">long</span> sqr = (<span class="keyword">long</span>)mid * mid;</span><br><span class="line">            <span class="keyword">long</span> sqr_next = (<span class="keyword">long</span>)(mid + <span class="number">1</span>) * (mid + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//比如 x=8，mid=2,sqr=4,sqr_next=9。向下取整即取当前的mid。</span></span><br><span class="line">            <span class="keyword">if</span>(sqr == x || (sqr &lt; x &amp;&amp; sqr_next &gt; x))&#123;</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sqr &gt; x)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回 x 是考虑 x = 1时</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<p>做题时对向下取整和边界问题困扰很久，这种方法比较好理解，也不用考虑那么多。</p>
<h5 id="寻找比目标字母大的最小字母easy">744，寻找比目标字母大的最小字母，easy</h5>
<p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。</p>
<p>在比较时，字母是依序循环出现的。举个例子：</p>
<p>如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;a&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;c&quot;</span><br><span class="line">输出: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;d&quot;</span><br><span class="line">输出: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;k&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>letters长度范围在[2, 10000]区间内。 letters 仅由小写字母组成，最少包含两个不同的字母。 目标字母target 是一个小写字母。</p>
<p><strong>题解</strong></p>
<ul>
<li>方法一：线性搜索。因为数组已排序，遍历 letters 数组，找到第一个比目标字母大的字母就返回。若都比目标字母小，则返回第一个。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">//线性搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(letters[i] - target &gt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> letters[i];        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：二分搜索。在 letters 数组中找到比 目标字母大的字母 中的左边界。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = letters.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] - target &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组中的字符都比 target 小</span></span><br><span class="line">        <span class="keyword">if</span>(left == letters.length) <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> letters[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<p>因为可能全部字母都比目标字母大，有可能找不到左边界，还要单独判断一下 <code>left == letters.length</code>，如果是，返回第一个字母。</p>
<h5 id="寻找旋转排序数组中的最小值medium">153，寻找旋转排序数组中的最小值，medium</h5>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。</p>
<p>请找出其中最小的元素。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= <code>nums.length</code> &lt;= 5000 -5000 &lt;= nums[i] &lt;= 5000 nums 中的所有整数都是 唯一 的 nums 原来是一个升序排序的数组，但在预先未知的某个点上进行了旋转</p>
<ul>
<li>方法一：线性搜索。如果升序数组发生了旋转，比较相邻两元素，如果前一个元素比后一个元素大，返回后者。如果没旋转，返回首个元素即最小值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">//线性搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i + <span class="number">1</span>]) <span class="keyword">return</span> nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不旋转，返回首个元素</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法二：二分法。此题的目的是找到数组的最小值。</p>
<p>注意此时不一定是有序数组，可能发生了旋转。在找到 mid 时，要确定最小值在 mid 的左侧还是右侧。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;  </span><br><span class="line">            <span class="comment">//min在mid右边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                min = Math.min(min, nums[mid]);</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                min = Math.min(min, nums[mid]);</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—数组（双指针）</title>
    <url>/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E6%95%B0%E7%BB%84%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89/</url>
    <content><![CDATA[<p>数组题目中有两种双指针的应用：和<strong>快慢指针</strong>。 目录如下：</p>
<p><a href="#双指针（左右）">双指针（左右）</a></p>
<p><a href="#双指针（快慢）">双指针（快慢）</a></p>
<p>相关题目有：</p>
<a id="more"></a>
<p><a href="#344，反转字符串，easy">344，反转字符串</a></p>
<p><a href="#26，删除排序数组中的重复项，easy">26，删除排序数组中的重复项</a></p>
<p><a href="#27，移除元素，easy">27，移除元素</a></p>
<p><a href="#283，移动零，easy">283，移动零</a></p>
<p><a href="#485，最大连续1的个数，easy">485，最大连续1的个数</a></p>
<p><a href="#540，有序数组中的单一元素，medium">540，有序数组中的单一元素</a></p>
<p><a href="#209，长度最小的子数组，medium">209，长度最小的子数组</a></p>
<h3 id="双指针左右">双指针（左右）</h3>
<p>左右指针在数组中实际是指两个索引值，一般初始化为<code>left = 0, right = nums.length - 1</code>。循环条件为 <code>while(left &lt; right)</code> 。</p>
<p>在上篇文章<a href="#https://blog.csdn.net/qq_39181839/article/details/112847321">二分查找</a>中，凸出了双指针特性。在下面题目中体会。</p>
<p>看到题目要求有【原地修改】的要求，一般都采用双指针。</p>
<h5 id="两数之和easy">167，两数之和Ⅱ，easy</h5>
<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:</p>
<p>返回的下标值（<code>index1</code> 和 <code>index2</code>）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节<code>left</code>和<code>right</code>可以调整<code>sum</code>的大小</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;        </span><br><span class="line">		<span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[left] + numbers[right] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[left] + numbers[right] &lt; target)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="反转字符串easy">344，反转字符串，easy</h5>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">          <span class="keyword">char</span> temp = s[left];  </span><br><span class="line">          s[left] = s[right];</span><br><span class="line">          s[right] = temp;</span><br><span class="line">          left++;</span><br><span class="line">          right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双指针快慢">双指针（快慢）</h3>
<p>快慢指针在数组中实际是指两个索引值，快指针始终在慢指针的前面，一般初始化为 <code>slow = 0, fast = 0 或 1</code>。循环条件为 <code>while(fast &lt; nums.length)</code> 。</p>
<h4 id="框架">框架</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> f&amp;s(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span> 或 <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="comment">//当前元素值不是所找的</span></span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != ...)&#123;</span><br><span class="line">                <span class="comment">//看slow、fast具体含义</span></span><br><span class="line">                ...</span><br><span class="line">				slow = ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，fast继续向前找</span></span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除排序数组中的重复项easy">26，删除排序数组中的重复项，easy</h5>
<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回<strong>移除后数组的新长度</strong>。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>快慢指针初始指向索引0和1，用快指针探路，慢指针保存没有重复元素的数组。</p>
<p>快指针向前，直到不和 当前慢指针指向元素 重复，慢指针索引+1，指向元素为新的数字。</p>
<p><a href="https://mmbiz.qpic.cn/sz_mmbiz_gif/gibkIz0MVqdFXdiaWmw4sp8GT0YI41Rk5muqNGreX2FbysTeUnlAWECO1eYWc5ZZDPMYCs7ViaHkEaOfK4lI9HD7A/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1">动画演示</a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[slow] != nums[fast])&#123;</span><br><span class="line">                slow++;</span><br><span class="line">                <span class="comment">// 维护 nums[0..slow] 无重复</span></span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组长度为索引 + 1</span></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>类似题目：83.删除排序链表中的重复元素</p>
<h5 id="移除元素easy">27，移除元素，easy</h5>
<p>你一个数组 <code>nums</code> 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回<strong>移除后数组的新长度</strong>。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>快慢指针初始都指向首个元素，快指针用于探路，如果不等于 val，则可以进行覆盖；如果等于 val，继续向前。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="comment">//当前元素值不等于val</span></span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                <span class="comment">//建立新数组（覆盖在原数组上）</span></span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，fast继续向前找等于val的元素</span></span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<p>上一题要求是删除重复元素，fast 移到下一个不重复元素时，索引<code>slow++</code>，并将fast 指向的值赋给 <code>nums[slow]</code>，最后得到数组长度为 索引数<code>slow</code> + 1。</p>
<p>这里是先给<code>nums[slow]</code>赋值然后再给<code>slow++</code>，这样可以保证<code>nums[0..slow-1]</code>是不包含值为<code>val</code>的元素的，最后的结果数组长度就是<code>slow</code>。</p>
<h5 id="移动零easy">283，移动零，easy</h5>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。</p>
<p><strong>题解</strong></p>
<p>与上一题类似，只是删除操作改成了移动操作。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)&#123;    </span><br><span class="line">                <span class="comment">//交换</span></span><br><span class="line">                <span class="keyword">int</span> temp = nums[fast];</span><br><span class="line">                nums[fast] = nums[slow];</span><br><span class="line">                nums[slow] = temp;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>另一种解法</strong></p>
<p>遍历此数组，如果当前元素不为0，就赋给慢指针所在位置的元素，遍历结束再将慢指针之后的元素赋为 0。可以看成建立了新的数组，但是是在原数组上改变的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)</span><br><span class="line">                nums[index++] = nums[i];           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最大连续1的个数easy">485，最大连续1的个数，easy</h5>
<p>给定一个二进制数组， 计算其中最大连续1的个数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,0,1,1,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>输入的数组只包含 0 和1。</p>
<p>输入数组的长度是正整数，且不超过 10,000。</p>
<p><strong>题解</strong></p>
<p>快慢指针初始都指向首个元素，快指针移至最后一个非 0 元素，<code>fast - slow</code> 即为当前连续1 的个数。当 <code>nums[fast] = 0</code> 时，<code>slow</code> 移至 <code>fast</code> 之后再开始统计。重复上述步骤直至 <code>fast</code> 遍历到最后一个元素。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">1</span>)&#123;</span><br><span class="line">                res = Math.max(res, fast - slow);</span><br><span class="line">                slow = fast + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组全1的情况</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(res, fast - slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<p>注意考虑数组全为 1 的情况，返回值为 <code>fast - slow</code> 。</p>
<p><strong>另一种解法</strong></p>
<p>一次遍历。两个计数器 <code>count</code>、<code>maxCount</code>作为计数指针 和 当前连续1 的最大个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                maxCount = Math.max(count, maxCount);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面两题稍有不同，但总体思想大致一致。</p>
<h5 id="有序数组中的单一元素medium">540，有序数组中的单一元素，medium</h5>
<p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2,3,3,4,4,8,8]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,3,7,7,10,11,11]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;           </span><br><span class="line">            <span class="comment">//检查这一对数，如果不同返回第一个数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[slow] &lt; nums[fast])</span><br><span class="line">                <span class="keyword">return</span> nums[slow];</span><br><span class="line">            <span class="comment">//否则，检查下一对数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[slow] == nums[fast])&#123;</span><br><span class="line">                slow = slow + <span class="number">2</span>;</span><br><span class="line">                fast = fast + <span class="number">2</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//nums仅有一个元素的特殊情况</span></span><br><span class="line">        <span class="keyword">return</span> nums[slow];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="长度最小的子数组medium">209，长度最小的子数组，medium</h5>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>快慢指针来维护一个滑动窗口，相当于数组元素入队出队。具体过程可以用队列来理解，但代码实现用快慢指针。</p>
<p><img src="https://pic.leetcode-cn.com/10ca012c2f0170afcac5e5996add20c32c36a82f4bb4a6187897bb948ace5fe2-image.png" alt="image.png" style="zoom:80%;" /></p>
<p><img src="https://pic.leetcode-cn.com/2da8cf86a2a3df3c95ed7d95add574dca2d8bae8420addd0fa6b8c55fa3db081-image.png" alt="image.png" style="zoom:80%;" /></p>
<p><img src="https://pic.leetcode-cn.com/ca74b1a2ad0eb5a4ebf8647a332161b140c8ebdd71cd5d19bef16e9bf0a43c95-image.png" alt="image.png" style="zoom:80%;" /><img src="https://pic.leetcode-cn.com/72f39b5cd7eb5f866e24d0a31eb3eac7d57cf3ad202ad40d30f103833c1f5a69-image.png" alt="image.png" style="zoom:80%;" /></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="comment">//当前窗口中元素和 小于 s，加入元素</span></span><br><span class="line">            sum += nums[fast]; </span><br><span class="line">            fast++;      </span><br><span class="line">            <span class="comment">//窗口内的元素和 大于等于 s 时，更新最小长度，并缩短窗口</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;                </span><br><span class="line">                min = Math.min(min, fast - slow);</span><br><span class="line">                sum -= nums[slow];</span><br><span class="line">                slow++;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—贪心算法</title>
    <url>/2021/01/31/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p>
<p>什么是贪心选择性质呢，简单说就是：<strong>每一步都做出一个局部最优的选择，最终的结果就是全局最优</strong>。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。</p>
<p>比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。</p>
<h1 id="区间调度问题">区间调度问题</h1>
<a id="more"></a>
<p>先解决一个基础问题：给你很多形如 <code>[start, end]</code> 的闭区间，请你设计一个算法，<strong>算出这些区间中最多有几个互不相交的区间</strong>。</p>
<p>举个例子，<code>intvs = [[1,3], [2,4], [3,6]]</code>，这些区间最多有 2 个区间互不相交，即 <code>[[1,3], [3,6]]</code>，你的算法应该返回 2。注意边界相同并不算相交。</p>
<p><strong>思路</strong></p>
<p>从区间集合 <code>intvs</code> 中选择一个区间 x，这个 x 是在当前所有区间中<strong>结束最早的</strong>（end 最小）。</p>
<p>把所有与 x 区间相交的区间从区间集合 <code>intvs</code> 中删除。</p>
<p>重复步骤 1 和 2，直到 <code>intvs</code> 为空为止。之前选出的那些 x 就是最大不相交子集。</p>
<p><strong>步骤</strong></p>
<p>先把每个区间按最后一个元素进行<strong>升序排序</strong>，其中最小的元素值为<code>x_end</code>，如果后面区间的开始元素比<code>x_end</code>小（即相交），则删除，并更新 <code>x_end</code>。 <img src="https://img-blog.csdnimg.cn/20210131210840745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intervalSchedule</span><span class="params">(<span class="keyword">int</span>[][] intvs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intvs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按 end 升序排序</span></span><br><span class="line">    Arrays.sort(intvs, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 至少有一个区间不相交</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 排序后，第一个区间就是 x，其第二个元素值是 x_end</span></span><br><span class="line">    <span class="keyword">int</span> x_end = intvs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intvs) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = interval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= x_end) &#123;</span><br><span class="line">            <span class="comment">// 找到下一个选择的区间了</span></span><br><span class="line">            count++;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="无重叠区间">435，无重叠区间</h5>
<p>移除的最小数量，则在上面模板中进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">    <span class="keyword">return</span> n - intervalSchedule(intervals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="用最少数量的箭引爆气球">452，用最少数量的箭引爆气球</h5>
<p>区间抽象成气球范围，弓箭最小数量即无重叠区间的最大个数（最多有 <code>n</code> 个不重叠的区间，那么就至少需要 <code>n</code> 个箭头穿透所有区间）。与上面模板不同的是，边界相同也算相交。 <img src="https://img-blog.csdnimg.cn/20210131211004955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 按 end 升序排序</span></span><br><span class="line">        Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 至少有一个区间不相交</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 排序后，第一个区间就是 x，其第二个元素值是 x_end</span></span><br><span class="line">        <span class="keyword">int</span> x_end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point : points) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = point[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (start &gt; x_end) &#123;</span><br><span class="line">                <span class="comment">// 找到下一个选择的区间了</span></span><br><span class="line">                count++;</span><br><span class="line">                x_end = point[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其它">其它</h2>
<h5 id="分发饼干easy">455，分发饼干，easy</h5>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: g &#x3D; [1,2,3], s &#x3D; [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: g &#x3D; [1,2], s &#x3D; [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= g.length &lt;= 3 * 104 0 &lt;= s.length &lt;= 3 * 104 1 &lt;= g[i], s[j] &lt;= 231 - 1</p>
<p><strong>题解</strong></p>
<p>尽可能满足更多的孩子，就不要造成饼干尺寸的浪费。</p>
<p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该<strong>优先满足胃口大</strong>的。</p>
<p>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。</p>
<p>先将饼干和胃口都进行排序，从后向前遍历胃口，用大饼干优先满足胃口大的，并统计满足小孩数量。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="comment">//最大的饼干</span></span><br><span class="line">        <span class="keyword">int</span> i = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//倒序遍历g，找到能满足胃口的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = g.length - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span>; j--)&#123; </span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= g[j])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以从前往后遍历g和s，最小的饼干如果不能满足胃口的话，继续找下一块饼干，如果可以满足，继续比较下一个g 和 s 的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length &amp;&amp; j &lt; g.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= g[j])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续找下一个饼干</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="买卖股票的最佳时机">121，买卖股票的最佳时机</h5>
<p>只允许完成一笔交易（即买入和卖出一支股票一次），计算你所能获取的最大利润。</p>
<p><strong>题解</strong></p>
<p>从左向右遍历时，维护一个最小价格 <code>low</code>，和一个最大利润 <code>maxP</code>，每次比较以当前价格售出时是否为最大利润。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> low = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="comment">//如果当前价格比low小，更新low</span></span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; low) low = prices[i];</span><br><span class="line">            <span class="comment">//得到每次以当前价格卖出得到的最大利润值</span></span><br><span class="line">            maxP = Math.max(maxP, prices[i] - low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="买卖股票的最佳时机-1">122，买卖股票的最佳时机Ⅱ</h5>
<p>允许多次交易，进行买入卖出操作。</p>
<p><strong>题解</strong></p>
<p>多次买卖，只要今天的价格比昨天高，就可以在昨天买入今天卖出，保证今天的利润是正的，这样得到的利润值最大。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;        </span><br><span class="line">		<span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">                maxP += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="种花问题easy">605，种花问题，easy</h5>
<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= flowerbed.length &lt;= 2 * 104 flowerbed[i] 为 0 或 1 flowerbed 中不存在相邻的两朵花 0 &lt;= n &lt;= flowerbed.length</p>
<p><strong>题解</strong></p>
<p>能种花的条件有三个：①. 此位置没有种花 ②. 左边没有种花或者当前为最左 ③. 右边没有种花或者当前为最右.</p>
<p>找到这样的位置就种花，计数器count++，最后返回与 n 的比较值。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;      		  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.length; i++)&#123;</span><br><span class="line">            <span class="comment">//可以种花的条件：当前位置为空、左边为空或为最左、右边为空或为最右</span></span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i] == <span class="number">0</span> &amp;&amp; (i == <span class="number">0</span> || flowerbed[i - <span class="number">1</span>] == <span class="number">0</span>) &amp;&amp; (i == flowerbed.length - <span class="number">1</span> ||  flowerbed[i + <span class="number">1</span>] == <span class="number">0</span>))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<p>在 if 条件句中，要先写 <code>i == 0</code> 和 <code>i ==  n - 1</code>，防止角标越界。</p>
<h5 id="非递减数列easy">665，非递减数列，easy</h5>
<p>给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p>
<p>我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 &lt;= i &lt;= n-2)，总满足 <code>nums[i] &lt;= nums[i + 1]</code>。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,2,3]</span><br><span class="line">输出: true</span><br><span class="line">解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,2,1]</span><br><span class="line">输出: false</span><br><span class="line">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>当 <code>nums</code> 两个相邻元素不满足非递减时，造成了“下降”情况，可以修改为</p>
<ul>
<li><code>nums[i] = nums[i + 1]</code></li>
<li><code>nums[i + 1] = nums[i]</code></li>
</ul>
<p>贪心的思路，让 <code>nums[i + 1]</code> 尽可能的小，使后面更容易非递减。</p>
<p>但是采用上面哪一种需要小心，对不同的数组采取不同的处理方法。</p>
<p>如：</p>
<ul>
<li><p>[1,2,3,1] 当 i 遍历到 3 时，发现比后面元素大，但如果采用第一种，将不满足非递减的条件，需要采用第二种。得到普遍规律为：<code>nums[i + 1] &lt; nums[i - 1]</code> 时，使 <code>nums[i + 1] = nums[i]</code>。</p></li>
<li><p>[1,2,3,2] 当 i 遍历到 3 时，发现比后面元素大，贪心原则将当前元素改为左边元素值。得到普遍规律为：<code>nums[i + 1] ≥ nums[i - 1]</code> 时，使 <code>nums[i] = nums[i + 1]</code>。</p></li>
<li><p>特殊情况为：<code>i == 0</code> 且 <code>nums[i] &gt; nums[i + 1]</code>，只能修改为右边元素值 <code>nums[i] = nums[i + 1]</code>。</p></li>
</ul>
<p>在遍历过程中如果下降次数超过 1 次，则返回true，不用继续判断了。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> down = <span class="number">0</span>;<span class="comment">//下降次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">                down++;</span><br><span class="line">                <span class="keyword">if</span>(down &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//[4,2,3]</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//[1,3,2,4]</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; nums[i + <span class="number">1</span>] &gt;= nums[i - <span class="number">1</span>])</span><br><span class="line">                    nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//[1,3,2,2]</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; nums[i + <span class="number">1</span>] &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">                    nums[i + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最大子序和easy">53，最大子序和，easy</h5>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>贪心思想主要体现在 当前元素加入前的 <code>curSum</code> 为负时，应将 <code>curSum</code> 舍弃，重新计算。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> curSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            curSum += nums[i];</span><br><span class="line">            <span class="comment">//同时获取当前最大和</span></span><br><span class="line">            maxSum = Math.max(maxSum, curSum);</span><br><span class="line">            <span class="comment">//只要正Sum不要负的，如果为负则重新计数</span></span><br><span class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>)</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—回溯算法</title>
    <url>/2021/02/15/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="回溯算法">回溯算法</h2>
<h3 id="前言">前言</h3>
<p><strong>「回溯是递归的副产品，只要有递归就会有回溯」</strong>，所以回溯法也经常和二叉树遍历，深度优先遍历（<span class="math inline">\(dfs\)</span>）混在一起，因为这两种方式都是用了递归。</p>
<p>回溯法就是暴力搜索，优化回溯算法只有<strong>「剪枝」</strong>一种方法。</p>
<p>回溯算法能解决如下问题：</p>
<a id="more"></a>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。你只需要思考 3 个问题：</p>
<p><strong>1、路径</strong>：也就是已经做出的选择。</p>
<p><strong>2、选择列表</strong>：也就是你当前可以做的选择。</p>
<p><strong>3、结束条件</strong>：也就是到达决策树底层，无法再做选择的条件。</p>
<p>代码的框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = [];<span class="comment">//结果集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(路径，选择列表)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (结束条件) &#123;</span><br><span class="line">        result.add(路径)；<span class="comment">//存放结果</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        做选择;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」。</strong></p>
<p>使用两个变量： res 和 path，res 表示<strong>最终的结果</strong>，path 保存<strong>已走过的路径</strong>。当满足结束条件，即<u>到达了决策树的底层</u>，就把 path 放到 res 中。</p>
<p>此总结参考于 labuladong的算法小抄 和 代码随想录。</p>
<h3 id="组合问题">组合问题</h3>
<h5 id="组合medium">77，组合，medium</h5>
<p>给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>n 相当于 树的宽度， k 相当于 树的高度。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/b15fff1a94206fa74dfd68dba60da8b9.png" alt="Image" /><figcaption>Image</figcaption>
</figure>
<p>由上面框架，选择一个数就填入路径集<code>path</code>，结束条件：路径集<code>path</code>大小 = k。</p>
<p>在每层递归如何选择数呢？需要变量 <code>index</code> 记录下一层递归的起始位置，<code>index + 1 ~ n</code>即为下层递归的选择列表。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        backtrack(n, k, <span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> index, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//横向遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt;= n ; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtrack(n, k, i + <span class="number">1</span>, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还可以进行优化，会将效率提高不少。若 <code>n = 5, k = 4</code>，现在 <code>path.size() = 1</code>，那还需 <code>k - path.size() = 3</code> 个数。若 <code>index = 4</code>，则只能选取 5，不满足，故 i 有限制条件。<code>i &lt;= n - (k - path.size()) + 1</code>，即在集合n中至多要从该起始位置 : <code>n - (k - path.size()) + 1</code>开始遍历。</p>
<h4 id="组合总和"><strong>组合总和</strong></h4>
<h5 id="组合总和medium">216，组合总和Ⅲ，medium</h5>
<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<p>所有数字都是正整数。 解集不能包含重复的组合。 示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>借鉴上一题的思路，组合中的数字为 1~9，则从1 开始分层遍历，结束条件即为 和为 n 且 <code>path.size() = k</code>。选择操作：将 i 添入路径，并加入和sum 中，撤销操作反之。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        backtracking(n, k, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, List&lt;Integer&gt; path, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == n &amp;&amp; path.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt;= <span class="number">9</span> ; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backtracking(n, k, path, i + <span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="组合总和medium-1">39，组合总和，medium</h5>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。 解集不能包含重复的组合。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= <code>candidates.length</code> &lt;= 30 1 &lt;= candidates[i] &lt;= 200 candidate 中的每个元素都是独一无二的。 1 &lt;= target &lt;= 500</p>
<p><strong>题解</strong></p>
<p>题意：在无重复元素的数组中可重复选取元素使其和为target，结果集中的数组不重复。</p>
<p>此题的难点在于不产生重复组合。</p>
<p>错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">    backtracking(i,...);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用 <code>index</code>，最后结果会有重复数组，如 [[2,2,3],[2,3,2],[3,2,2],[7]] 。</p>
<p>解决：仍需要 index，以使下一次选择的起点在当前选择的基础上，这样就不会选到本次选择同层左边的数。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210215160501659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>正确：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.length; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">    backtracking(index,...);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>规律</strong>：若只在一个集合中选取组合，需要开始索引 <code>index</code>，如此题和上面两题。</p>
<p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用 <code>index</code>，如 17。</p>
<p>结束条件： <code>sum == target</code> 时填入路径，<code>sum &gt; target</code> 时舍弃。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/3fb042b5dcc8a9f74b94662b441a4914.png" alt="Image" /><figcaption>Image</figcaption>
</figure>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            backtracking(candidates, target, i, path);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="组合总和medium-2">40，组合总和Ⅱ，medium</h5>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>与39题比较：</p>
<p>39题 数组元素无重复，可重复选取，解集无重复</p>
<p>40题 数组元素有重复，不可重复选取，解集无重复</p>
<p>关键在于<strong>「去重」</strong>，对此题构成的树，从上而下的同一树枝可以有重复元素，同一树层之间不可以有重复元素。如数组[1,1,2]（为方便理解已排序），target = 3 时构成的树如图</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/fe56789ddce344a4a4c330191f845290.png" alt="Image" /><figcaption>Image</figcaption>
</figure>
<p>那么怎么区分树层的重复元素和树枝的重复元素呢？</p>
<p>使用boolean 数组 <code>used</code>，初始化为false，当选取元素改为true。</p>
<p>首先对数组进行排序，若相邻元素相等且前一元素已被<strong>同一树层</strong>使用过，跳过。代码表示为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">continue</span>;  </span><br></pre></td></tr></table></figure>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/7bed7dc8842cad57af368e34732c0b05.png" alt="Image" /><figcaption>Image</figcaption>
</figure>
<p>在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：</p>
<ul>
<li>used[i - 1] == true，说明同一<strong>树支</strong>candidates[i - 1]使用过</li>
<li>used[i - 1] == false，说明同一<strong>树层</strong>candidates[i - 1]使用过</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;             <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[candidates.length];</span><br><span class="line">        Arrays.fill(used, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//先排序使相同元素处于相邻位置</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.length ; i++)&#123;</span><br><span class="line">            <span class="comment">//同一树层不可以重复</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">continue</span>;   </span><br><span class="line">            </span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i]; </span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtracking(candidates, target, i + <span class="number">1</span>, path, used);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多个集合求组合">多个集合求组合</h4>
<h5 id="电话号码的字母组合medium">17，电话号码的字母组合，medium</h5>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt="img" style="zoom:80%;" /></p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits &#x3D; &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits &#x3D; &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits &#x3D; &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>与上面题目不同，本题是在多个集合中找组合，不需要开始索引 index。</p>
<p>此题需要注意的地方有很多：</p>
<ul>
<li><p>数字与字母的映射——可以用数组或Map</p></li>
<li><p>结束条件怎么表示？用 <code>idx</code> 表示遍历到digits 的数字索引（即树的深度），当 <code>idx == digits.length()</code> 时，结束。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/b1b653f788c9024244727b6d2f8f6988.png" alt="Image" /><figcaption>Image</figcaption>
</figure></li>
<li><p>怎么选择？对 每个数字<code>digit</code> 对应的字母集<code>letter</code> 进行遍历，选择 <code>letter</code> 中的字母。</p></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String[] str = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;<span class="comment">//0-9对应字母集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backtracking(digits, <span class="keyword">new</span> StringBuffer(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String digits, StringBuffer path, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == digits.length())&#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> digit = digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>;     <span class="comment">// 将index指向的&#x27;数字&#x27;转为int</span></span><br><span class="line">        String letter = str[digit]; 				<span class="comment">// 第 index 个数字对应的字母集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letter.length(); i++)&#123;</span><br><span class="line">            path.append(letter.charAt(i));			<span class="comment">//选择</span></span><br><span class="line">            backtracking(digits, path, idx + <span class="number">1</span>);  <span class="comment">//对下一层处理</span></span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);   <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<ul>
<li><code>StringBuffer</code> 与 String 加入字母的区别：</li>
</ul>
<p>因为<code>StringBuffer</code>传入的都是同一个对象，所以在递归完成之后必须撤回上一次的操作，需要删除上一次添加的字符。而String每次改变之后传入的都是不同的对象。故无需撤销操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; letters.length() ; i ++)&#123;</span><br><span class="line">	backtracking(digits, index + <span class="number">1</span>, s + letters.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>int 与 char 类型的转换</p>
<p>char 不能直接转为int，得到是‘3’的<code>Ascii</code>，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> numChar = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> intNum = (<span class="keyword">int</span>)numChar;</span><br><span class="line">    System.out.println(numChar + <span class="string">&quot;: &quot;</span> + intNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3：51</span><br></pre></td></tr></table></figure>
<p>char 转为 int 的正确方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> numChar = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> intNum = numChar - ‘<span class="number">0</span>’;</span><br><span class="line">    System.out.println(numChar + <span class="string">&quot;: &quot;</span> + intNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3：3</span><br></pre></td></tr></table></figure>
<p>而 int 可以强转为 char</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">char</span> b = (<span class="keyword">char</span>)a; <span class="comment">//b = &#x27;9&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="子集问题">子集问题</h3>
<h5 id="子集medium">78，子集，medium</h5>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= <code>nums.length</code> &lt;= 10 -10 &lt;= <code>nums[i]</code> &lt;= 10 <code>nums</code> 中的所有元素 互不相同</p>
<p><strong>题解</strong></p>
<p>与上面组合问题不同在于<strong>「子集」</strong>是这棵树的所有节点，而不是只有叶子节点。</p>
<p>解中不含重复子集，则<strong>取过的元素不会重复取</strong>，for 循环的开始索引 <code>index</code>，而不是 0。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/c6a0773ead22e31d8482e76a08275fa9.png" alt="Image" /><figcaption>Image</figcaption>
</figure>
<p>那结束条件是什么呢？可以不需要加终止条件，因为<code>index &gt;= nums.size()</code>，本层for循环本来也结束了。</p>
<p><strong>「求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树」</strong>。</p>
<p>根据上面的模板有</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        backtracking(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不需结束条件</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="子集medium-1">90，子集Ⅱ，medium</h5>
<p>给定一个可能包含重复元素的整数数组 <code>nums</code>，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>与 78 题的区别：</p>
<ul>
<li>78题 —— 数组不含重复元素，解不含重复子集。</li>
<li>90题 —— 数组含重复元素，解不含重复子集。</li>
</ul>
<p>此题与 40题 类似，解题思路也一致。</p>
<p>同一树层不能取相同元素（否则解中的子集会重复），而同一树枝可以有相同元素。</p>
<p>使用boolean数组 <code>used</code> ，初始化为false，当选取元素改为true。</p>
<p>首先对数组进行<strong>排序</strong>，若相邻元素相等且前一元素已被同一树层使用过，跳过。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/a388616952b76a18a2463b2dc667537a.png" alt="Image" /><figcaption>Image</figcaption>
</figure>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracking(nums, <span class="number">0</span>, used, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">boolean</span>[] used, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>, used, path);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="递增子序列medium">491，递增子序列，medium</h5>
<p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4, 6, 7, 7]</span><br><span class="line">输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>首先判断 此题的<strong>「去重」</strong>与 40、90题不同，上面的做法是将数组先排序再去重，防止同一层的相同元素重复使用，使解中出现重复子集。但此题要求递增子序列，不可打乱顺序。</p>
<p>采用 <strong><code>HashSet</code></strong> 去重，记录同层使用过的元素。</p>
<p>如果当前元素在 set 中有重复元素，则跳过。</p>
<p>那怎么保证递增呢？</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/da35e130f6e7e7fc10ccbb196613288d.png" alt="Image" /><figcaption>Image</figcaption>
</figure>
<p>如果当前元素 小于 上一个选取的元素，则跳过。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        backtracking(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="comment">//注意此处没有return</span></span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//当同层有相同元素已经在set中，或要加入的nums[i] &lt; 上一个加入的元素时</span></span><br><span class="line">            <span class="keyword">if</span>(!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="number">1</span>) || set.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<p>set 定义在递归函数上面，为了确保本层不选取重复元素。新的一层 set 都会重新定义（清空），所以要知道 set 只负责本层！</p>
<p>因为递增序列中至少两个元素，所以 <code>path.size() &gt; 1</code> 才添加到 res 中，注意<strong>不能写 return</strong>，因为要记录树的所有节点。</p>
<p>添加 return 返回的结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[4,7],[4,6],[7,7],[6,7]]</span><br></pre></td></tr></table></figure>
<h4 id="小总结">小总结</h4>
<p>如果给定数组中包含重复元素 / 组合和子集问题中要求<strong>解中不含重复结果</strong> / 在一个集合中找组合，就需要开始索引 <code>idx</code> 对同层元素去重。（77，39，216，40）</p>
<p>子集问题不需要剪枝，因为要返回所有可能集合。不需要return。</p>
<h3 id="切割问题">切割问题</h3>
<h5 id="分割回文串medium">131，分割回文串，medium</h5>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>不能重复截取，所以仍需要 <code>idx</code>。</p>
<ul>
<li>结束条件：分割线到字符串末尾，将path填入 res 中。</li>
<li>选择：如果当前形成的字符串<code>[idx,i]</code> 不是回文串，跳过。是则进行递归。 <img src="https://img-blog.csdnimg.cn/20210214165327228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        backtracking(<span class="keyword">new</span> ArrayList&lt;String&gt;(), s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;String&gt; path, String s, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历完成</span></span><br><span class="line">        <span class="keyword">if</span>(idx == s.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt; s.length(); i++)&#123;</span><br><span class="line">             <span class="comment">//子串 [idx,i]</span></span><br><span class="line">            String str = s.substring(idx, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果不是回文，跳过</span></span><br><span class="line">            <span class="keyword">if</span>(!isPalindrome(str))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;         </span><br><span class="line">            path.add(str);</span><br><span class="line">            backtracking(path, s, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是不是回文字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(left) != str.charAt(right))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排列问题">排列问题</h3>
<h5 id="全排列medium">46，全排列，medium</h5>
<p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<ul>
<li><p>不需要idx：解中的组合是有序的，例如：在同一树层已经选择了 1，下一次选择还可以选 1，即 [2,1] ≠[1,2]。所以不需要 <code>idx</code>。</p></li>
<li><p>使用boolean 数组 used：全排列，组合中没有重复数字，同一树枝上不能重复选择。用used 数组记录当前元素是否已被选择。</p></li>
</ul>
<figure>
<img src="https://img-blog.csdnimg.cn/20210215160540814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="" /><figcaption><img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv51h5BKbTHZUOibWKplkvJfSAfBfMiaRlo2Dpob0U8tABjUsSaMm20Z1NgdOpcb8D5ZuQjHHItRRewQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:80%;" /></figcaption>
</figure>
<ul>
<li>结束条件：当递归到树的叶子节点结束，path 添加到res 中。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtracking(nums, used, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == n)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//如果一个树枝上的元素已被选择（path已有nums[i]），跳过</span></span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="keyword">true</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtracking(nums, used, path);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>排列问题的不同：</strong></p>
<ul>
<li>因为解中的数组是有序的，每层都是从0开始搜索而不是startIndex</li>
<li>需要used数组记录path里都放了哪些元素了</li>
</ul>
<h5 id="全排列medium-1">47，全排列Ⅱ，medium</h5>
<p>给定一个<strong>可包含重复数字</strong>的序列 nums ，按任意顺序 返回所有<strong>不重复</strong>的全排列。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>与46题的区别</p>
<p>此题有 重复数字，则在同一层不能选取相同数字，否则会出现重复排列。类似 40题的思路来去重。</p>
<p>在同一树枝中，同一个数字不能被重复选，需要通过 <code>used[i]</code> 判断是否已被选取过。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/2021021516071763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//先排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracking(nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//同一层相同元素已被选取，跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; used[i - <span class="number">1</span>] == <span class="keyword">false</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//同一枝同一元素已被选取，跳过</span></span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="keyword">true</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtracking(nums, path, used);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>注意解中<u>有序和无序</u>的区别：在 组合、子集、切割问题 中，<u>一个集合</u>的问题，需要开始索引 idx。排列问题从 0 开始遍历。</p>
<p>注意<u>同一层</u>的重复元素和<u>同一树枝</u>的重复元素的区别：常借用 boolean数组 记录被选择的元素，进行 <strong>去重</strong>。</p>
<p>注意结束条件：树的节点，所有节点 或 叶子节点 或满足题意的节点。</p>
<h3 id="其他">其他</h3>
<h5 id="括号生成medium">22，括号生成，medium</h5>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= n &lt;= 8</p>
<p><strong>题解</strong></p>
<p>选择：将左括号 或 右括号 填入path。</p>
<p>结束条件：当左括号 和 右括号都用完了，或 <code>path.length() == 2 * n</code> 就结束。</p>
<p>遍历过程：</p>
<ul>
<li>剪枝：当选择的右括号数量 &gt; 左括号。</li>
<li>选择：当选择的左括号数量 &lt; n，填入左括号；右括号同。 <img src="https://img-blog.csdnimg.cn/20210215160739252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        backtracking(n, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//l 表示已填入path 的左括号数量，r 表示已填入path 的右括号数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r, StringBuilder path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结束条件</span></span><br><span class="line">        <span class="comment">// if(path.length() == 2 * n)&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(l == n &amp;&amp; r == n)&#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已选择的左括号数量 &lt; 右括号，剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; n)&#123;</span><br><span class="line">            path.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            backtracking(n, l + <span class="number">1</span>, r, path);<span class="comment">//向下递归</span></span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; n)&#123;</span><br><span class="line">            path.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            backtracking(n, l, r + <span class="number">1</span>, path);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图的回溯">图的回溯</h2>
<p>二维图可看作多个子节点多个分支，进行深度遍历搜索得到结果。</p>
<p>容易与【岛屿问题】混淆，岛屿问题用 DFS 来解，图的问题与岛屿问题有什么区别呢？下面由具体题目来体会。</p>
<h5 id="单词搜索medium">79，单词搜索，medium</h5>
<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">board &#x3D;</span><br><span class="line">[</span><br><span class="line">  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],</span><br><span class="line">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class="line">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class="line">]</span><br><span class="line">给定 word &#x3D; &quot;ABCCED&quot;, 返回 true</span><br><span class="line">给定 word &#x3D; &quot;SEE&quot;, 返回 true</span><br><span class="line">给定 word &#x3D; &quot;ABCB&quot;, 返回 false</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>一开始当做岛屿问题来做，为了避免每次DFS的时候被搜过的地方再重复搜索，修改已经搜索过的网格为 '.'。</p>
<p>给定 word = &quot;ABCB&quot;时就会发现，第一次dfs后的结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;E&#39;],</span><br><span class="line"></span><br><span class="line">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class="line"></span><br><span class="line">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>矩阵发生了变化，不能再继续搜索到 ABC 了。这时候就想到用回溯，修改了状态再改回来就好了嘛。</p>
<p>一段官方点的说法：DFS前后必须要保证执行前后程序面对问题的状态是相同的，因此当前问题缩小为子问题时所做的对当前问题状态产生影响的事情应该全部失效，这就是所谓的回溯时还原现场。</p>
<p>直接写回溯可能会超时，还可以进行优化，也就是【剪枝】。</p>
<p>当已经找到路径时，不需再回溯。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> columns = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(backtracking(board, word, i, j, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//结束条件：不在合法区域 或  当前字符与目标不一致</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidArea(board, i, j) || board[i][j] != word.charAt(idx))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//搜索完单词</span></span><br><span class="line">        <span class="keyword">if</span>(idx == word.length() - <span class="number">1</span>)&#123;</span><br><span class="line">            res = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//还没找到全部路径</span></span><br><span class="line">        <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="comment">//向四个方向搜索</span></span><br><span class="line">            <span class="keyword">boolean</span> r1 = backtracking(board, word, i + <span class="number">1</span>, j, idx + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">boolean</span> r2 = backtracking(board, word, i , j + <span class="number">1</span>, idx + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">boolean</span> r3 = backtracking(board, word, i - <span class="number">1</span>, j, idx + <span class="number">1</span>); </span><br><span class="line">            <span class="keyword">boolean</span> r4 = backtracking(board, word, i, j - <span class="number">1</span>, idx + <span class="number">1</span>); </span><br><span class="line">            board[i][j] = temp;</span><br><span class="line">            <span class="keyword">return</span> r1 || r2 || r3 || r4;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidArea</span><span class="params">(<span class="keyword">char</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sr &lt; <span class="number">0</span> || sr &gt;= image.length || sc &lt; <span class="number">0</span> || sc &gt;= image[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—岛屿问题</title>
    <url>/2021/02/16/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>思路</strong></p>
<p>一个二维矩阵从某个点开始向四周扩展，直到无法再扩展为止。</p>
<p>矩阵，可以抽象为一幅「图」，这就是⼀个图的遍历问题，也就类似⼀个 N 叉树遍历的问题。几行代码就能解决，直接上框架吧：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (x, y) 为坐标位置 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">fill(x - <span class="number">1</span>, y); <span class="comment">// 上 </span></span><br><span class="line"></span><br><span class="line">fill(x + <span class="number">1</span>, y); <span class="comment">// 下 </span></span><br><span class="line"></span><br><span class="line">fill(x, y - <span class="number">1</span>); <span class="comment">// 左 </span></span><br><span class="line"></span><br><span class="line">fill(x, y + <span class="number">1</span>); <span class="comment">// 右 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个框架可以解决所有在二维矩阵中遍历的问题，说得高端点，这就叫深度优先搜索（Depth First Search，简称 <strong>DFS</strong>），说得简单点，这就叫四叉树遍历框架。坐标 (x, y) 就是 root，四个方向就是 root 的四个子节点。</p>
<p><strong>DFS模板</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line"><span class="comment">//dfs出口，不满足条件就退出</span></span><br><span class="line">	<span class="keyword">if</span>(结束条件)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;    </span><br><span class="line">    操作</span><br><span class="line"><span class="comment">//递归，接着进一步DFS</span></span><br><span class="line">    dfs(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="图像渲染easy">733，图像渲染，easy</h5>
<p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p>
<p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p>
<p>从初始坐标开始，记录初始坐标的<u>上下左右</u>四个方向上像素值<u>与初始坐标相同</u>的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。<u>将所有有记录的像素点的颜色值改为新的颜色值</u>。</p>
<p>最后返回经过上色渲染后的图像。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">输出: [[2,2,2],[2,2,0],[2,0,1]]</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://img-blog.csdnimg.cn/20210216174746701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解析: </span><br><span class="line">在图像的正中间，(坐标(sr,sc)&#x3D;(1,1)),</span><br><span class="line">在路径上所有符合条件的像素点的颜色都被更改成2。</span><br><span class="line">注意，右下角的像素没有更改为2，</span><br><span class="line">因为它不是在上下左右四个方向上与初始点相连的像素点。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>从起始点开始，搜索四个方向</p>
<ul>
<li><p>如果这个方向越界且不需要渲染，结束搜索。</p></li>
<li><p>否则，继续从这个方向搜索它的上下左右。</p></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;      </span><br><span class="line">        <span class="comment">//如果新颜色与原来相同，不需更改</span></span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] == newColor) <span class="keyword">return</span> image;</span><br><span class="line">        </span><br><span class="line">        dfs(image, sr, sc, newColor, image[sr][sc]);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor, <span class="keyword">int</span> oldColor)</span></span>&#123;</span><br><span class="line">        <span class="comment">//出口：不在合法范围内 或 此位置与初始颜色不同</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidArea(image, sr, sc) || image[sr][sc] != oldColor) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//操作</span></span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        dfs(image, sr - <span class="number">1</span>, sc, newColor, oldColor);</span><br><span class="line">        dfs(image, sr + <span class="number">1</span>, sc, newColor, oldColor);</span><br><span class="line">        dfs(image, sr, sc - <span class="number">1</span>, newColor, oldColor);</span><br><span class="line">        dfs(image, sr, sc + <span class="number">1</span>, newColor, oldColor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合法：不处于边界之外</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidArea</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sr &lt; <span class="number">0</span> || sr &gt;= image.length || sc &lt; <span class="number">0</span> || sc &gt;= image[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="岛屿数量medium">200，岛屿数量，medium</h5>
<p>给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>本题的目标是得到“岛屿数量”，上下左右相连的 <code>1</code> 都被认为是连续岛屿。</p>
<p>总体思路：遍历地图，找到一个陆地（' 1 '），采用 dfs 向 上下左右 四个方向搜索，同时“岛屿数量” + 1。</p>
<p>dfs 流程：</p>
<ul>
<li><p>结束条件：不在合法范围内 或 不是陆地</p></li>
<li><p>操作：避免重复遍历，网格的dfs 会重复向四个方向找，可能重复遍历节点。</p>
<pre><code>         将已遍历过的陆地标记为 &#39;2&#39;</code></pre></li>
<li><p>递归：搜索上下左右的节点</p></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从 一个陆地 ‘1’向四个方向遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isValidArea(grid, r, c) || grid[r][c] != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//标记已遍历过的陆地</span></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidArea</span><span class="params">(<span class="keyword">char</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sr &lt; <span class="number">0</span> || sr &gt;= image.length || sc &lt; <span class="number">0</span> || sc &gt;= image[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="岛屿的最大面积medium">695，岛屿的最大面积，medium</h5>
<p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p>
<p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>找到给定的二维数组中<strong>最大的岛屿面积</strong>。(如果没有岛屿，则返回面积为 0 。)</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>和上面思路一致，根据题目对结果进行修改。</p>
<p>题目目标是得到最大岛屿面积，在 dfs 过程中求出每个岛屿的面积，在主函数中得到最大的一个。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> a = dfs(grid, i, j);</span><br><span class="line">                    res = Math.max(a, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r ,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isValidArea(grid, r, c) || grid[r][c] != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//标记已遍历过的陆地</span></span><br><span class="line">        grid[r][c] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(grid, r - <span class="number">1</span>, c) + dfs(grid, r + <span class="number">1</span>, c) + dfs(grid, r, c - <span class="number">1</span>) + dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidArea</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sr &lt; <span class="number">0</span> || sr &gt;= image.length || sc &lt; <span class="number">0</span> || sc &gt;= image[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="岛屿的周长easy">463，岛屿的周长，easy</h5>
<p>给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。</p>
<p>网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<p>示例 1：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/6fd1a8c57dc7f3800628577ad6fc650f.png" alt="img" /><figcaption>img</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]</span><br><span class="line">输出：16</span><br><span class="line">解释：它的周长是上面图片中的 16 个黄色的边</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>岛屿的周长是计算岛屿全部的「边缘」，而这些边缘就是我们在 DFS 遍历中，dfs 函数返回的位置。</p>
<p>可以将岛屿的周长中的边分为两类，如下图所示。黄色的边是与网格边界相邻的周长，而蓝色的边是与海洋格子相邻的周长。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/e84efa198ef108951ef340cc712e5aa0.png" alt="将岛屿周长中的边分为两类" /><figcaption>将岛屿周长中的边分为两类</figcaption>
</figure>
<p>dfs 函数直接返回有这几种情况：</p>
<ul>
<li><code>!inArea(grid, r, c)</code>，即坐标 (r, c) 超出了网格的范围，也就是「先污染后治理」的情况</li>
<li><code>grid[r][c] != 1</code>，即当前格子不是岛屿格子，这又分为两种情况：
<ul>
<li><code>grid[r][c] == 0</code>，当前格子是海洋格子</li>
<li><code>grid[r][c] == 2</code>，当前格子是已遍历的陆地格子</li>
</ul></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                   <span class="keyword">return</span> dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从 一个陆地 ‘1’向四个方向遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">//蓝色边界</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidArea(grid, r, c)) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//黄色边界</span></span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前格子是已遍历的陆地格子,和周长没关系</span></span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//标记已遍历过的陆地</span></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(grid, r - <span class="number">1</span>, c) + dfs(grid, r + <span class="number">1</span>, c) + dfs(grid, r, c - <span class="number">1</span>) + dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidArea</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sr &lt; <span class="number">0</span> || sr &gt;= image.length || sc &lt; <span class="number">0</span> || sc &gt;= image[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>更简单的写法：遍历每一个空格，遇到岛屿，计算其上下左右的情况，遇到水域或者出界的情况，就可以计算边了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//4个方向</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> r = i + directions[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> c = j + directions[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= grid.length || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].length || grid[r][c] == <span class="number">0</span>) res++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—双指针解数组排序</title>
    <url>/2021/02/17/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h5 id="前言">前言</h5>
<p>双指针分为快慢指针（向一个方向遍历）和左右指针（从两个方向相对遍历）， 在进行数组排序时常用到第一种。</p>
<p><strong>指针 j 用于探路，找到目标元素</strong>与指针 i 所指元素交换，并将 i 向前一步，继续。</p>
<h5 id="模板">模板</h5>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">    	<span class="comment">//j 指针探路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(找到目标元素)&#123;</span><br><span class="line">                <span class="comment">//交换</span></span><br><span class="line">                swap(A, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="按奇偶排序数组easy">905，按奇偶排序数组，easy</h5>
<p>给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。</p>
<p>你可以返回满足此条件的任何数组作为答案。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,1,2,4]</span><br><span class="line">输出：[2,4,3,1]</span><br><span class="line">（输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。）</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>此题目标是用 指针j 找到偶数元素，将偶数元素往前提。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">//找到偶数元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(A, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="移动-0easy">283，移动 0，easy</h5>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>此题目标是用 指针j 找到非 0 元素，将非 0 元素往前提。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            <span class="comment">//找到非 0 元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] != <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="颜色分类medium">75，颜色分类，medium</h5>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,0,1]</span><br><span class="line">输出：[0,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>与前两题不同在 需要两次交换，先用 指针j 找到 0，将 0 往前提。</p>
<p>再将 j 定于此位置，继续找 1，将 1 往前提。</p>
<p>过程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210217113417103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" /></p>
<p><a href="https://pic.leetcode-cn.com/4ff01311844f58b83124a449e24857e9d02fd6c04067e9551fda6bccbe59b87e-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%94%B9%E5%8F%98.gif">动画演示</a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//第一步：将 0 往前提</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二步：将 1 往前提</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == <span class="number">1</span>)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>易错！！String类与常量池</title>
    <url>/2021/02/18/%E6%98%93%E9%94%99%EF%BC%81%EF%BC%81String%E7%B1%BB%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
    <content><![CDATA[<p>一、String对象有两种创建方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line">String str1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>两种方法是有差别的。</p>
<a id="more"></a>
<ul>
<li>第一种方式是在<strong>常量池中取对象</strong>：先检查字符串常量池中有没有&quot;a&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;a&quot;；</li>
<li>第二种方式是直接在<strong>堆内存空间创建</strong>一个新的对象。</li>
</ul>
<p>再如： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str3 = <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure> str1 与 str3 都指向常量池中的 “a”，而 str2 指向堆中新创建的 “a”。 <img src="https://img-blog.csdnimg.cn/20210218215326378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 记住一点：只要<strong>使用 new 方法，便需要创建新的对象。</strong></p>
<p>二、String 类型的常量池的使用： - 直接使用双引号声明出来的 String 对象会直接存储在常量池中。 - 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中<strong>已经包含一个等于此 String 对象内容的字符串</strong>，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是<strong>在常量池中记录此字符串的引用</strong>，<strong>并返回</strong>该引用。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;计算机&quot;</span>);<span class="comment">//堆</span></span><br><span class="line">String s2 = s1.intern();<span class="comment">//常量池</span></span><br><span class="line">String s3 = <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure> 三、一个小问题</p>
<p><code>String str = new String(&quot;abc&quot;);</code> 这句话创建了几个字符串对象？ 答：1 或 2 个。如果常量池中已有 “abc”，只在堆空间创建一个 “abc”；如果常量池中没有 “abc”，将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);<span class="comment">// 堆内存的地址值</span></span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">// 输出 true，内容相同</span></span><br></pre></td></tr></table></figure> 四、字符串拼接</p>
<p>常量池中的对象可以直接拼接成一个新的字符串。两个字符串拼接的结果在堆中。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str4 = str1 + str2; <span class="comment">//在堆上创建的新的对象      </span></span><br><span class="line">String str5 = <span class="string">&quot;string&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure> <img src="https://img-blog.csdnimg.cn/20210218221413161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>五、扩展：Integer 类 与 常量池</p>
<p>Integer 类默认创建数值[-128，127] 的相应类型的缓存数据。 1. <code>Integer i1=40；</code> Java 在编译的时候会直接将代码封装成 <code>Integer i1=Integer.valueOf(40);</code>，从而使用常量池中的对象。 2. <code>Integer i1 = new Integer(40);</code> 这种情况下会创建新的对象。</p>
<p>一个例子: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));     </span><br></pre></td></tr></table></figure> 结果： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i1&#x3D;i2   true</span><br><span class="line">i1&#x3D;i2+i3   true</span><br><span class="line">i1&#x3D;i4   false</span><br><span class="line">i4&#x3D;i5   false</span><br><span class="line">i4&#x3D;i5+i6   true</span><br><span class="line">40&#x3D;i5+i6   true</span><br></pre></td></tr></table></figure> 解释：</p>
<p>语句 i4 == i5 + i6，因为 + 这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行<strong>自动拆箱</strong>操作，进行数值相加，即 i4 == 40。然后 <strong>Integer 对象无法与数值进行直接比较</strong>，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。</p>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—LRU缓存机制</title>
    <url>/2021/02/27/LeetCode%E5%88%B7%E9%A2%98%E2%80%94LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>146，LRU缓存机制，medium</strong></p>
<p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<p>• <code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</p>
<p>• <code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 -1 。</p>
<p>• <code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<a id="more"></a>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1&#125;</span><br><span class="line">lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 1</span><br><span class="line">lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    &#x2F;&#x2F; 返回 3</span><br><span class="line">lRUCache.get(4);    &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>LRU 缓存淘汰算法是一种常用策略，认为最近使用的数据是「有用的」，很久没用过的数据是「没用的」，当内存满了就优先删除没用的数据。</p>
<p>此题需要设计数据结构，首先接收一个 <code>capacity</code> 参数作为缓存的最大容量，然后实现两个 API，一个是 <code>put(key, val)</code> 方法存入键值对，另一个是 <code>get(key)</code> 方法获取 key 对应的 val，如果 key 不存在则返回 -1。</p>
<p>此数据结构的必要条件： 1. cache 中的元素必须有时序，区分最近使用和久未使用的数据。 2. API 需要快速查找，快速插入，快速删除。</p>
<p>哈希表能实现快速查找，但无固定顺序。链表有顺序，能实现快速插入和删除，但查找慢。结合一下就形成新的数据结构：哈希链表 LinkedHashMap 。</p>
<ul>
<li><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p></li>
<li><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p></li>
</ul>
<p>这样一来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 <code>get</code> 或者 <code>put</code> 操作。具体的方法如下：</p>
<ul>
<li>对于 <code>get</code> 操作，首先判断 key 是否存在：
<ul>
<li>如果 key 不存在，则返回−1；</li>
<li>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</li>
</ul></li>
<li>对于 <code>put</code> 操作，首先判断 key 是否存在：
<ul>
<li>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</li>
<li>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</li>
</ul></li>
</ul>
<p>为什么要用双向链表不用单向链表呢？下面通过代码思考。</p>
<p>双链表的节点类： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后依靠 Node 类型构建一个双向链表，实现几个LRU算法需要的API： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    <span class="comment">//头尾虚拟节点</span></span><br><span class="line">    Node head;</span><br><span class="line">    Node tail;</span><br><span class="line">    <span class="comment">//元素数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化双向链表</span></span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.next = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加节点到头部</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将节点移至头部</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除链表中最后一个节点，并返回该节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node res = tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 到这里就能回答刚才「为什么必须要用双向链表」的问题了，因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。</p>
<p>有了双向链表，只需要在LRU算法中把它和哈希表结合起来即可。代码框架： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCahche</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 下面就能实现LRU算法的 <code>get</code> 和 <code>put</code> 方法。在维护链表的同时也要注意 <code>map</code> 中元素的增加、删除。</p>
<p><code>get</code> 操作较简单：若不存在 key，返回 -1；若存在，将链表中对应节点提至链表头部，再返回对应的value 值。</p>
<p><code>put</code> 操作较复杂，通过一个流程图来梳理： <img src="https://img-blog.csdnimg.cn/20210227112311467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>到此为止整个算法流程就梳理完了，还有一个问题要思考： 既然哈希表中已经存了 key，为什么链表中还要存 key 和 val 呢，只存 val 不就行了？</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">        <span class="comment">//头尾虚拟节点</span></span><br><span class="line">        Node head;</span><br><span class="line">        Node tail;</span><br><span class="line">        <span class="comment">//元素数量</span></span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//初始化双向链表</span></span><br><span class="line">            head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            head.next = tail;</span><br><span class="line">            tail.next = head;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加节点到头部</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            node.prev = head;</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            head.next.prev = node;</span><br><span class="line">            head.next = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            node.prev.next = node.next;</span><br><span class="line">            node.next.prev = node.prev;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将节点移至头部</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            removeNode(node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除链表中最后一个节点，并返回该节点</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Node res = tail.prev;</span><br><span class="line">            removeNode(res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        <span class="comment">//提至头部</span></span><br><span class="line">        cache.moveToHead(n);</span><br><span class="line">        <span class="keyword">return</span> n.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node n = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="comment">//若key已存在，修改链表中的值并提至头部，修改map中的键值对</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            cache.removeNode(map.get(key));</span><br><span class="line">            cache.moveToHead(n);</span><br><span class="line">            map.put(key, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若key不存在，需要插入n</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//若容量已满，删除尾部最后一个 和map中对应的键值对</span></span><br><span class="line">            <span class="keyword">if</span>(cache.size() == capacity)&#123;</span><br><span class="line">                Node node = cache.removeTail();</span><br><span class="line">                map.remove(node.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向链表头部和map中添加新元素</span></span><br><span class="line">            cache.addToHead(n);</span><br><span class="line">            map.put(key, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 <code>put</code> 方法，可以回答上面的问题。容量满了要删除最后一个久未使用的元素，同时还要将 <code>map</code> 中对应的键删除。如果链表中只存储 <code>value</code>，那么就无法得知 <code>key</code>，就无法删除 <code>map</code> 中对应的键值对。</p>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>类变量、成员变量、局部变量存放位置比较</title>
    <url>/2021/03/01/%E7%B1%BB%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>三种变量易混淆，在学JVM的过程中分不清它们的存放位置，特此梳理比较。</p>
<p>一、实例变量</p>
<p>也叫成员变量、全局变量。</p>
<a id="more"></a>
<ul>
<li>定义在类中、方法外，有默认初始值。</li>
<li>通过对象的引用来访问实例变量。</li>
<li>随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。</li>
</ul>
<p>二、类变量</p>
<p>也叫静态变量。</p>
<ul>
<li>定义在类中、方法外，有关键字 static 修饰，有默认初始值。</li>
<li>可以通过对象调用，也可以通过类名调用。</li>
<li>生命周期与类共存亡。</li>
<li>对象的引用存放在<strong>方法区</strong>，如果用关键字 new 为引用类型的静态变量分配对象，该对象在堆中的地址也会存放在方法区。！但是<strong>对象本身仍在堆内存中</strong>。</li>
</ul>
<p>三、局部变量</p>
<ul>
<li>定义在方法中，或者方法的形参，没有初始化值。</li>
<li>生命周期与方法共存亡。</li>
<li>存放在栈中。局部的对象的引用所指对象在堆中的<strong>地址</strong>在存储在了栈中。</li>
</ul>
<p>举例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObjTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();<span class="comment">//静态变量、类变量</span></span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();<span class="comment">//实例变量、成员变量</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();<span class="comment">//局部变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>静态变量staticObj 随着Test的类型信息存放在<strong>方法区</strong></li>
<li>成员变量instance0bj 随着Test的对象实例存放在<strong>Java堆</strong></li>
<li>局部变量localobj则是存放在foo() 方法栈帧的局部变量表中。</li>
<li>三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例 即new() 必然会在Java堆中分配。</li>
</ul>
<p>再举个例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">PersonDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="comment">//局部变量p和形参args都在main方法的栈帧中</span></span><br><span class="line">        <span class="comment">//new Person()对象在堆中分配空间</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">//sum在栈中，new int[10]在堆中分配空间</span></span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;   <span class="comment">//实例变量name和age在堆(Heap)中分配空间</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//类变量(引用类型)name1和&quot;cn&quot;都在方法区(Method Area)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name1 = <span class="string">&quot;cn&quot;</span>;</span><br><span class="line">    <span class="comment">//类变量(引用类型)name2在方法区(Method Area)</span></span><br><span class="line">    <span class="comment">//new String(&quot;cn&quot;)对象在堆(Heap)中分配空间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name2 = <span class="keyword">new</span> String(<span class="string">&quot;cn&quot;</span>);</span><br><span class="line">    <span class="comment">//num在堆中，new int[10]也在堆中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    Person(String name,<span class="keyword">int</span> age)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//this及形参name、age在构造方法被调用时</span></span><br><span class="line">        <span class="comment">//会在构造方法的栈帧中开辟空间</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//setName()方法在方法区中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//speak()方法在方法区中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;...&quot;</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//showCountry()方法在方法区中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">showCountry</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;country=&quot;</span>+country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面代码中更容易看出区别，这部分还是要多想多记！</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>狂神HTML笔记</title>
    <url>/2021/03/02/%E7%8B%82%E7%A5%9EHTML%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="初识html">1.初识HTML：</h1>
<figure>
<img src="https://img-blog.csdnimg.cn/20210302152918212.png" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<a id="more"></a>
<h1 id="元素标签属性内容">2.元素=标签+属性+内容</h1>
<h3 id="网页基本标签">（1）网页基本标签</h3>
<ol type="1">
<li>标题标签 <code>&lt;h1&gt;一级标签&lt;/h1&gt;</code> <code>&lt;h2&gt;二级标签&lt;/h2&gt;</code></li>
<li>段落标签 <code>&lt;p&gt;跑得快 跑得快&lt;/p&gt;</code></li>
<li>水平线标签 <code>&lt;hr/&gt;</code></li>
<li>换行标签 <code>跑得快 跑得快&lt;br/&gt;</code></li>
<li>粗体、斜体 <code>&lt;strong&gt;i love u&lt;/strong&gt;</code> <code>&lt;em&gt;i love u&lt;/em&gt;</code></li>
<li>特殊符号 空格：  <code>空&amp;nbsp;&amp;nbsp; 格</code> 大于：&gt; <code>4 &amp;gt;3</code> 小于：&lt; <code>2 &amp;lt;4</code></li>
</ol>
<h3 id="图像标签">（2）图像标签</h3>
<p><img src="https://img-blog.csdnimg.cn/20210302153014705.png" alt="在这里插入图片描述" /> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--img学习</span></span><br><span class="line"><span class="comment">    src:图片地址，推荐使用相对路径</span></span><br><span class="line"><span class="comment">    ../ ——上一级目录</span></span><br><span class="line"><span class="comment">    alt:图片名字（必填）</span></span><br><span class="line"><span class="comment">    title：鼠标悬停时显示的信息</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../resource/image/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;狂神头像&quot;</span> <span class="attr">title</span>=<span class="string">&quot;悬停&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure> ### （3）超链接标签 <img src="https://img-blog.csdnimg.cn/20210302153042809.png" alt="在这里插入图片描述" /></p>
<p>href：必填，表示要跳转到哪个页面 target：表示窗口在哪里打开</p>
<h4 id="a页面间链接">a、页面间链接</h4>
<p><img src="https://img-blog.csdnimg.cn/20210302153104395.png" alt="在这里插入图片描述" /> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;1.我的第一个网页.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>点我跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure> 图片链接： <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;1.我的第一个网页.html&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../resource/image/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;狂神头像&quot;</span> <span class="attr">title</span>=<span class="string">&quot;悬停&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure> #### b、锚链接 1. 需要一个锚标记 2. 跳转到标记 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--锚标记：top--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span> = <span class="string">&quot;top&quot;</span>&gt;</span>顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用&quot;#&quot;标记 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure> #### c、功能性链接 1. 邮件链接：mailto 3. QQ链接：搜索QQ推广，在推广工具中获取 <img src="https://img-blog.csdnimg.cn/20210302153249536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h3 id="补充块元素和行内元素">【补充】块元素和行内元素</h3>
<figure>
<img src="https://img-blog.csdnimg.cn/20210302153428454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<h3 id="列表标签">（4）列表标签</h3>
<p><img src="https://img-blog.csdnimg.cn/20210302153452335.png" /></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--有序列表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>C/C++<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--无序列表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>C/C++<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自定义列表</span></span><br><span class="line"><span class="comment">    dl: 标签</span></span><br><span class="line"><span class="comment">    dt: 列表名称</span></span><br><span class="line"><span class="comment">    dd: 列表内容</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>学科<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>C/C++<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="表格标签">（5）表格标签</h3>
<p><img src="https://img-blog.csdnimg.cn/2021030215354221.png" alt="在这里插入图片描述" /> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--表格 table</span></span><br><span class="line"><span class="comment">    行 tr</span></span><br><span class="line"><span class="comment">    列 td--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第一行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>学生成绩<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第二、三行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>狂神<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第四、五行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>Rui<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure> 效果： <img src="https://img-blog.csdnimg.cn/2021030215361459.png" alt="在这里插入图片描述" /></p>
<h3 id="媒体元素">（6）媒体元素</h3>
<figure>
<img src="https://img-blog.csdnimg.cn/20210302153633166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<h1 id="页面结构">3.页面结构</h1>
<p><img src="https://img-blog.csdnimg.cn/20210302153706454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> # 4.内联框架： <img src="https://img-blog.csdnimg.cn/20210302153731285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> # 5.初识表单post和get提交： <img src="https://img-blog.csdnimg.cn/20210302153813566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;1.我的第一个网页.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--文本输入框--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--密码框--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure> # 6.表单元素格式： <img src="https://img-blog.csdnimg.cn/20210302153857716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ### （1）文本框和单选框 <img src="https://img-blog.csdnimg.cn/20210302153922502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="文本框：" /> ### （2）按钮和多选框： <img src="https://img-blog.csdnimg.cn/20210302153941380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ### （3）下拉框、文本域和文件域： <img src="https://img-blog.csdnimg.cn/20210302154007639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210302154020877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ### （4）简单验证和滑块： <img src="https://img-blog.csdnimg.cn/20210302154045550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ## 表单的应用 <img src="https://img-blog.csdnimg.cn/20210302154121694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="只读：无法修改 添加readonly" /> ## 表单初级验证 <img src="https://img-blog.csdnimg.cn/20210302154149223.png" alt="输入框默认显示内容" /></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈的三个问题</title>
    <url>/2021/03/03/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>一上午做了三道单调栈的问题，算是小摸了一下单调栈的套路，虽然很难想，掌握了规律还是很好做出来的！</p>
<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84，柱状图中最大的矩形，hard</a></p>
<p><a href="https://leetcode-cn.com/problems/daily-temperatures/">739，每日温度，medium</a></p>
<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42，接雨水，hard</a></p>
<a id="more"></a>
<h5 id="柱状图中最大的矩形hard">84，柱状图中最大的矩形，hard</h5>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" /></p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" /></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>先考虑暴力解法，也就是对数组的每个高度来说，向左找、向右找到第一个比它小的高度，即可确定矩阵的宽，很容易就得到最大面积。</p>
<p>但这样时间复杂度比较高，每个元素都要循环两遍，为<em>O</em>(N<sup>2</sup>)，考虑怎么优化呢？</p>
<p>以空间换时间，对每个元素向后找比它小的，才能计算面积，符合【栈】先进后出的规则。用一个单调栈来记录<strong>下标</strong>（高度可以用下标来表示），这样就能很清楚的确定形成矩形的宽了。</p>
<p>如果当前的高度比它之前的高度（栈顶元素的高度）严格小于的时候，就可以直接确定以栈顶元素为高的矩形的面积，向左回退的时候，其实就可以当中间这些柱形不存在一样。</p>
<p>还有一个细节，为了确定数组两端元素的高为矩形的面积，在数组两端添加比 1 小的元素，这样就始终保证栈非空。</p>
<p>下面图帮助理解</p>
<p><img src="https://pic.leetcode-cn.com/7e876ae756613053b3432cebc9274e9dbdaafd2e6b8492d37fc34ee98f7655ea-%E5%9B%BE%E7%89%87.png" /></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line"><span class="comment">// //暴力解</span></span><br><span class="line"><span class="comment">//         int res = 0;</span></span><br><span class="line"><span class="comment">//         for(int i = 0; i &lt; heights.length; i++)&#123;</span></span><br><span class="line"><span class="comment">//             int left = i;</span></span><br><span class="line"><span class="comment">//             int right = i;</span></span><br><span class="line"><span class="comment">//             //向左找可以构成矩形的</span></span><br><span class="line"><span class="comment">//             while(left &gt; 0 &amp;&amp; heights[left - 1] &gt;= heights[i])&#123;</span></span><br><span class="line"><span class="comment">//                 left--;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             //向右找可以构成矩形的</span></span><br><span class="line"><span class="comment">//             while(right &lt; heights.length - 1 &amp;&amp; heights[right + 1] &gt;= heights[i])&#123;</span></span><br><span class="line"><span class="comment">//                 right++;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             int width = right - left + 1;</span></span><br><span class="line"><span class="comment">//             res = Math.max(res, width * heights[i]);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//单调栈：将数组左右两侧各加 &lt; 1 的柱子，这样所有元素的左边都比当前柱子小，只需找到右边第一个比当前柱子小的，即可确定以当前高度为高的矩形面积（宽即为左右两边第一个比当前柱子小的两柱子之间距离，左边即为栈顶元素）</span></span><br><span class="line">        <span class="comment">//重构数组</span></span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">2</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        nums[len + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            nums[i] = heights[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单调栈中确定以数组每个元素的高度确定矩形的面积，并维护最大值res</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//当前高度比栈顶高度小即可确定栈顶元素的高度为高的矩形面积</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i] &lt; nums[stack.peekLast()])&#123;</span><br><span class="line">                <span class="comment">//栈顶元素出栈</span></span><br><span class="line">                <span class="keyword">int</span> h = nums[stack.removeLast()];</span><br><span class="line">                <span class="comment">//栈顶元素的高度为高的矩形面积</span></span><br><span class="line">                res = Math.max(res, h * (i - stack.peekLast() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="每日温度medium">739，每日温度，medium</h5>
<p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<p><strong>题解</strong></p>
<p>首先想到暴力解法，两层for循环，搜索每个元素后面比它大的值，就得到每个元素需要等待的天数。</p>
<p>此题目的是<u>向右</u>找到比当前索引对应的高度 高 的 第一个柱体，所以需要维护一个递减栈。</p>
<p>遍历数组元素，当前索引对应的高度比栈顶元素对应高度 大，即弹出栈顶并将索引差记录到结果数组。</p>
<figure>
<img src="https://pic.leetcode-cn.com/1614494588-CkmPkk-%E6%A0%88739%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%E6%AD%A3%E5%BA%8F%E5%8A%A8%E7%94%BB1.gif" alt="动画演示" /><figcaption>动画演示</figcaption>
</figure>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> idx = stack.pop();</span><br><span class="line">                res[idx] = i - idx;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="接雨水hard">42，接雨水，hard</h5>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" /></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>依然是遍历到右面不比自己低的柱子时，会形成坑接住雨水。所以采用【单调栈】。</p>
<p>维护一个递减的单调栈，仍记录下标，栈中每个元素表示接雨水的【左侧柱体】。</p>
<p>遍历数组元素，当前元素对应高度大于栈顶元素对应高度，则能形成雨水，栈顶元素弹出，并记录其索引，去除栈中元素对应高度重复的元素（为了不重复计算）。计算雨水时，仍然采用高度*宽度，<code>宽度 = 当前遍历索引 - 栈顶索引 - 1</code>；<code>高度 = 两侧柱体取最矮的 - 上面记录的弹出栈的索引对应的高度</code>。因为以记录的柱体作为左侧柱体的雨水已经计算过了！</p>
<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/dan-diao-zhan-jie-jue-jie-yu-shui-wen-ti-by-sweeti/">可以跟着甜姨的图解理解一下</a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;        </span><br><span class="line">		<span class="keyword">if</span>(height.length == <span class="number">0</span> || height == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peekLast()])&#123;</span><br><span class="line">                <span class="keyword">int</span> popIdx = stack.removeLast();</span><br><span class="line">                <span class="comment">//去除高度重复的栈顶</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[stack.peekLast()] == height[popIdx])&#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//计算雨水面积</span></span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = stack.peekLast();</span><br><span class="line">                    <span class="comment">//雨水面积为 宽*高，宽是当前元素与栈顶元素的距离，高取雨水两边的较矮高度-已经计算过的高度</span></span><br><span class="line">                    res += (i - idx - <span class="number">1</span>) * (Math.min(height[i], height[idx]) - height[popIdx]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>这三道题都可以用单调栈来解，各自也有不同的解法。总的来说，【单调栈】以空间换时间，使暴力解法的左右两次循环变为朝一个方向循环一次。在向左。</p>
<p>还有一个细节，就是记录下标，而不是将元素值入栈，这是为了方便计算间隔来计算面积，写代码时要提醒自己。</p>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot员工管理项目</title>
    <url>/2021/03/07/SpringBoot%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="环境准备">环境准备</h2>
<ul>
<li>jdk1.8</li>
<li>maven 3.3.9</li>
<li>SpringBoot 2.1.8</li>
</ul>
<h2 id="导入静态资源">导入静态资源</h2>
<p><a href="https://pan.baidu.com/s/13P_1dRRWxqzdQFG1Y1I3UQ">百度网盘链接</a></p>
<a id="more"></a>
<p>提取码：wrbg</p>
<p>将asserts目录下的css、img、js等静态资源放置static目录下 <img src="https://img-blog.csdnimg.cn/20210307154859589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 将html静态资源放置templates目录下 <img src="https://img-blog.csdnimg.cn/20210307154922944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h2 id="创建项目">创建项目</h2>
<ul>
<li>File-New-Project-Spring Initializr快速创建Spring Boot项目，修改Group名，注意Java Version版本的选择为8。</li>
<li>引入依赖，选择Web-Spring Web，Template Engines-Thymeleaf，Lombok，如图所示。<img src="https://img-blog.csdnimg.cn/20210307153538485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li>
</ul>
<h2 id="模拟数据库">模拟数据库</h2>
<h3 id="创建数据库实体类">1. 创建数据库实体类</h3>
<p>新建 pojo 包，用来存放实体类</p>
<p>在 pojo 包下创建一个部门表Department和一个员工表Employee <img src="https://img-blog.csdnimg.cn/20210307155123929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h5 id="部门表">部门表：</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String departmentName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="员工表">员工表：</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Integer gender;<span class="comment">//0:女 1：男</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(Integer id, String lastName, String email, Integer gender, Department department)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.department = department;</span><br><span class="line">        <span class="comment">//默认的创建日期</span></span><br><span class="line">        <span class="keyword">this</span>.birth = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于导入了lombok依赖，使用@Data注解即可get属性，<span class="citation" data-cites="AllArgsConstructor有参构造">@AllArgsConstructor有参构造</span>，<span class="citation" data-cites="NoArgsConstructor无参构造">@NoArgsConstructor无参构造</span>。</p>
</blockquote>
<h3 id="编写dao层">2. 编写Dao层</h3>
<p>模拟数据库，完成对员工的增删改查任务。</p>
<h5 id="部门dao">部门Dao</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟数据库中的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Department&gt; department = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        department = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//创建一个部门表</span></span><br><span class="line"></span><br><span class="line">        department.put(<span class="number">1</span>, <span class="keyword">new</span> Department(<span class="number">1</span>, <span class="string">&quot;市场部&quot;</span>));</span><br><span class="line">        department.put(<span class="number">2</span>, <span class="keyword">new</span> Department(<span class="number">2</span>, <span class="string">&quot;教学部&quot;</span>));</span><br><span class="line">        department.put(<span class="number">3</span>, <span class="keyword">new</span> Department(<span class="number">4</span>, <span class="string">&quot;运营部&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得所有部门信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Department&gt; <span class="title">getDepartment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> department.values();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过id获得部门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartmentById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> department.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="员工dao">员工Dao</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟数据库中的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DepartmentDao departmentDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        employees = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//创建一个部门表</span></span><br><span class="line">		employees.put(<span class="number">101</span>, <span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">&quot;张晓明&quot;</span>,<span class="string">&quot;vdx342@qq.com&quot;</span>, <span class="number">1</span>, <span class="keyword">new</span> Department(<span class="number">1</span>, <span class="string">&quot;市场部&quot;</span>)));</span><br><span class="line">        employees.put(<span class="number">102</span>, <span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">&quot;黄校长&quot;</span>, <span class="string">&quot;qas261@162.com&quot;</span>,<span class="number">0</span>, <span class="keyword">new</span> Department(<span class="number">2</span>,<span class="string">&quot;教学部&quot;</span>)));</span><br><span class="line">        employees.put(<span class="number">103</span>, <span class="keyword">new</span> Employee(<span class="number">103</span>,<span class="string">&quot;王例子&quot;</span>, <span class="string">&quot;edf123261@162.com&quot;</span>,<span class="number">0</span>, <span class="keyword">new</span> Department(<span class="number">3</span>,<span class="string">&quot;运营部&quot;</span>)));</span><br><span class="line">        employees.put(<span class="number">104</span>, <span class="keyword">new</span> Employee(<span class="number">104</span>,<span class="string">&quot;安吉拉&quot;</span>, <span class="string">&quot;wd561@162.com&quot;</span>,<span class="number">1</span>, <span class="keyword">new</span> Department(<span class="number">4</span>,<span class="string">&quot;运营部&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主键自增</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer initId = <span class="number">104</span>;</span><br><span class="line">    <span class="comment">//增加一个员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmployee</span><span class="params">(Employee emp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(emp.getId() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            emp.setId(initId++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//emp部门由调用DepartmentDao包中的getDepartmentById()方法得到</span></span><br><span class="line">        emp.setDepartment(departmentDao.getDepartmentById(emp.getDepartment().getId()));</span><br><span class="line">        employees.put(emp.getId(), emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询全部员工信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employees.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过id查询员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpById</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employees.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        employees.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体实现">具体实现</h2>
<h3 id="一-默认访问首页">(一) 默认访问首页</h3>
<p>在controller类可以使用RequestMapping，浏览器发送 “/” 请求来到 templates 下的 index.html 页面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&#123;&quot;/&quot;,&quot;/index.html&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样每次都定义一个空方法比较麻烦，在MyMvcConfig 类中写webMvcConfigurer方法使所有组件一起起作用。修改引入的index.html 名为 login.html。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加视图映射</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span></span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/index.html&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">	｝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 将html文件其中的语法改为Thymeleaf，所有页面的静态资源都需要使用其接管。注意所有html都需要引入Thymeleaf命名空间。 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">xmlns:th=&quot;http://www.thymeleaf.org&quot;</span><br></pre></td></tr></table></figure> 例如，在 <code>index.html</code> 中 <img src="https://img-blog.csdnimg.cn/20210307160557602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 其他页面亦是如此，再次测试访问，正确显示页面</p>
<p>在application.properties修改url路径 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/kuang</span></span><br></pre></td></tr></table></figure> 运行，显示首页为 <img src="https://img-blog.csdnimg.cn/20210307162325534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h3 id="二国际化">（二）国际化</h3>
<h4 id="编写国际化配置文件抽取页面需要显示的国际化消息">1）、编写国际化配置文件，抽取页面需要显示的国际化消息</h4>
<p>在resources 下新建 i18n 包，包中新建配置文件<code>login.properties</code>和<code>login_en_US.properties</code>，自动生成如下形式： <img src="https://img-blog.csdnimg.cn/20210307161252704.png" alt="在这里插入图片描述" /></p>
<p>右键选择Add ... 下方 + 添加新语言，输入<code>zh_CN</code> 自动生成 <code>login_zh_CN.properties</code> <img src="https://img-blog.csdnimg.cn/20210307161350762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>在 Settings/Preferences 中找到 File Encodings，选为<strong>UTF8</strong>，并勾选自动转为ascii码。（此次是一个坑，不这样设置后面页面显示会出现乱码。） <img src="https://img-blog.csdnimg.cn/20201216233022753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 添加属性： <img src="https://img-blog.csdnimg.cn/20201217090321556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>配置好的文件如图 <img src="https://img-blog.csdnimg.cn/20210307161441122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210307161455434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210307161509114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h4 id="spring-boot自动配置好了管理国际化资源文件的组件">2）、Spring Boot自动配置好了管理国际化资源文件的组件</h4>
<p>我们的配置文件可以直接放在类路径下叫messages.properties。现在把配置文件放在i18n下，只需在application.properties下修改包名。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.messages.basename&#x3D;i18n&#x2F;login</span><br></pre></td></tr></table></figure></p>
<h4 id="去页面获取国际化的值">3）、去页面获取国际化的值（#{})</h4>
<p>在index.html 文件的相应位置用<code>th:**=&quot;#&#123;&#125;&quot;</code>修改 <img src="https://img-blog.csdnimg.cn/20201217201628675.png" alt="在这里插入图片描述" /> 此时显示页面为 <img src="https://img-blog.csdnimg.cn/20201217202555905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 此时，根据浏览器语言设置的信息即可切换中英文显示页面</p>
<h4 id="点击链接切换国际化">4）、点击链接切换国际化</h4>
<p>上述实现了登录首页显示为中文，我们在index.html页面中可以看到两个标签</p>
<p><code>&lt;a class=&quot;btn btn-sm&quot;&gt;中文&lt;/a&gt;</code> <code>&lt;a class=&quot;btn btn-sm&quot;&gt;English&lt;/a&gt;</code> 也就对应着视图中的 <img src="https://img-blog.csdnimg.cn/2021030716202535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 那么我们怎么通过这两个标签实现中英文切换呢?</p>
<p>首先在这两个标签上加上跳转链接并带上相应的参数 <img src="https://img-blog.csdnimg.cn/2021030716180356.png" alt="在这里插入图片描述" /></p>
<p>此时点击中文链接，url为 <img src="https://img-blog.csdnimg.cn/20210307162130307.png" alt="在这里插入图片描述" /></p>
<p>点击英文链接，显示页面为 <img src="https://img-blog.csdnimg.cn/20210307162140863.png" alt="在这里插入图片描述" /></p>
<p>但还没有实现点击链接切换。</p>
<p>先分析一下源码，首先搜索WebMvcAutoConfiguration，可以在其中找到关于一个方法 <code>localeResolver()</code> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果用户配置了,则使用用户配置好的</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FixedLocaleResolver(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//用户没有配置,则使用默认的</span></span><br><span class="line">   AcceptHeaderLocaleResolver localeResolver = <span class="keyword">new</span> AcceptHeaderLocaleResolver();</span><br><span class="line">   localeResolver.setDefaultLocale(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">   <span class="keyword">return</span> localeResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 再点开默认地区解析器的AcceptHeaderLocaleResolver对象，点击此类查看源码 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHeaderLocaleContextResolver</span> <span class="keyword">implements</span> <span class="title">LocaleContextResolver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Locale&gt; supportedLocales = <span class="keyword">new</span> ArrayList(<span class="number">4</span>);</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Locale defaultLocale;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcceptHeaderLocaleContextResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 可以发现它继承了LocaleResolver接口，实现了地区解析</p>
<p>类似地，我们只需要编写一个自己的地区解析器，继承LocaleResolver接口，重写其方法即可。</p>
<h5 id="编写区域解析器">编写区域解析器</h5>
<p><img src="https://img-blog.csdnimg.cn/20210307163114219.png" alt="在这里插入图片描述" /> 并重写<code>resolveLocale</code> 方法，对应着index.html 文件中请求参数 l - 如果点击中文按钮，则跳转到/index.html(l='zh_CN')页面 - 如果点击English按钮，则跳转到/index.html(l='en_US')页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocalResolver</span> <span class="keyword">implements</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析请求</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果获取请求中的语言参数链接，就构造一个自己的</span></span><br><span class="line">        String language = request.getParameter(<span class="string">&quot;l&quot;</span>);<span class="comment">//l对应着index.html文件中的跳转链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(language);</span></span><br><span class="line">        <span class="comment">//如果没有就使用默认</span></span><br><span class="line">        Locale locale = Locale.getDefault();</span><br><span class="line">        <span class="comment">//如果请求的链接携带了国际化参数，就构造一个自己的</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(language))&#123;</span><br><span class="line">            String[] s = language.split(<span class="string">&quot;_&quot;</span>);<span class="comment">//zh_CN</span></span><br><span class="line">            <span class="comment">//国家、地区</span></span><br><span class="line">             locale = <span class="keyword">new</span> Locale(s[<span class="number">0</span>], s[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注入容器">注入容器</h5>
<p>向容器中注入自定义的国际化组件才能生效</p>
<p>在<code>MyMvcConfig</code> 中添加代码 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyLocalResolver();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 重启项目即可实现国际化切换！</p>
<p>点击Engilsh <img src="https://img-blog.csdnimg.cn/20210307163828380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 点击中文<img src="https://img-blog.csdnimg.cn/20210307163856219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h3 id="三登录">（三）登录</h3>
<p>输入正确用户名密码。点击 <code>登录</code> 按钮即可登录进入后台，即dashboard.html页面。</p>
<h4 id="首先在index.html中添加表单提交地址">1）、首先在index.html中添加表单提交地址</h4>
<p>并添加<code>name</code>属性方便后面传参。 <img src="https://img-blog.csdnimg.cn/20210308200441814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p>
<h4 id="在controller-包新建logincontroller-类">2）、在controller 包新建LoginController 类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username, <span class="meta">@RequestParam(&quot;password&quot;)</span> String password, Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//具体的业务</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(password))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;dashboard&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//消息回显，需要model</span></span><br><span class="line">            model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 index.html 文件中添加键 msg 显示错误提示文本 <img src="https://img-blog.csdnimg.cn/20210308200834962.png" /></p>
<h4 id="测试">3）、测试：</h4>
<p>当输入正确用户名：admin，正确密码：123 时，进入；当输入错误信息时页面提示。 <img src="https://img-blog.csdnimg.cn/20210308200441814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /> 此时可以登录，但url中暴露了用户信息。编写一个映射，将dashboard 映射到main.html。</p>
<p>在 <code>MyMvcConfig</code> 类中的重写方法添加新的视图映射， <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry.addViewController(<span class="string">&quot;/main.html&quot;</span>).setViewName(<span class="string">&quot;dashboard&quot;</span>);</span><br></pre></td></tr></table></figure> 并将 LoginController 类采取<strong>重定向</strong>的方式 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username, <span class="meta">@RequestParam(&quot;password&quot;)</span> String password, Model model, HttpSession httpSession)</span></span>&#123;</span><br><span class="line">        <span class="comment">//具体的业务</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(password))&#123;</span><br><span class="line">            <span class="comment">//重定向</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:/main.html&quot;</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//消息回显，需要model</span></span><br><span class="line">            model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 此时再次登录，显示的url 就隐藏了用户信息 <img src="https://img-blog.csdnimg.cn/20210308201855103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /> 但此时发现，直接访问 main.html 就进入了首页，造成安全问题，故需要对一些页面进行拦截。</p>
<h3 id="四登录拦截器">（四）登录拦截器</h3>
<p>用户登录后，将用户信息存入session。 - 如果发现session为空，说明没有登录，需要拦截 - 否则，不需要拦截</p>
<p>在 LoginController 类中将用户信息存入session <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username, <span class="meta">@RequestParam(&quot;password&quot;)</span> String password, Model model, HttpSession httpSession)</span></span>&#123;</span><br><span class="line">        <span class="comment">//具体的业务</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(password))&#123;</span><br><span class="line">            httpSession.setAttribute(<span class="string">&quot;loginUser&quot;</span>, username);<span class="comment">//拦截器获取此session</span></span><br><span class="line">            <span class="comment">//重定向</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:/main.html&quot;</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//消息回显，需要model</span></span><br><span class="line">            model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在 config 包中新建 LoginHandlerInterceptot 类，实现 <code>HandlerInterceptor</code>接口，并重写 preHandle 方法。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//登录成功之后应该有用户的session</span></span><br><span class="line">        Object userSession = request.getSession().getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">        <span class="comment">//userSession为空，说明没有登录，需要拦截</span></span><br><span class="line">        <span class="keyword">if</span>(userSession == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//告诉一个消息</span></span><br><span class="line">            request.setAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;没有权限， 请先登录！&quot;</span>);</span><br><span class="line">            <span class="comment">//再返回到首页</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/index.html&quot;</span>).forward(request, response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">在 `MyMvcConfig` 类中添加拦截器，也就是重写addInterceptors 方法。注意排除登录页面及静态资源。</span><br><span class="line">```java</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginHandlerInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>).excludePathPatterns(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/index.html&quot;</span>,<span class="string">&quot;/user/login&quot;</span>,<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 此时，再直接输入main.html 就会提醒，对此页面进行了拦截。 <img src="https://img-blog.csdnimg.cn/20210308203154870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p>
<p>上两篇分别实现了<a href="https://blog.csdn.net/qq_39181839/article/details/111304598">导入静态资源、首页、国际化</a> 和 <a href="https://blog.csdn.net/qq_39181839/article/details/111336277">登录、登录拦截器</a></p>
<p>这一篇继续实现员工的增删改查 ### （四）CRUD</p>
<h4 id="一查显示员工列表">一、查—显示员工列表</h4>
<h5 id="实现点击customers跳转">1、实现点击Customers跳转</h5>
<p>为了在dashboard页面点击Customers 实现跳转，添加请求路径 /emps <img src="https://img-blog.csdnimg.cn/20210309202536643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /> 在templates目录下新建一个包emp，用来放所有关于员工信息的页面，将list.html页面移入该包中</p>
<p>添加 EmployeeController 类，处理 <code>/emps</code> 请求 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    EmployeeDao employeeDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/emps&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        Collection&lt;Employee&gt; employees = employeeDao.getAll();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;empl&quot;</span>, employees);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;emp/list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 注意到 list.html 和 dashboard.html 页面的侧边栏和顶部栏是相同的，可以抽取出来</p>
<h5 id="抽取页面公共部分">2. 抽取页面公共部分</h5>
<p>在 templates 目录下新建一个commons包，并新建commons.html。利用<code>th:fragment</code> 标签抽取公共部分（顶部导航栏和侧边栏） - 抽取公共片段 th:fragment=&quot;copy&quot; - 引入公共片段 th:insert=&quot;~{footer :: copy}&quot; <sub>{templatename::selector}：模板名::选择器 </sub>{templatename::fragmentname}:模板名::片段名 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--顶部导航栏,利用th:fragment提取出来,命名为topbar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0&quot;</span> <span class="attr">th:fragment</span>=<span class="string">&quot;topbar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;navbar-brand col-sm-3 col-md-2 mr-0&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;</span>&gt;</span>Company</span><br><span class="line">        name<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-control form-control-dark w-100&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;Search&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;navbar-nav px-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item text-nowrap&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;</span>&gt;</span>Sign out<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--侧边栏,利用th:fragment提取出来,命名为sidebar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;col-md-2 d-none d-md-block bg-light sidebar&quot;</span> <span class="attr">th:fragment</span>=<span class="string">&quot;siderbar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar-sticky&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav flex-column&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link active&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;feather feather-home&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;9 22 9 12 15 12 15 22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Dashboard <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sr-only&quot;</span>&gt;</span>(current)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;feather feather-file&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;13 2 13 9 20 9&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Orders</span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;feather feather-shopping-cart&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;9&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;21&quot;</span> <span class="attr">r</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">circle</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;20&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;21&quot;</span> <span class="attr">r</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">circle</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Products</span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/emps&#125;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;feather feather-users&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;9&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;7&quot;</span> <span class="attr">r</span>=<span class="string">&quot;4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">circle</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M23 21v-2a4 4 0 0 0-3-3.87&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M16 3.13a4 4 0 0 1 0 7.75&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Customers</span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;feather feather-bar-chart-2&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;18&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;20&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;18&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;12&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;20&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;12&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;6&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;20&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;6&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;14&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Reports</span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;feather feather-layers&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">points</span>=<span class="string">&quot;12 2 2 7 12 12 22 7 12 2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polygon</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;2 17 12 22 22 17&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;2 12 12 17 22 12&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Integrations</span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h6</span> <span class="attr">class</span>=<span class="string">&quot;sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>Saved reports<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;d-flex align-items-center text-muted&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">href</span>=<span class="string">&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span> <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">class</span>=<span class="string">&quot;feather feather-plus-circle&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;12&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;12&quot;</span> <span class="attr">r</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">circle</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;12&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;8&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;12&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;16&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;8&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;12&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;16&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;12&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav flex-column mb-2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;feather feather-file-text&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;14 2 14 8 20 8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;16&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;13&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;8&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;13&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;16&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;17&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;8&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;17&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;10 9 9 9 8 9&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Current month</span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;feather feather-file-text&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;14 2 14 8 20 8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;16&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;13&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;8&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;13&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;16&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;17&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;8&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;17&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;10 9 9 9 8 9&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Last quarter</span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;feather feather-file-text&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;14 2 14 8 20 8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;16&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;13&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;8&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;13&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;16&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;17&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;8&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;17&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;10 9 9 9 8 9&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Social engagement</span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://getbootstrap.com/docs/4.0/examples/dashboard/#&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;feather feather-file-text&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;14 2 14 8 20 8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;16&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;13&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;8&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;13&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;16&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;17&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;8&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;17&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;10 9 9 9 8 9&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Year-end sale</span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 并在 list.html 和 dashboard.html 中删除原导航栏、侧边栏代码，利用<code>th:replace=&quot;~&#123;&#125;&quot;</code> 标签引入抽取之后的 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导航栏--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123;common/common::topbar&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--侧边栏--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123;commons/commons::siderbar&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="点击customers-高亮">3、点击Customers 高亮</h5>
<p>在 dashboard.html 的侧边栏标签传递参数<code>active</code>为 main.html <img src="https://img-blog.csdnimg.cn/20210309204402489.png" /> 同样在 list.html 的侧边栏标签传递参数 <code>active</code> 为 list.html <img src="https://img-blog.csdnimg.cn/20210309204441574.png" /> 在 commons.html 利用thymeleaf接收参数active，利用三元运算符判断决定是否高亮 [在这里插入图片描述](https://img-blog.csdnimg.cn/20210309204029985.png<img src="https://img-blog.csdnimg.cn/2021030920454252.png" /> <img src="https://img-blog.csdnimg.cn/20210309204603421.png" /> 再次重启即实现点击高亮！</p>
<h5 id="显示员工列表">4、显示员工列表</h5>
<p>在 EmployeeController 中传入了<code>empl</code>，用 <code>th:each</code> 遍历取出 在list.html 中修改，并添加两个标签 编辑 和 删除 <img src="https://img-blog.csdnimg.cn/20210309205318935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 此时可以正确显示 <img src="https://img-blog.csdnimg.cn/20210309205351569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h4 id="二增实现增加员工">二、增—实现增加员工</h4>
<h5 id="实现页面跳转">1. 实现页面跳转</h5>
<p><img src="https://img-blog.csdnimg.cn/2021031420375290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /> 在list.html 增加一个“添加页面”按钮，并在EmployeeController类中处理请求。 <img src="https://img-blog.csdnimg.cn/20210314204203162.png" /> 使用Restful风格，这里通过get方式提交请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/emp&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toAddPage</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">       <span class="comment">//查出所有部门信息</span></span><br><span class="line">       Collection&lt;Department&gt; departments = departmentDao.getDepartment();</span><br><span class="line">       <span class="comment">//获得所有部门再返回前端</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;departments&quot;</span>, departments);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;emp/addEmp&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="添加员工页面">2. 添加员工页面</h5>
<p>点击“添加员工”显示/emp/addEmp.html，在emp包下新建addEmp.html，复制 list.html 的主要内容，并修改部门为显示部门名。 <img src="https://img-blog.csdnimg.cn/20210314204944713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导航栏--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123;common/common::topbar&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--侧边栏--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123;common/common::sidebar(active=&#x27;list.html&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">main</span> <span class="attr">role</span>=<span class="string">&quot;main&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--提交表单，点击添加按钮跳转--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/emp&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;zhangsan@atguigu.com&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--这里传入参数是id，与value对应。在controller接收的是一个Employee对象，所以需要提交的是其中的一个属性--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;department.id&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--th:text 显示为部门名 用户接收的是部门id，value为部门id--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:each</span>=<span class="string">&quot;dep:$&#123;departments&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;dep.getDepartmentName()&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;dep.getId()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;birth&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="添加员工">3. 添加员工</h5>
<p>点击“添加”按钮，进行表单提交，发出Post请求，路径仍是&quot;/add&quot;，重新跳转到/emps 页面展示全部员工信息。 <img src="https://img-blog.csdnimg.cn/20210314205510856.png" alt="在这里插入图片描述" /> 在EmployeeController中处理请求。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/emp&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addEmp</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用底层业务方法保存员工信息</span></span><br><span class="line">        employeeDao.addEmployee(employee);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/emps&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>添加之后： <img src="https://img-blog.csdnimg.cn/20210314205546102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /> 注意在添加日期时要注意日期格式，在 application.properties 中进行时间配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.mvc.date-format&#x3D;yyyy-MM-dd</span><br></pre></td></tr></table></figure>
<h4 id="三改修改员工信息">三、改—修改员工信息</h4>
<h5 id="实现页面跳转-1">1. 实现页面跳转</h5>
<p>在list.html 增加一个“编辑”按钮，选择需要修改的员工id。 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm btn-primary&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/emp/update/&#125;+$&#123;em.id&#125;&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure> 在EmployeeController类中处理请求，跳转到修改员工页面。<code>@PathVaribale</code> 获取url中的数据即传入前端选择的员工id。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/emp/update/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toUpdateEmp</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//查出原来的参数</span></span><br><span class="line">        Employee employee = employeeDao.getEmpById(id);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;emp&quot;</span>, employee);</span><br><span class="line"><span class="comment">//        //查出所有部门信息</span></span><br><span class="line">        Collection&lt;Department&gt; departments = departmentDao.getDepartment();</span><br><span class="line">        <span class="comment">//获得所有部门再返回前端</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;departments&quot;</span>, departments);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;emp/update&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="修改员工页面">2. 修改员工页面</h5>
<p>点击“编辑”显示/emp/addEmp.html，在emp包下新建update.html，复制 addEmp.html 的主要内容，并添加 <code>th:value</code> 或 <code>th:checked</code> 或 <code>th:selected</code>取出员工信息。 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--侧边栏--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123;common/common::sidebar(active=&#x27;list.html&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">main</span> <span class="attr">role</span>=<span class="string">&quot;main&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--提交表单，点击添加按钮跳转--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/emp/update&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--指定修改人的id--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;emp.getId()&#125;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;zhangsan&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;emp.getLastName()&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;zhangsan@atguigu.com&quot;</span>  <span class="attr">th:value</span>=<span class="string">&quot;$&#123;emp.getEmail()&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">th:checked</span>=<span class="string">&quot;$&#123;emp.getGender()==1&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">th:checked</span>=<span class="string">&quot;$&#123;emp.getGender()==0&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--这里传入参数是id，与value对应。在controller接收的是一个Employee对象，所以需要提交的是其中的一个属性--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;department.id&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--th:text 显示为部门名 用户接收的是部门id，value为部门id--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:each</span>=<span class="string">&quot;dep:$&#123;departments&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;dep.getDepartmentName()&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;dep.getId()&#125;&quot;</span>  <span class="attr">th:selected</span>=<span class="string">&quot;$&#123;emp.getDepartment().getId()==dep.getId()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;birth&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;zhangsan&quot;</span>  <span class="attr">th:value</span>=<span class="string">&quot;$&#123;#dates.format(emp.getBirth(),&#x27;yyyy-MM-dd&#x27;)&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure> 如修改 101 员工，修改页面显示为： <img src="https://img-blog.csdnimg.cn/20210314210944303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p>
<h5 id="修改员工">3. 修改员工</h5>
<p>点击“修改”按钮，进行表单提交，发出Post请求，路径仍是&quot;/emp/update&quot;，重新跳转到/emps 页面展示修改后的全部员工信息。 <img src="https://img-blog.csdnimg.cn/20210314211122552.png" /> 在EmployeeController中处理请求，将修改后的员工信息提交给后台。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/emp/update&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateEmp</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">        employeeDao.addEmployee(employee);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/emps&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>修改后返回&quot;/emps&quot;，已成功修改。 <img src="https://img-blog.csdnimg.cn/20210314211329593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p>
<h4 id="四删删除员工">四、删—删除员工</h4>
<p>在list.html 增加一个“删除”按钮，选择需要删除的员工id。 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm btn-danger&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/emp/delete/&#125;+$&#123;em.id&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure> 在 EmployeeController 类中处理请求，根据传入id删除员工。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/emp/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteEmp</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        employeeDao.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/emps&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 进行删除操作，显示更新后的员工信息。 <img src="https://img-blog.csdnimg.cn/20210314211753163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p>
]]></content>
      <categories>
        <category>SpringBoot学习</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>员工管理项目</tag>
      </tags>
  </entry>
  <entry>
    <title>狂神MyBatis笔记</title>
    <url>/2021/03/08/%E7%8B%82%E7%A5%9EMyBatis%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="代码实现">代码实现</h2>
<p>数据持久层mapper中只需要接口UserMapper，不需要实现类，而是通过.xml文件的naemespace绑定对应接口。</p>
<h3 id="编写代码">编写代码</h3>
<a id="more"></a>
<ul>
<li><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String pwd;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">	<span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口实现类由原来的...Impl转为一个Mapper配置文件...Mapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace = 绑定一个对应的Mapper接口 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 千万不能写错!!!! --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 查询语句 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 里面的id对应上面接口的方法名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		select * from user</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="crud">CRUD</h3>
<h4 id="namespace">1. namespace</h4>
<p>namespace中的包名要和mapper接口的包名一致</p>
<h4 id="selectinsertupdatedelete语句">2. select、insert、update、delete语句</h4>
<ul>
<li>id：对应接口的方法名</li>
<li>parameterType：参数类型</li>
<li>resultType：Sql语句执行的返回值</li>
</ul>
<p>例1：实现根据id查询用户</p>
<ol type="1">
<li><p>Mapper接口中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">	<span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在UserMapper.xml中添加Select语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 查询语句 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 里面的id对应上面接口的方法名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		select * from user</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据id查询用户，用&#x27;#&#x27;取方法参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    	select * from User whele id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>例2：增加用户</p>
<ol type="1">
<li><p>Mapper接口中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line">	<span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//添加用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在UserMapper.xml中添加Select语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 查询语句 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 里面的id对应上面接口的方法名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		select * from user</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据id查询用户，用&#x27;#&#x27;取方法参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    	select * from User whele id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插入用户,对象中对属性可以直接取出来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parametertype</span>&quot;<span class="attr">com.wu.pojo.User</span>&quot;&gt;</span></span><br><span class="line">	insert into user(id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>例3：修改用户</p>
<ol type="1">
<li><p>Mapper接口中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line">	<span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//添加用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">//修改用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在UserMapper.xml中添加Select语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 查询语句 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 里面的id对应上面接口的方法名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		select * from user</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据id查询用户，用&#x27;#&#x27;取方法参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    	select * from User whele id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插入用户,对象中对属性可以直接取出来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parametertype</span>&quot;<span class="attr">com.wu.pojo.User</span>&quot;&gt;</span></span><br><span class="line">		insert into user(id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--更新用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		update user set name=#&#123;name&#125;,pwd =#&#123;pwd&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>例4：删除用户</p>
<ol type="1">
<li><p>Mapper接口中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line">	<span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//添加用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">//修改用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">//删除用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在UserMapper.xml中添加Select语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 查询语句 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 里面的id对应上面接口的方法名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		select * from user</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据id查询用户，用&#x27;#&#x27;取方法参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    	select * from User whele id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插入用户,对象中对属性可以直接取出来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parametertype</span>&quot;<span class="attr">com.wu.pojo.User</span>&quot;&gt;</span></span><br><span class="line">		insert into user(id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--更新用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		update user set name=#&#123;name&#125;,pwd =#&#123;pwd&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--删除用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    	delete from user where id =#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="万能map">3. 万能map</h4>
<p>实体类，或数据库中的表，字段或参数过多，考虑使用Map。</p>
<ul>
<li>在 UserMapper 添加接口方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">getUserById2</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在UserMapper.xml中添加该方法的语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个后面的参数对应map的key，名字可以自己随便取，不要求和实体类一一对应--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">	select * from user where id = #&#123;userid&#125; and name =#&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试类中测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">	UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">	Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">	map.put(<span class="string">&quot;userid&quot;</span>, <span class="number">1</span>);</span><br><span class="line">	map.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	User user = mapper.getUserById2(map);</span><br><span class="line">	System.out.println(user);</span><br><span class="line">	sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Map传递参数，直接在sql中取出key即可！ 【parameter=“map”】</p>
<p>对象传递参数，直接在sql中取出对象的属性即可！ 【parameter=“Object”】</p>
<p>只有一个基本类型参数的情况下，可以直接在sql中取到</p>
<p>多个参数用Map , <strong>或者注解！</strong></p></li>
</ul>
<h4 id="模糊查询">4. 模糊查询</h4>
<ul>
<li><p>在 UserMapper 添加接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserLike</span><span class="params">(String value)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>在UserMapper.xml中添加该方法的语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--也可以用concat拼接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList2&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">	select * from user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot学习</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—回文问题</title>
    <url>/2021/03/09/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%9B%9E%E6%96%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>由一个整数问题引入。</p>
<p>回文即 正序（从左向右）和倒序（从右向左）读都是一样的。常见的有整数、链表、字符串相关问题。</p>
<p>先由整数问题引入。</p>
<h2 id="回文数">回文数</h2>
<a id="more"></a>
<h4 id="整数反转easy">7，整数反转，easy</h4>
<p>给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [−2<sup>31</sup>, 2<sup>31</sup> − 1] ，就返回 0。</p>
<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>此题需要注意的是x的范围，x∈[-2147483648, 2147483647]</p>
<p>考虑整数反转，只要不断取余并 / 10，即可取出末尾数字并构成新的反转数。如： <img src="https://img-blog.csdnimg.cn/20210309143302959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p>
<p>可见此方法适用于 x为正或为负，循环的判断条件为 <code>x != 0</code> 即可。</p>
<p>但是需要注意的是 反转数 的范围，比如 x = 1147483619，反转后超过[−2<sup>31</sup>, 2<sup>31</sup> − 1]。则需要判断临界条件，<strong>判断第一次取余后的x</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ee890586531264e25b92e600a50a7475.png" /></p>
<p>如图，如果此时<code>x &gt; 214748364</code> 说明已经超过范围，返回 0；如果此时<code>x = 214748364</code>，需要比较刚取出的末位数字与 7 的关系</p>
<p>负数同理</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e6282f5825b0df1868913d58e929ae47.png" /></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// x ≥ -2147483648 &amp;&amp; x ≤ 2147483647</span></span><br><span class="line">        <span class="comment">//将整数x不断取模，再x/10</span></span><br><span class="line">        <span class="comment">//x可正可负，判断条件为！= 0</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = x % <span class="number">10</span>;<span class="comment">//取模结果可正可负</span></span><br><span class="line">            <span class="comment">//判断剩余值是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(res &gt; <span class="number">214748364</span> || res == <span class="number">214847364</span> &amp;&amp; tmp &gt; <span class="number">7</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; -<span class="number">214748364</span> || res == -<span class="number">214748364</span> &amp;&amp; tmp &lt; -<span class="number">8</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新的结果</span></span><br><span class="line">            res = res * <span class="number">10</span> + tmp;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这道题的思路，那么判断一个整数是否为回文数就很简单了，只需进行反转然后比较与原数字是否相等。</p>
<h4 id="回文数easy">9，回文数，easy</h4>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>代码</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = x;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; <span class="number">214748364</span> || res == <span class="number">214748364</span> &amp;&amp; tmp &gt; <span class="number">7</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; -<span class="number">214748364</span> || res == -<span class="number">214748364</span> &amp;&amp; tmp &lt; -<span class="number">8</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">10</span> + tmp;</span><br><span class="line">            x /= <span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="回文串">回文串</h2>
<p>有了上面判断整数是否回文，再看字符串的问题。</p>
<h4 id="验证回文串easy">125，验证回文串，easy</h4>
<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>回文常用<strong>左右指针</strong>来判断</p>
<p>此题难点在于只考虑字母和数字且忽略字母大小写，要进行合法字符的判断再用快慢指针比较字符是否相同。</p>
<p><strong>代码</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;     </span><br><span class="line">        <span class="comment">//首先将s转为没有空格全部小写的字符串</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                sb.append(Character.toLowerCase(c));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span> || c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = sb.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.charAt(left)==(sb.charAt(right)))&#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于回文串，也常用动态规划来求最XX个数。</p>
<p>如下两道题。</p>
<h4 id="回文子串medium">647，回文子串，medium</h4>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>题目中要求回文子串个数，维护一个变量cnt，找到回文子串就将cnt+1</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i][j]\)</span> —— s[i]到s[j]形成的字符串是否是回文串</p></li>
<li><p>base case</p>
<p>单个字符一定为回文，返回TRUE</p>
<p><span class="math inline">\(dp[i][i] = true;\)</span></p></li>
<li><p>递推关系</p>
<p>如果 <code>s[i]==s[j]</code>，则比较中间部分是否是一个回文字符串</p>
<ul>
<li>j - i &lt;= 2，中间不含或只含一个子串，<code>dp[i][j] = true</code></li>
<li>否则，<span class="math inline">\(dp[i][j]\)</span> 取决于 <span class="math inline">\(dp[i+1][j - 1]\)</span>。注意遍历顺序！可以像如图 ：i 从下至上，j 从左至右遍历。 <img src="https://img-blog.csdnimg.cn/20210309144313182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></li>
</ul>
<ol start="4" type="1">
<li><p>返回值</p>
<p>上面得到的 <span class="math inline">\(dp[i][j]\)</span> 如果为 true，cnt++。最后返回cnt的值。</p></li>
</ol></li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//求dp[i][j]需要通过dp[i+1][j-1] 遍历顺序从下到上，从左到右</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]))&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长回文子串medium">5，最长回文子串，medium</h4>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>看到最长联想到用动态规划解题。</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i][j]\)</span> ——子串<code>s[i...j]</code> （闭区间）是否为回文子串</p></li>
<li><p>递推关系</p>
<ol type="1">
<li><p>base case</p>
<p>单个字符一定为回文，返回TRUE</p>
<p><span class="math inline">\(dp[i][i] = true;\)</span></p></li>
<li><p>状态转移方程</p>
<p>由题意，<code>s[i] == s[j]</code> 时子串<code>s[i...j]</code>为回文；去掉头尾后仍是回文时才有 <span class="math inline">\(dp[i][j] = true\)</span>。</p>
<p>则 <span class="math inline">\(dp[i][j] = (s[i] == s[j]) 与 dp[i+1][j-1]\)</span>。</p>
<p>边界条件： <code>i + 1 ≥ j - 1</code> =&gt; <code>j - i ≤ 2</code>，只需判断 <code>s[i] == s[j]</code>，不用参考以前的 <code>dp</code>值。</p>
<p>当 <code>j - i &gt; 2</code> 时，需要考虑 <span class="math inline">\(dp[i+1][j-1]\)</span>，即“有后效性”。在二维表中表现为参考左下方结果才能得到当前的 <span class="math inline">\(dp\)</span> 值。</p></li>
</ol></li>
<li><p>返回值</p>
<p>初始化变量 <code>maxLen</code> 记录最长回文子串长度， <code>start</code> 记录开始位置。</p></li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i - j &gt;= -<span class="number">2</span>)</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>; </span><br><span class="line">                        <span class="comment">// dp[i][j] = s.charAt(i) == s.charAt(j);</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + 1][j - 1];</span></span><br><span class="line">                &#125;</span><br><span class="line">           </span><br><span class="line">                <span class="comment">//此时dp[i][j]=true，是回文子串，还要更新开始位置和长度</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen)&#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong></p>
<p>对于填表，由于构成子串，因此 <code>i</code> 和 <code>j</code> 的关系是 <code>i &lt;= j</code> ，因此只需要填这张表格对角线以上的部分。</p>
<p>由于需要满足“无后效性”，填表顺序也需要注意。</p>
<p><strong>说明：表格中的数字表示「填表顺序」，从 1 开始</strong>。表格外的箭头和数字也表示「填表顺序」，与表格中的数字含义一致。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9e7b4a1321aa0c234a2418668127cf3b.png" /></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/80831a741823e2bcbbcd897382b39a69.png" /></p>
<h2 id="回文链表">回文链表</h2>
<p>回文也可以应用在链表中，思路较简单。 #### 234，回文链表，easy</p>
<p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p><strong>题解</strong></p>
<p>利用快慢指针（快速度为慢速度的2倍）找到中间节点，将后半段链表进行反转，再比较反转后的链表与原链表前半段是否相同。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode middle = getMiddle(head);<span class="comment">//链表中点</span></span><br><span class="line">        ListNode newHead = reverse(middle.next);<span class="comment">//反转后半部分链表</span></span><br><span class="line">        <span class="comment">//比较前半部分和后半部分链表的节点值</span></span><br><span class="line">        <span class="keyword">while</span>(newHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val != newHead.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            newHead = newHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">     <span class="comment">//返回链表的中间节点（如果链表长度为偶数，为左边的中间节点）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getMiddle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode temp = reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>扩展</strong></p>
<p>此方法符合时间复杂度为 O(n)，空间复杂度为 O(1)。</p>
<p>链表不支持随机访问，从头开始查找，时间复杂度为O(n)，没有用栈等存储，空间复杂度为 O(1)。</p>
<p><strong>链表与数组进行对比：</strong></p>
<p>数组的优点</p>
<ul>
<li>随机访问性强</li>
<li>查找速度快</li>
</ul>
<p>数组的缺点</p>
<ul>
<li>插入和删除效率低</li>
<li>可能浪费内存</li>
<li>内存空间要求高，必须有足够的连续内存空间。</li>
<li>数组大小固定，不能动态拓展</li>
</ul>
<p>链表的优点</p>
<ul>
<li>插入删除速度快</li>
<li>内存利用率高，不会浪费内存</li>
<li>大小没有固定，拓展很灵活。</li>
</ul>
<p>链表的缺点</p>
<ul>
<li>不能随机查找，必须从第一个开始遍历，查找效率低</li>
</ul>
<table>
<thead>
<tr class="header">
<th>时间复杂度</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>读取</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr class="even">
<td>插入</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr class="odd">
<td>删除</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—使用计数数组</title>
    <url>/2021/03/10/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E4%BD%BF%E7%94%A8%E8%AE%A1%E6%95%B0%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>此类题一般有一个元素值为<strong>1~n</strong> 的数组，要求找到<strong>重复或缺失的数字</strong>。</p>
<a id="more"></a>
<h5 id="找到所有数组中消失的数字easy">448，找到所有数组中消失的数字，easy</h5>
<p>给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>题意：数组元素值为 1 ~ n，数组长度为n，有重复元素。</p>
<p>使用计数数组 count，从索引 1 存储 nums的元素值，count 元素值为0的下标即nums中缺失的元素。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//count数组的下标1~n用来存储nums数组元素1~n，count不含有的元素的下标即为没出现过的nums元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            count[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="错误的集合easy">645，错误的集合，easy</h5>
<p>集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。</p>
<p>给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,2,4]</span><br><span class="line">输出: [2,3]</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<p>给定数组的长度范围是 [2, 10000]。 给定的数组是无序的。</p>
<p><strong>题解</strong></p>
<p>和上面题的思路一致，找到计数数组count中元素为 0 的即为缺失元素，为2的即为重复元素。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            count[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="寻找重复数medium">287，寻找重复数，medium</h5>
<p>上面的双指针法已经是最优解法了，但计数数组的思想比较好想。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            count[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题—股票交易问题</title>
    <url>/2021/03/11/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>再做一次股票交易问题，又发现满满的套路，跟我一起重刷一遍吧！思路清晰！一口气狂撸6道题！</p>
<h2 id="题目汇总">题目汇总：</h2>
<h4 id="贪心">贪心</h4>
<ul>
<li><p>121，最多进行一次买卖</p></li>
<li><p>122，可以多次买卖</p></li>
</ul>
<h4 id="二维dp">二维DP</h4>
<ul>
<li>122，可以多次买卖
<ul>
<li><p>309，多次买卖+卖出冷冻期</p></li>
<li><p>714，多次买卖+卖出手续费</p></li>
</ul></li>
</ul>
<h4 id="三维dp">三维DP</h4>
<ul>
<li>123，最多两次买卖</li>
<li>188，最多 k 次买卖</li>
</ul>
<a id="more"></a>
<p>注意卖出必须在买入之后！ #### 【贪心】 ##### 121，买卖股票的最佳时机，easy</p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你<u>最多只允许完成一笔交易</u>（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong> 记录当前的最小价格，当前价格与最小价格的差即为当前卖出的利润。维护两个变量：最小价格 <code>low</code>，和 最大利润 <code>maxP</code></p>
<p><strong>代码</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> low = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="comment">//如果当前价格比low小，更新low</span></span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; low) low = prices[i];</span><br><span class="line">            <span class="comment">//得到每次以当前价格卖出得到的最大利润值</span></span><br><span class="line">            maxP = Math.max(maxP, prices[i] - low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="买卖股票的最佳时机easy">122，买卖股票的最佳时机Ⅱ，easy</h5>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong> 可以无限次进行交易，则只要当天比前一天的价格高即可卖出，获得利润。</p>
<p><strong>代码</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;        </span><br><span class="line">		<span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">                maxP += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二维dp-1">【二维DP】</h4>
<p>上面的 122题 还可以用动态规划来解，理解了此题DP的思想，309题和714题就很好懂了！</p>
<h5 id="买卖股票的最佳时机easy-1">122，买卖股票的最佳时机Ⅱ，easy</h5>
<p>对股票，每天有三种选择：<strong>买入、卖出、保持不变</strong>。保持不变分为两种状态：一种是买入之后的持有股票，一种是卖出之后的不持有股票。 1. 子问题 <span class="math inline">\(dp[i][j]\)</span> — 在第 i 天持有状态为 s 的最大利润。其中 s = 0 表示当天不持有股票，s = 1表示当天持有股票。 2. base case <span class="math inline">\(dp[0][0] = 0\)</span> — 在第0天不持有股票，利润为0 <span class="math inline">\(dp[0][1] = -prices[i]\)</span> — 在第0天持有股票，利润为第一天股票价格的负值 3. 状态转移 - <span class="math inline">\(dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]\)</span> 在第 i 天不持有股票，前一天有两种可能：也不持有股票 或者 持有股票但在第 i 天卖出 - <span class="math inline">\(dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]\)</span> 在第 i 天持有股票，前一天有两种可能：也持有股票 或者 不持有股票但在第 i 天买入 4. 返回值 返回在第 n -1 天不持有的最大利润 <span class="math inline">\(dp[i - 1][0]\)</span>，不持有才是利润最大的时候</p>
<p><strong>代码</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = prices.length;<span class="comment">//天数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="最佳买卖股票时机含冷冻期medium">309，最佳买卖股票时机含冷冻期，medium</h5>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可<u>以尽可能地完成更多的交易</u>（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 <u>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</u> 示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>此题与上面的区别在于卖出之后冷冻期为 1 天，那么在状态转移中如果当天持有股票，就不能讨论与前一天的情况变化，而是考虑与两天前的情况比较。</p>
<p>如果今天持有股票，可能前一天持有保持不变，也可能之前没有股票，今天买入。</p>
<p>那么状态转移方程就变为 <span class="math inline">\(dp[i][1]=Math.max(dp[i-1][1], dp[i-2][0]-prices[i])\)</span>。 此时，for循环中 i 从 2 开始遍历。相应地，base case 的情况也要变化。</p>
<p><strong>代码</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = Math.max(<span class="number">0</span>, prices[<span class="number">1</span>] - prices[<span class="number">0</span>]);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = Math.max(-prices[<span class="number">0</span>], -prices[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="最佳买卖股票时机含手续费medium">714，最佳买卖股票时机含手续费，medium</h5>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以<u>无限次地完成交易，但是你每笔交易都需要付手续费</u>。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>与 122题 的唯一区别就是付手续费，那很简单嘛，设定买入需要交手续费，只要在原来买入的时候 减去fee 即可。</p>
<p><strong>代码</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length; </span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>] - fee;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="三维dp-1">【三维DP】</h4>
<h5 id="买卖股票的最佳时机hard">123，买卖股票的最佳时机Ⅲ，hard</h5>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你<u>最多可以完成 两笔 交易。</u></p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>限定了交易次数，所以需要再加一个状态 k。 <span class="math inline">\(dp[i][k][s]\)</span> — 在第 i 天，交易次数最多为 k，持有状态为 s 的最大利润。其中，0 =&lt; i &lt;= n - 1 , k &gt;= 1，s = 0 或 1。</p>
<p>此时的状态转移方程： - <span class="math inline">\(dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\)</span></p>
<pre><code>解释：今天没有持有股票，有两种可能：

要么是&lt;u&gt;昨天就没有持有，然后今天保持不变&lt;/u&gt;；要么是&lt;u&gt;昨天持有股票，但是今天卖出了，所以今天没有持有股票&lt;/u&gt;。</code></pre>
<ul>
<li><p><span class="math inline">\(dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\)</span></p>
<p>解释：今天持有着股票，有两种可能：</p>
<p>要么<u>昨天就持有着股票，然后今天保持不变</u>；要么<u>昨天本没有持有，但今天买入，所以今天就持有股票了</u>。</p></li>
</ul>
<p>由状态转移方程，for 循环 从 1 遍历，base case中就要讨论边界条件。</p>
<p>返回值：第 n - 1天不持有股票且最多交易2次 的最大利润 <span class="math inline">\(dp[n - 1][2][0]\)</span></p>
<p><strong>代码</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> max_k = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[0][1][0] = 0;</span></span><br><span class="line">        <span class="comment">// dp[0][2][0] = 0;</span></span><br><span class="line">        <span class="comment">// dp[0][1][1] = -prices[0];</span></span><br><span class="line">        <span class="comment">// dp[0][2][1] = -prices[0];</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                <span class="comment">//处理base case</span></span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][<span class="number">1</span>][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    dp[i][<span class="number">2</span>][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) = max(0,-无穷) = 0</span></span><br><span class="line">                    <span class="comment">//dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i]) = max(0,-无穷) = 0</span></span><br><span class="line">                    <span class="comment">//dp[i][1][1] = max(dp[i-1][1][1],dp[i-1][0][0] - prices[i]) = max(-无穷, -prices[i]) = -prices[i]</span></span><br><span class="line">                    <span class="comment">//dp[i][2][1] = max(dp[i-1][2][1],dp[i-1][0][0] - prices[i]) = max(-无穷, -prices[i]) = -prices[i]</span></span><br><span class="line">                &#125;</span><br><span class="line">               dp[i][k][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">               dp[i][k][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="买卖股票的最佳时机hard-1">188，买卖股票的最佳时机Ⅲ，hard</h5>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>与上一题区别在于完成 k 笔交易，有了上一题的铺垫，此题的代码很好解决。但按照上面的思路，k 太大会出现超出内存限制。思考：交易数k 最大有多大呢？</p>
<p>一次交易分为买入和卖出，至少需要两天。所以有效的限制 <code>k  &lt;= n / 2</code>，如果超过，就没有约束作用了，相当于 k = +无穷（即第122题）。</p>
<p><strong>代码</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span> || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k &gt; n / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfit(prices);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j &gt;= <span class="number">1</span>; j--)&#123;</span><br><span class="line">                <span class="comment">//处理base case</span></span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">               dp[i][j][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">0</span>], dp[i-<span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">               dp[i][j][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
