<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rui</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>去摘遥不可及的星星</description>
    <pubDate>Mon, 24 May 2021 04:41:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>MySQL-MVCC、当前读、快照读</title>
      <link>http://example.com/2021/05/24/MySQL-MVCC%E3%80%81%E5%BD%93%E5%89%8D%E8%AF%BB%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB/</link>
      <guid>http://example.com/2021/05/24/MySQL-MVCC%E3%80%81%E5%BD%93%E5%89%8D%E8%AF%BB%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB/</guid>
      <pubDate>Mon, 24 May 2021 04:38:40 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;mvcc&quot;&gt;MVCC&lt;/h2&gt;
&lt;p&gt;多版本并发控制，通过保存数据在每个时间点的快照来实现。&lt;/p&gt;
&lt;p&gt;InnoDB的MVCC通过在&lt;strong&gt;每行记录后面保存两个隐藏的列&lt;/strong&gt;来实现，一列保存&lt;strong&gt;行的创建时间&lt;/strong&gt;，一列保存&lt;strong&gt;行的删除时间&lt;/strong&gt;，这个时间指的是系统版本号。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="mvcc">MVCC</h2><p>多版本并发控制，通过保存数据在每个时间点的快照来实现。</p><p>InnoDB的MVCC通过在<strong>每行记录后面保存两个隐藏的列</strong>来实现，一列保存<strong>行的创建时间</strong>，一列保存<strong>行的删除时间</strong>，这个时间指的是系统版本号。</p><a id="more"></a><figure><img src="https://img-blog.csdnimg.cn/20210524122455323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><p>MVCC<strong>只在读已提交（RC）和可重复读（RR）</strong>两个隔离级别下工作。</p><h2 id="快照读">快照读</h2><p>读取记录的可见版本（有可能是历史版本），不用加锁。</p><p>简单的select操作，不包括 <code>select ... lock in share mode</code>，<code>select ... for update</code>。</p><ul><li><p>RC：每次select都生成一个快照读，总是读取已提交的最新数据行</p></li><li><p>RR：第一次select生成快照读，读取上一次的快照</p></li></ul><p>举例： <img src="https://img-blog.csdnimg.cn/2021052412263796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210524122720935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>对于操作的前四行，即只有事务2已提交</p><ul><li><p>读已提交： 未提交的事务id：[1,3] 最大的事务id：3 每一次查询都生成一个快照读，所以事务4的查询结果为29。</p></li><li><p>可重复读： RR第一次查询会生成快照，对一个事务，每次都沿用第一次的快照，直接复制一份之前的快照。 则在RR下，事务4再次查询的结果将会是29，而不是图中RC情况下的30。</p></li></ul><h2 id="当前读">当前读</h2><p>读取的是最新版本，并且对读取的记录加锁。</p><p><code>select...lock in share mode (共享读锁)</code> <code>select...for update</code> <code>update , delete , insert</code></p><p>上面形式都属于当前读。</p><h4 id="当前读的实现方式">当前读的实现方式</h4><p>使用next-key锁(行记录锁+Gap间隙锁)实现</p><h4 id="rr级别怎样防止幻读">RR级别怎样防止幻读？</h4><p>RR级别下只要对 SELECT 操作也手动加行（X）锁即可类似 SERIALIZABLE 级别（它会对 SELECT 隐式加锁） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里需要用 X锁， 用 LOCK IN SHARE MODE 拿到 S锁 后我们没办法做 写操作</span><br><span class="line">SELECT &#96;id&#96; FROM &#96;users&#96; WHERE &#96;id&#96; &#x3D; 1 FOR UPDATE;</span><br></pre></td></tr></table></figure> 如果 id = 1 的记录存在则会被加行（X）锁；如果不存在，则会加 next-lock key / gap 锁（范围行锁），即记录存在与否，mysql 都会对记录对应的索引加锁，其他事务是无法操作的。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQL/">MySQL</category>
      
      
      <category domain="http://example.com/tags/MVCC/">MVCC</category>
      
      
      <comments>http://example.com/2021/05/24/MySQL-MVCC%E3%80%81%E5%BD%93%E5%89%8D%E8%AF%BB%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL存储引擎及其索引实现</title>
      <link>http://example.com/2021/05/23/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E5%85%B6%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/</link>
      <guid>http://example.com/2021/05/23/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E5%85%B6%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Sun, 23 May 2021 07:17:15 GMT</pubDate>
      
      <description>&lt;p&gt;存储引擎指&lt;strong&gt;表&lt;/strong&gt;的类型及表在计算机上的存储方式。&lt;/p&gt;
&lt;p&gt;主要的存储引擎有InnoDB、MyISAM、Memory等。&lt;/p&gt;
&lt;h4 id=&quot;myiasm&quot;&gt;MyIASM&lt;/h4&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>存储引擎指<strong>表</strong>的类型及表在计算机上的存储方式。</p><p>主要的存储引擎有InnoDB、MyISAM、Memory等。</p><h4 id="myiasm">MyIASM</h4><a id="more"></a><h5 id="使用这个存储引擎每个myisam在磁盘上存储三个文件">1、使用这个存储引擎，每个MyISAM在磁盘上存储三个文件。</h5><p>• frm文件：存储表的定义数据</p><p>• MYD文件：存放<strong>表具体记录的数据</strong></p><p>• MYI文件：存储<strong>索引</strong></p><h5 id="特点">2、特点：</h5><ul><li><p>不支持事务，每次查询具有原子性</p></li><li><p>支持表级锁，每次操作对整个表加锁</p></li><li><p>采用<strong>非聚簇索引</strong>，索引文件与数据文件分离。<strong>索引文件的数据域存储指向数据记录的地址</strong>。辅助索引与主键索引基本一致，只是主索引要求key是唯一的，<strong>辅索引的key不用保证唯一性</strong>。</p></li></ul><h5 id="主键索引与辅助索引">3、主键索引与辅助索引</h5><h6 id="主索引">1）主索引</h6><p>先加载MYI文件，其中存放索引，找到对应地址之后，将MYD文件加载到内存，根据刚才得到的地址找到对应行数据，返回给用户。 <img src="https://img-blog.csdnimg.cn/2021052311210883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 上图是MyISAM主键索引，设表一共有三列，假设我们以Col1为主键。</p><h6 id="辅索引">2）辅索引</h6><p>如果在Col2上建立一个辅助索引，如图 <img src="https://img-blog.csdnimg.cn/2021052315003242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 同样data域存放数据记录的地址，但辅助索引的key可以重复。</p><h5 id="总结">总结</h5><p>因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。 MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h4 id="memory">Memory</h4><p>将数据存在内存 - 表级锁</p><ul><li><p>由于数据存在内存中，一旦服务器出现故障，数据都会丢失</p></li><li><p>默认使用hash索引</p></li></ul><h4 id="innodb">InnoDB</h4><p>默认的数据库存储引擎。</p><h5 id="特点-1">1、特点：</h5><ul><li><p>支持事务。默认事务隔离级别为可重复读（RR），通过MVCC实现。</p></li><li><p>支持行级锁，可以支持更高的并发。</p></li><li><p>支持外键约束；外键约束降低了表的查询速度，但增加了表之间的耦合度。</p></li><li><p>存在缓冲管理。通过缓冲池，将索引和数据全部缓存起来，加快查询速度。</p></li><li><p>采用聚簇索引（索引的数据域存储数据文件本身）</p></li></ul><h5 id="主键索引与辅助索引-1">2、主键索引与辅助索引</h5><p>InnoDB也使用B+树作为索引结构，但区别在于<strong>InnoDB的数据文件本身就是索引文件，InnoDB辅助索引的data域存储相应记录主键的值而不是地址。</strong></p><h6 id="主索引-1">1）主索引</h6><p>InnoDB的表数据文件本身就是按B+树组织的一个数据结构，<strong>树节点data域保存完整的数据记录</strong>。这个<strong>索引的key是数据表的主键</strong>，因此InnoDB表数据文件本身就是主索引。 <img src="https://img-blog.csdnimg.cn/20210523150921401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h6 id="辅索引-1">2）辅索引</h6><p>InnoDB的<strong>所有辅助索引都引用主键作为data域</strong>。例如，下图为定义在Col3上的一个辅助索引：</p><p><img src="https://img-blog.csdnimg.cn/20210523151044146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 辅助索引搜索需要检索两遍索引：首先检索<strong>辅助索引获得主键</strong>，然后用主键到<strong>主索引中检索获得数据记录</strong>。</p><h4 id="总结-1">总结</h4><p>InnoDB索引和MyISAM索引的区别：</p><ul><li><p>主索引的区别：InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</p></li><li><p>辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</p></li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQL/">MySQL</category>
      
      
      <category domain="http://example.com/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">存储引擎</category>
      
      <category domain="http://example.com/tags/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/">聚簇索引</category>
      
      
      <comments>http://example.com/2021/05/23/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E5%85%B6%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL索引底层实现</title>
      <link>http://example.com/2021/05/23/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link>
      <guid>http://example.com/2021/05/23/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Sun, 23 May 2021 01:14:45 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;一引入&quot;&gt;一、引入&lt;/h2&gt;
&lt;p&gt;索引的概念：索引是可以快速获取数据的数据结构。&lt;/p&gt;
&lt;p&gt;那么既然是数据结构，用什么数据结构实现呢？&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="一引入">一、引入</h2><p>索引的概念：索引是可以快速获取数据的数据结构。</p><p>那么既然是数据结构，用什么数据结构实现呢？</p><a id="more"></a><p>首先对于下面的表 <img src="https://img-blog.csdnimg.cn/20210522213925115.png" alt="在这里插入图片描述" /> 如果执行语句 <code>select * from t where t.money = 300;</code>，需会全表扫描，一条一条的遍历查询。</p><p><strong>查询一行数据至少和磁盘做一次I/O操作</strong>（I/O是很耗性能的），至少要做 7 次 I/O 操作。</p><h2 id="二索引的数据结构">二、索引的数据结构</h2><h4 id="avl树">1）AVL树</h4><p>那么利用AVL树的特性，将数据划分为两部分，可以降低时间复杂度。</p><p><img src="https://img-blog.csdnimg.cn/20210522214154182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 图示是最好的情况，近似于折半查找，时间复杂度为O(log2n)。但对于特殊数据，组成不平衡的AVL树，退化为顺序查找，效率为O(n)。 <img src="https://img-blog.csdnimg.cn/20210522214322790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h4 id="红黑树">2）红黑树</h4><p><img src="https://img-blog.csdnimg.cn/20210522214502148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 当单边的节点大于3时候，红黑树就会自动调整，这样可以解决二叉树的弊端。</p><p>但是红黑树同样也有弊端：</p><ul><li><p>当数据量特别大的时候，红黑树的高度特别大。</p></li><li><p>有可能查询的数据在叶子节点，那查询的次数也很大，且进行多次磁盘I/O操作，性能差。</p></li></ul><h4 id="b树">3） B树</h4><p><img src="https://img-blog.csdnimg.cn/2021052221511115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" />多路平衡查找树，M阶B树代表每个节点最多可以有M个子节点，所有非叶子节点在同一层。</p><p>B树有以下特点：</p><ul><li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子节点都位于同一层，并且叶子节点只有关键字，指向孩子的指针都为null。</li><li>每个节点都存有索引和数据，也就是对应的key和value。</li></ul><p>B树查找数据的时间复杂度最好为O(1)，即在第一个节点就查到，最差为O(logN)。</p><p>B树的弊端： 若一个节点的空间为16KB，若data中的数据过大，则一个节点能放的数据量较小，这样就会造成树的高度比较大（比红黑树高度小点）</p><h4 id="b树-1">4） B+树</h4><p><img src="https://img-blog.csdnimg.cn/20210522215648927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>B+树与B树的区别：</p><ul><li>B+树的非叶子节点只存储索引，不存储data，可以放更多索引</li><li>叶子节点包含所有索引字段，所有的data元素都存储在叶子节点</li><li><p>叶子节点使用指针连接，对 <code>select * from t where col2 &gt; 20</code> 的范围查找更快速 <img src="https://img-blog.csdnimg.cn/20210522222512889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p></li><li><p>时间复杂度固定为O(logN)</p></li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQL/">MySQL</category>
      
      
      <category domain="http://example.com/tags/%E7%B4%A2%E5%BC%95/">索引</category>
      
      
      <comments>http://example.com/2021/05/23/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux学习—权限、用户、系统指令</title>
      <link>http://example.com/2021/05/22/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9D%83%E9%99%90%E3%80%81%E7%94%A8%E6%88%B7%E3%80%81%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4/</link>
      <guid>http://example.com/2021/05/22/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9D%83%E9%99%90%E3%80%81%E7%94%A8%E6%88%B7%E3%80%81%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4/</guid>
      <pubDate>Sat, 22 May 2021 11:34:12 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;五管理使用者和设立权限的命令&quot;&gt;（五）管理使用者和设立权限的命令&lt;/h3&gt;
&lt;p&gt;执行命令&lt;code&gt;ls -l&lt;/code&gt; 的结果如下： &lt;img src=&quot;https://img-blog.csdnimg.cn/20210522092951254.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一列 10位代表文件类型和权限 第一位 如果是‘d’，代表目录；如果是‘-’，代表文件&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="五管理使用者和设立权限的命令">（五）管理使用者和设立权限的命令</h3><p>执行命令<code>ls -l</code> 的结果如下： <img src="https://img-blog.csdnimg.cn/20210522092951254.png" alt="在这里插入图片描述" /></p><ul><li><p>第一列 10位代表文件类型和权限 第一位 如果是‘d’，代表目录；如果是‘-’，代表文件</p><a id="more"></a><p>后9位每三个一组，第一组表示文件主人的权限；第二组表示文件主人同组成员的权限；第三组表示其他人的权限</p></li><li><p>第三列 代表文件拥有者</p></li><li><p>第四列 代表所属群组</p></li></ul><h6 id="chmod命令">1、chmod命令</h6><ul><li>改变许可权限 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x—文件可以被执行</span><br><span class="line">w—文件可以被写入</span><br><span class="line">r—文件可以被读取</span><br></pre></td></tr></table></figure></li><li>设定文件权限 <code>chmod 文件使用者(u/g/o) 增减(+/-) 权限(x/w/r) 文件</code> u—拥有文件的用户 g—用户所在群组 o—其他人 a—所有 举例： <img src="https://img-blog.csdnimg.cn/20210522095356850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 还可以用数字代替权限，4—w，2—r，1—x 下面两个命令等价： <code>chmod 751 a</code> <code>chmod u=rwx,g=rx,o=x a</code></li></ul><h6 id="useradd与userdel">2、useradd与userdel</h6><p>添加用户、删除用户 <code>useradd [用户名]</code> <code>userdel [参数] [用户名]</code> 参数：-r，删除用户及相关目录，彻底删除</p><h3 id="六用户设置命令">（六）用户设置命令</h3><h6 id="chgrp">1、chgrp</h6><p>用于变更文件或目录的所属群组 <code>chgrp 群组名称 文件名称</code> <img src="https://img-blog.csdnimg.cn/20210522192047136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h6 id="chown">2、chown</h6><p>将文件的拥有者改为指定的用户或组。 <img src="https://img-blog.csdnimg.cn/20210522192254672.png" alt="在这里插入图片描述" /> 举例： <img src="https://img-blog.csdnimg.cn/20210522192315372.png" alt="在这里插入图片描述" /></p><h6 id="su">3、su</h6><p>修改用户。</p><p><code>su 用户名</code> <img src="https://img-blog.csdnimg.cn/20210522192432941.png" alt="在这里插入图片描述" /></p><h3 id="七系统查看指令">（七）系统查看指令</h3><h6 id="exit">1、exit</h6><p>退出。文本模式下使用ctrl+D。</p><h6 id="reboot">2、reboot</h6><p>重新启动。 <img src="https://img-blog.csdnimg.cn/2021052219261529.png" alt="在这里插入图片描述" /></p><h6 id="halt和shutdown">3、halt和shutdown</h6><p>关机。 <img src="https://img-blog.csdnimg.cn/20210522192653797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h6 id="ps">4、ps</h6><p>查看在系统中哪些程序在执行及其执行的情况。（静态查看） <img src="https://img-blog.csdnimg.cn/20210522192806192.png" alt="在这里插入图片描述" /></p><h6 id="top">5、top</h6><p>查看目前程序的执行情景和内存使用。（动态查看） 几秒钟就更新一次系统状态，方便跟踪。</p><h6 id="kill">6、kill</h6><p>终止一个正在执行中的进程。 <code>kill 进程号</code></p><h6 id="date在这里插入图片描述">7.date<img src="https://img-blog.csdnimg.cn/20210522193059760.png" alt="在这里插入图片描述" /></h6><h6 id="cal">8.cal</h6><figure><img src="https://img-blog.csdnimg.cn/20210522193126666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h6 id="df">9.df</h6><p>检查硬盘的使用量</p><h6 id="du">10.du</h6><p>显示文件目录的大小 <code>du 参数 文件名</code></p><h3 id="九网络操作命令">（九）网络操作命令</h3><figure><img src="https://img-blog.csdnimg.cn/20210522193311519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</category>
      
      
      
      <comments>http://example.com/2021/05/22/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9D%83%E9%99%90%E3%80%81%E7%94%A8%E6%88%B7%E3%80%81%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux学习—文件备份、压缩、阅读、定位命令</title>
      <link>http://example.com/2021/05/21/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E3%80%81%E5%8E%8B%E7%BC%A9%E3%80%81%E9%98%85%E8%AF%BB%E3%80%81%E5%AE%9A%E4%BD%8D%E5%91%BD%E4%BB%A4/</link>
      <guid>http://example.com/2021/05/21/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E3%80%81%E5%8E%8B%E7%BC%A9%E3%80%81%E9%98%85%E8%AF%BB%E3%80%81%E5%AE%9A%E4%BD%8D%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Fri, 21 May 2021 01:37:16 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;三文件备份和压缩命令&quot;&gt;（三）、文件备份和压缩命令&lt;/h3&gt;
&lt;h6 id=&quot;bzip2&quot;&gt;1、bzip2&lt;/h6&gt;
&lt;p&gt;将源文件file压缩为file.bz2，压缩后无源文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bzip2 文件名称&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解压：&lt;code&gt;bunzip2 file.bz2&lt;/code&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="三文件备份和压缩命令">（三）、文件备份和压缩命令</h3><h6 id="bzip2">1、bzip2</h6><p>将源文件file压缩为file.bz2，压缩后无源文件</p><p><code>bzip2 文件名称</code></p><p>解压：<code>bunzip2 file.bz2</code></p><a id="more"></a><p>压缩文件 file.bz2 解压为 file，解压后无压缩文件</p><p>可以同时压缩多个文件 <img src="https://img-blog.csdnimg.cn/20210521091538915.png" alt="在这里插入图片描述" /></p><h6 id="gzip">2、gzip</h6><p><code>gzip file</code> <code>gunzip file.gz</code> 与bzip2规则一样 <img src="https://img-blog.csdnimg.cn/20210521091815502.png" alt="在这里插入图片描述" /></p><h6 id="tar">3、tar</h6><p>将文件或目录进行打包或解压缩 <code>tar [参数] [打包后的文件名] [需要打包的文件或目录]</code> 参数包括： <img src="https://img-blog.csdnimg.cn/2021052109214663.png" alt="在这里插入图片描述" /> 常用参数： - 打包：cvf - 解压缩：xvf</p><p>打包后的文件名：file.tar</p><p>举例： <img src="https://img-blog.csdnimg.cn/20210521092340345.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210521092400793.png" alt="在这里插入图片描述" /> 与bzip2、gzip的区别： 打包后不会删除源文件，解压后也不会删除压缩文件</p><h3 id="四文件阅读和定位命令">（四）文件阅读和定位命令</h3><h6 id="head">1、head</h6><p>默认查看文件开头的10行，通过设置可查看前xx行。 <code>head 文件名称</code> <code>head -20 file</code> 查看file的前20行</p><h6 id="tail">2、tail</h6><p>默认查看文件结尾的10行，通过设置可查看结尾的最后xx行。 <code>tail 文件名称</code> <code>tail -20 file</code> 查看file的后20行 有助于查看日志文件的最后10行来阅读重要的系统信息。</p><h6 id="more">3、more</h6><p>按页查看文件内容 <code>more [选项] [文件名称]</code> <img src="https://img-blog.csdnimg.cn/20210521093020319.png" alt="在这里插入图片描述" /> 使用more在文本文件中搜索关键字 <img src="https://img-blog.csdnimg.cn/202105210931181.png" alt="在这里插入图片描述" /> 当一个目录下的文件内容太多，用more来分页显示。与管道 | 结合起来。 <img src="https://img-blog.csdnimg.cn/20210521093212315.png" alt="在这里插入图片描述" /></p><h6 id="which">4、which</h6><p>依序从path环境变量所列的目录中找出命令的位置，并显示完整路径的名称。在找到第一个符合条件的程序文件时，就立刻停止搜索。 <code>which 命令</code></p><h6 id="whereis">5、whereis</h6><p>查找符合条件的文件，定位一些文件在文件系统中的位置。一般用于程序名的搜索。 <img src="https://img-blog.csdnimg.cn/2021052109344331.png" alt="在这里插入图片描述" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</category>
      
      
      <category domain="http://example.com/tags/Linux%E5%91%BD%E4%BB%A4/">Linux命令</category>
      
      
      <comments>http://example.com/2021/05/21/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E3%80%81%E5%8E%8B%E7%BC%A9%E3%80%81%E9%98%85%E8%AF%BB%E3%80%81%E5%AE%9A%E4%BD%8D%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>解锁一道会员题—LeetCode1245</title>
      <link>http://example.com/2021/05/20/%E8%A7%A3%E9%94%81%E4%B8%80%E9%81%93%E4%BC%9A%E5%91%98%E9%A2%98%E2%80%94LeetCode1245/</link>
      <guid>http://example.com/2021/05/20/%E8%A7%A3%E9%94%81%E4%B8%80%E9%81%93%E4%BC%9A%E5%91%98%E9%A2%98%E2%80%94LeetCode1245/</guid>
      <pubDate>Thu, 20 May 2021 09:12:01 GMT</pubDate>
      
      <description>&lt;p&gt;先由一道easy题入手 &lt;a href=&quot;https://leetcode-cn.com/problems/diameter-of-binary-tree/&quot;&gt;LeetCode 543&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>先由一道easy题入手 <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">LeetCode 543</a></p><a id="more"></a><p>二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 对于每个节点，直径即其<strong>左子树和右子树的深度的和</strong>，而对整个树，<strong>这些节点的直径中的最大值</strong>即是树的直径。 方法：采用dfs，建立辅助函数，函数返回值为以当前root节点为根节点的树的深度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历每个节点,此方法返回root为根节点的树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = depth(root.left);<span class="comment">//根节点为root的左子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> r = depth(root.right);<span class="comment">//根节点为root的右子树的深度</span></span><br><span class="line">        ans = Math.max(ans, l + r);<span class="comment">//更新树的直径</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面的铺垫，那看一下主角题目： <img src="https://img-blog.csdnimg.cn/20210513150943989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" />虽然是树，但已经转化为图的题。 任意一个节点的最大直径是<strong>从自身出发的所有路径中最长两条路径长度的和。</strong> 依然采用dfs，则辅助函数返回值为以当前节点root（父节点parent）为起点的路径的最大值。函数中需要维护一个最大长路径max1，和一个次长路径max2。并维护一个res，不断与<code>max1+max2</code> 进行比较，求最大值即为最长直径。</p><p>继续思考： 如果无向图中的路径有值呢？</p><p><img src="https://img-blog.csdnimg.cn/20210513210746152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 题目中给出的是edges关系。还需要建立一个新的Node类，和一个<code>List&lt;Node&gt;[]</code> 邻接表记录节点之间的关系。</p><p>辅助函数依然返回的是当前节点root为起点的一条路径的最长长度。 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *   int start;</span></span><br><span class="line"><span class="comment"> *   int end;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;  <span class="comment">// 邻接点结构</span></span><br><span class="line">        <span class="keyword">int</span> id, dist; <span class="comment">//id表示节点编号，dist表示距离</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> dist)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.dist = dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    List&lt;Node&gt;[] g; <span class="comment">// 保存邻接点</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> n, Interval[] Tree_edge, <span class="keyword">int</span>[] Edge_value)</span> </span>&#123;</span><br><span class="line">        g = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            g[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//每个节点的邻接点和距离值</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = Tree_edge[i].start, y = Tree_edge[i].end;</span><br><span class="line">            g[x].add(<span class="keyword">new</span> Node(y, Edge_value[i]));</span><br><span class="line">            g[y].add(<span class="keyword">new</span> Node(x, Edge_value[i]));</span><br><span class="line"> <span class="comment">//g[0]:Node(1,3) g[1]:Node(0,3),Node(2,2),Node(5,4) g[2]:Node(1,2),Node(3,1),Node(4,5) g[3]:Node(2,1) g4:Node(2,5) g[5]:Node(1,4)</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回当前节点root（父节点为parent）为起点的路径的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">         List&lt;Node&gt; list  = g[root];</span><br><span class="line">        <span class="keyword">int</span> max1 = <span class="number">0</span>; <span class="comment">// 以当前节点为起点的一条最大路径长度</span></span><br><span class="line">        <span class="keyword">int</span> max2 = <span class="number">0</span>; <span class="comment">// 以当前节点为起点的一条次大路径长度</span></span><br><span class="line">        <span class="keyword">for</span>(Node next : list)&#123;</span><br><span class="line">            <span class="comment">//防止走回头路</span></span><br><span class="line">            <span class="keyword">if</span>(next.id != parent)&#123;</span><br><span class="line">                <span class="keyword">int</span> max = dfs(next.id, root) + next.dist;</span><br><span class="line">                <span class="keyword">if</span>(max &gt;= max1)&#123;</span><br><span class="line">                    max2 = max1;</span><br><span class="line">                    max1 = max;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max &gt;= max2)&#123;</span><br><span class="line">                    max2 = max;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// max1+max2得到当前节点最大边长,与返回结果比较，更新最大值</span></span><br><span class="line">                res = Math.max(res, max1 + max2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回当前节点一条路径的最大长度</span></span><br><span class="line">        <span class="keyword">return</span> max1;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/LeetCode%E5%88%B7%E9%A2%98/">LeetCode刷题</category>
      
      
      <category domain="http://example.com/tags/%E5%9B%BE/">图</category>
      
      
      <comments>http://example.com/2021/05/20/%E8%A7%A3%E9%94%81%E4%B8%80%E9%81%93%E4%BC%9A%E5%91%98%E9%A2%98%E2%80%94LeetCode1245/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux学习—概述及对文件目录的操作</title>
      <link>http://example.com/2021/05/20/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C/</link>
      <guid>http://example.com/2021/05/20/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Thu, 20 May 2021 09:08:35 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;Linux的基本思想： 第一，一切都是文件；第二，每个软件都有确定的用途。其中一条详细讲就是系统的所有都可以归结为一个文件，包括命令、硬件和软件设备、操作系统等。 Linux支持多用户，各个用户之间互不影响。Linux可以使多个程序同时并独立地运行。&lt;/p&gt;
&lt;h2 id=&quot;二目录结构和vi编辑器&quot;&gt;二、目录结构和vi编辑器&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="一概述">一、概述</h2><p>Linux的基本思想： 第一，一切都是文件；第二，每个软件都有确定的用途。其中一条详细讲就是系统的所有都可以归结为一个文件，包括命令、硬件和软件设备、操作系统等。 Linux支持多用户，各个用户之间互不影响。Linux可以使多个程序同时并独立地运行。</p><h2 id="二目录结构和vi编辑器">二、目录结构和vi编辑器</h2><a id="more"></a><h3 id="一目录结构">（一）目录结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc：配置文件存放地</span><br><span class="line">&#x2F;home：用户的目录</span><br><span class="line">&#x2F;bin：可执行文件和常用的Linux命令</span><br><span class="line">&#x2F;root：root账户的home目录</span><br></pre></td></tr></table></figure><h3 id="二vi编辑器">（二）vi编辑器</h3><p>格式：<code>vi file_name</code> 功能：生成新文件或编辑、查看文件</p><p>由命令模式进入编辑模式 1）按 i 键，插入文本 2）按 a 键，追加文本</p><p>由编辑模式进入命令模式 按ETC键</p><p>可执行的操作： 1）:w 保存文件 2）:wq 保存并退出 3）:wq! 保存并强制退出</p><h2 id="三linux命令">三、Linux命令</h2><h3 id="一管理文件和目录">（一）管理文件和目录</h3><h6 id="pwd">1、pwd</h6><p>打印用户当前所处路径 <code>[root@localhost~]# pwd</code></p><h6 id="cd">2、cd</h6><p>改变用户所在目录 <code>[root@localhost~]# cd &lt;目录名&gt;</code> <img src="https://img-blog.csdnimg.cn/2021052016503643.png" alt="在这里插入图片描述" /></p><h6 id="ls">3、ls</h6><p>显示指定目录下的内容 <code>ls [参数] [目录或文件]</code> <img src="https://img-blog.csdnimg.cn/20210520165140826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h6 id="cat">4、cat</h6><p>显示文本内容 <code>cat 文本文件名字</code> 举例： <img src="https://img-blog.csdnimg.cn/20210520165308670.png" alt="在这里插入图片描述" /></p><h6 id="touch">5、touch</h6><p>创建文本 <code>touch 文本文件名字</code></p><h6 id="grep">6、grep</h6><p>在一堆文件中查找一个特定的字符串 <code>grep 字符串 文件名</code></p><h6 id="cp">7、cp</h6><p>复制文件，可以目标文件的指定位置 <code>cp 源文件 目标文件</code> 举例： <img src="https://img-blog.csdnimg.cn/20210520165542906.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210520165644469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h3 id="二对文件和目录的操作">（二）对文件和目录的操作</h3><h6 id="mv">1、mv</h6><p>对文件或目录进行移动，还可以进行重命名 <code>mv 源对象 目的对象</code> <img src="https://img-blog.csdnimg.cn/20210520165806502.png" alt="在这里插入图片描述" /> 举例： <img src="https://img-blog.csdnimg.cn/2021052016585269.png" alt="在这里插入图片描述" /><img src="https://img-blog.csdnimg.cn/20210520165904766.png" alt="在这里插入图片描述" /></p><h6 id="mkdir">2、mkdir</h6><p>创建目录 <code>mkdir [目录名1] [目录名2] [目录名3] ...</code> 举例： <img src="https://img-blog.csdnimg.cn/20210520170235301.png" alt="在这里插入图片描述" /></p><p>可以创建嵌套的目录，但只能嵌套一个 <code>mkdir -p aa/bb</code></p><h6 id="rmdir">3、rmdir</h6><p>删除目录 <code>rmdir [参数] [目录名1] [目录名2] ...</code> 可以删除多个嵌套目录 <code>rmdir -p aa/bb/cc</code></p><h6 id="rm">4、rm</h6><p>删除文件 <code>rm [参数] [文件]</code> <img src="https://img-blog.csdnimg.cn/20210520170411209.png" alt="在这里插入图片描述" /> 举例： <img src="https://img-blog.csdnimg.cn/20210520170524601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</category>
      
      
      <category domain="http://example.com/tags/Linux/">Linux</category>
      
      
      <comments>http://example.com/2021/05/20/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据结构面试题</title>
      <link>http://example.com/2021/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <guid>http://example.com/2021/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <pubDate>Thu, 29 Apr 2021 13:54:05 GMT</pubDate>
      
      <description>&lt;p&gt;数据结构是计算机存储、组织数据的方式。对于特定的数据结构(比如数组)，有些操作效率很高(读某个数组元素)，有些操作的效率很低(删除某个数组元素)。程序员的目标是为当前的问题选择最优的数据结构。&lt;/p&gt;
&lt;p&gt;八种常用数据结构：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>数据结构是计算机存储、组织数据的方式。对于特定的数据结构(比如数组)，有些操作效率很高(读某个数组元素)，有些操作的效率很低(删除某个数组元素)。程序员的目标是为当前的问题选择最优的数据结构。</p><p>八种常用数据结构：</p><a id="more"></a><p>一、数组 分为一维数组和多维数组。 优点：查询某个元素比较方便，时间复杂度为O(1)。 缺点：构建时必须分配一段连续的空间，添加和删除元素时间复杂度为O(n)</p><p>二、链表 也是线性结构，是由一系列节点组成的链，每一个节点保存了数据及指向下一节点的指针。 优点：灵活分配内存空间，在O(1)时间内删除或添加元素。 缺点： 查询第k个元素需要O(k)时间。 三、栈 栈中元素采用先进后出，常用操作包括push()、pop()、isEmpty()、peek()。 对于栈中数据来说，所有操作在栈顶完成，只能查看栈顶部的数据，向栈顶压入数据，也只能从栈顶弹出数据。 四、队列 与栈类似，都采用线性结构存储数据。队列采用先进先出。 对于队列的数据来说，只允许在队尾查看和添加数据，在队头查看和删除数据。双端队列的头尾都能在O(1)的时间内进行数据的查看、添加和删除。 五、图 由多个节点组成，节点间可以互相连接组成一个网络。图分为有向图和无向图。 六、树 分层的数据结构，由节点和连接节点的边组成。树是一种特殊的图，与图的区别在于没有循环。 树的节点可以分为根节点、子节点，子节点又包括非叶子节点和叶子节点。 二叉树和二叉查找树是最常用的树。 七、前缀树 与树类似，处理字符串问题非常高效。 八、哈希表</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">面试问题</category>
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>http://example.com/2021/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>一道阿里面试算法题</title>
      <link>http://example.com/2021/04/18/%E4%B8%80%E9%81%93%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</link>
      <guid>http://example.com/2021/04/18/%E4%B8%80%E9%81%93%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</guid>
      <pubDate>Sun, 18 Apr 2021 01:34:05 GMT</pubDate>
      
      <description>&lt;p&gt;面试过程中出的一道算法题，应该算easy程度吧，面试过程中理解错了，审题很重要！ 题目：给定一串括号，判断是否符合规则，即相应左右括号数量匹配，右括号出现在左括号右面。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>面试过程中出的一道算法题，应该算easy程度吧，面试过程中理解错了，审题很重要！ 题目：给定一串括号，判断是否符合规则，即相应左右括号数量匹配，右括号出现在左括号右面。</p><a id="more"></a><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：([)[]&#123;()&#125;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：)&#123;[(]&#125;)</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&#123;[(]&#125;)</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用map记录每种右括号的数量，遍历字符串，遇到左括号，将相应右括号数量+1；遇到右括号，如果此时value值为0或map还未放入元素，则返回false，否则相应value值-1。最后返回三个value值是否都为0。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 给定一个字符串，判断是否有效</span></span><br><span class="line"><span class="comment"> *（各种括号数量匹配即有效）</span></span><br><span class="line"><span class="comment"> * 输入：([)[]&#123;()&#125; 输出：false</span></span><br><span class="line"><span class="comment"> *      )&#123;[(]&#125;) 输出：true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAlibaba</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = sc.nextLine();</span><br><span class="line">        System.out.println(helper(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="comment">//遇到左括号相应map的size + 1,遇到右括号-1</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : ch)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                map.put(<span class="string">&#x27;)&#x27;</span>, map.getOrDefault(<span class="string">&#x27;)&#x27;</span>, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                map.put(<span class="string">&#x27;]&#x27;</span>, map.getOrDefault(<span class="string">&#x27;]&#x27;</span>, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                map.put(<span class="string">&#x27;&#125;&#x27;</span>, map.getOrDefault(<span class="string">&#x27;&#125;&#x27;</span>, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.isEmpty() || map.get(<span class="string">&#x27;)&#x27;</span>) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> map.put(<span class="string">&#x27;)&#x27;</span>, map.get(<span class="string">&#x27;)&#x27;</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.isEmpty() || map.get(<span class="string">&#x27;]&#x27;</span>) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> map.put(<span class="string">&#x27;]&#x27;</span>, map.get(<span class="string">&#x27;]&#x27;</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.isEmpty() || map.get(<span class="string">&#x27;&#125;&#x27;</span>) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> map.put(<span class="string">&#x27;&#125;&#x27;</span>, map.get(<span class="string">&#x27;&#125;&#x27;</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(<span class="string">&#x27;)&#x27;</span>) == <span class="number">0</span> &amp;&amp; map.get(<span class="string">&#x27;]&#x27;</span>) == <span class="number">0</span> &amp;&amp; map.get(<span class="string">&#x27;&#125;&#x27;</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">面试问题</category>
      
      
      
      <comments>http://example.com/2021/04/18/%E4%B8%80%E9%81%93%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>4月15携程实习生笔试</title>
      <link>http://example.com/2021/04/16/4%E6%9C%8815%E6%90%BA%E7%A8%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95/</link>
      <guid>http://example.com/2021/04/16/4%E6%9C%8815%E6%90%BA%E7%A8%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95/</guid>
      <pubDate>Fri, 16 Apr 2021 09:34:03 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;第一题-盖房子&quot;&gt;第一题 盖房子&lt;/h2&gt;
&lt;p&gt;第一次在某个点建红房子“R&amp;quot;，之后每次在新房子左边建绿房子&amp;quot;G&amp;quot;，右边建红房子“R&amp;quot;。 输入一个n（1≤n≤12），输出过了n个月房子的排列。 要求： 输入非数字打印“N” 输入数字超出限制，打印“O&amp;quot; 样例： &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出GRR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出GGRRGRR&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="第一题-盖房子">第一题 盖房子</h2><p>第一次在某个点建红房子“R&quot;，之后每次在新房子左边建绿房子&quot;G&quot;，右边建红房子“R&quot;。 输入一个n（1≤n≤12），输出过了n个月房子的排列。 要求： 输入非数字打印“N” 输入数字超出限制，打印“O&quot; 样例： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入1</span><br><span class="line">输出R</span><br><span class="line">输入2</span><br><span class="line">输出GRR</span><br><span class="line">输入3</span><br><span class="line">输出GGRRGRR</span><br></pre></td></tr></table></figure> <a id="more"></a></p><p><strong>题解</strong></p><p>由每次的变化，想到构建二叉树，根节点是&quot;R”，左子节点都是“G&quot;，右子节点都是&quot;R&quot;，最后进行中序遍历得到结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    String val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(String val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main0415</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = sc.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;N&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span> || n &gt; <span class="number">12</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;O&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(createTree(<span class="keyword">new</span> TreeNode(<span class="string">&quot;R&quot;</span>), n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由root构建层数为depth的树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createTree</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(depth == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">         root.left = <span class="keyword">new</span> TreeNode(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">         root.right = <span class="keyword">new</span> TreeNode(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">         createTree(root.left, depth - <span class="number">1</span>);</span><br><span class="line">         createTree(root.right, depth - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历打印结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以做更进一步的简化，使用递归实现树的中序遍历</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main0415</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = sc.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;N&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span> || n &gt; <span class="number">12</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;O&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">System.out.println(helper(n, <span class="keyword">new</span> StringBuilder(<span class="string">&quot;R&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> sb;</span><br><span class="line">        <span class="keyword">return</span> helper(n - <span class="number">1</span>, <span class="keyword">new</span> StringBuilder(<span class="string">&quot;G&quot;</span>)).append(sb).append(helper(n - <span class="number">1</span>, <span class="keyword">new</span> StringBuilder(<span class="string">&quot;R&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题-包依赖问题">第二题 包依赖问题</h2><p>使用正整数表示包，对给定的被修改的包，求出所有受影响的包（去重）所代表数字的和，若无受影响的包则返回-1。直接依赖和间接依赖的包被修改均定义为受影响。 输入说明： 第一行为整数，表示被修改的包。 第二行开始的后续行都是数组，代表数组的第一个元素依赖后续的元素，注意数组元素可能只有1个，代表该包无依赖。 示例： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">4</span><br><span class="line">1,2</span><br><span class="line">3,4,5,6</span><br><span class="line">2,3</span><br><span class="line">6,4,2</span><br><span class="line">8,9</span><br><span class="line">10</span><br><span class="line">输出</span><br><span class="line">12</span><br></pre></td></tr></table></figure> <strong>题解</strong></p><p>输入的所有数据第一列依赖后几列的元素 <img src="https://img-blog.csdnimg.cn/202104161719158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 梳理依赖关系，就能得到包之间影响的对应关系 <img src="https://img-blog.csdnimg.cn/20210416171931616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>通过Integer类型的key和ArrayList类型的value值的map就能存储上面的关系。 然后通过队列queue将包及受影响的包入队，并加入set来统计总和。 <strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4</span></span><br><span class="line"><span class="comment"> * 1,2</span></span><br><span class="line"><span class="comment"> * 3,4,5,6</span></span><br><span class="line"><span class="comment"> * 2,3</span></span><br><span class="line"><span class="comment"> * 6,4,2</span></span><br><span class="line"><span class="comment"> * 8,9</span></span><br><span class="line"><span class="comment"> * 10</span></span><br><span class="line"><span class="comment"> * 输出：12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main04152</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        sc.nextLine();</span><br><span class="line">        HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            String[] s = sc.nextLine().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[s.length];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">                num[i] = Integer.parseInt(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> target = num[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">                <span class="comment">//将后面数字作为key，</span></span><br><span class="line">                <span class="keyword">int</span> key = num[i];</span><br><span class="line">                <span class="comment">//每个key对应一个list</span></span><br><span class="line">                ArrayList&lt;Integer&gt; al = map.getOrDefault(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                al.add(target);</span><br><span class="line">                map.put(key, al);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(helper(map, n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; map, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果map中没有target的key，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(target)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//将每个key对应value中的值加入队列</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        q.offer(target);</span><br><span class="line">        set.add(target);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="comment">//通过不断弹出cur循环找对应的value</span></span><br><span class="line">                <span class="keyword">int</span> cur = q.poll();</span><br><span class="line">                <span class="comment">//如果map中没有对应的，跳过</span></span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(cur)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//相对的value（list）中的值加入set</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m : map.get(cur))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(set.contains(m)) <span class="keyword">continue</span>;</span><br><span class="line">                    q.offer(m);</span><br><span class="line">                    set.add(m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s : set)&#123;</span><br><span class="line">            sum += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意去掉最初加入的target</span></span><br><span class="line">        <span class="keyword">return</span> sum - target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果： <img src="https://img-blog.csdnimg.cn/20210416172541449.png" alt="在这里插入图片描述" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%AC%94%E8%AF%95/">笔试</category>
      
      
      
      <comments>http://example.com/2021/04/16/4%E6%9C%8815%E6%90%BA%E7%A8%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
