<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rui</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>去摘遥不可及的星星</description>
    <pubDate>Sun, 23 May 2021 07:22:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>MySQL存储引擎及其索引实现</title>
      <link>http://example.com/2021/05/23/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E5%85%B6%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/</link>
      <guid>http://example.com/2021/05/23/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E5%85%B6%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Sun, 23 May 2021 07:17:15 GMT</pubDate>
      
      <description>&lt;p&gt;存储引擎指&lt;strong&gt;表&lt;/strong&gt;的类型及表在计算机上的存储方式。&lt;/p&gt;
&lt;p&gt;主要的存储引擎有InnoDB、MyISAM、Memory等。&lt;/p&gt;
&lt;h4 id=&quot;myiasm&quot;&gt;MyIASM&lt;/h4&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>存储引擎指<strong>表</strong>的类型及表在计算机上的存储方式。</p><p>主要的存储引擎有InnoDB、MyISAM、Memory等。</p><h4 id="myiasm">MyIASM</h4><a id="more"></a><h5 id="使用这个存储引擎每个myisam在磁盘上存储三个文件">1、使用这个存储引擎，每个MyISAM在磁盘上存储三个文件。</h5><p>• frm文件：存储表的定义数据</p><p>• MYD文件：存放<strong>表具体记录的数据</strong></p><p>• MYI文件：存储<strong>索引</strong></p><h5 id="特点">2、特点：</h5><ul><li><p>不支持事务，每次查询具有原子性</p></li><li><p>支持表级锁，每次操作对整个表加锁</p></li><li><p>采用<strong>非聚簇索引</strong>，索引文件与数据文件分离。<strong>索引文件的数据域存储指向数据记录的地址</strong>。辅助索引与主键索引基本一致，只是主索引要求key是唯一的，<strong>辅索引的key不用保证唯一性</strong>。</p></li></ul><h5 id="主键索引与辅助索引">3、主键索引与辅助索引</h5><h6 id="主索引">1）主索引</h6><p>先加载MYI文件，其中存放索引，找到对应地址之后，将MYD文件加载到内存，根据刚才得到的地址找到对应行数据，返回给用户。 <img src="https://img-blog.csdnimg.cn/2021052311210883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 上图是MyISAM主键索引，设表一共有三列，假设我们以Col1为主键。</p><h6 id="辅索引">2）辅索引</h6><p>如果在Col2上建立一个辅助索引，如图 <img src="https://img-blog.csdnimg.cn/2021052315003242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 同样data域存放数据记录的地址，但辅助索引的key可以重复。</p><h5 id="总结">总结</h5><p>因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。 MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h4 id="memory">Memory</h4><p>将数据存在内存 - 表级锁</p><ul><li><p>由于数据存在内存中，一旦服务器出现故障，数据都会丢失</p></li><li><p>默认使用hash索引</p></li></ul><h4 id="innodb">InnoDB</h4><p>默认的数据库存储引擎。</p><h5 id="特点-1">1、特点：</h5><ul><li><p>支持事务。默认事务隔离级别为可重复读（RR），通过MVCC实现。</p></li><li><p>支持行级锁，可以支持更高的并发。</p></li><li><p>支持外键约束；外键约束降低了表的查询速度，但增加了表之间的耦合度。</p></li><li><p>存在缓冲管理。通过缓冲池，将索引和数据全部缓存起来，加快查询速度。</p></li><li><p>采用聚簇索引（索引的数据域存储数据文件本身）</p></li></ul><h5 id="主键索引与辅助索引-1">2、主键索引与辅助索引</h5><p>InnoDB也使用B+树作为索引结构，但区别在于<strong>InnoDB的数据文件本身就是索引文件，InnoDB辅助索引的data域存储相应记录主键的值而不是地址。</strong></p><h6 id="主索引-1">1）主索引</h6><p>InnoDB的表数据文件本身就是按B+树组织的一个数据结构，<strong>树节点data域保存完整的数据记录</strong>。这个<strong>索引的key是数据表的主键</strong>，因此InnoDB表数据文件本身就是主索引。 <img src="https://img-blog.csdnimg.cn/20210523150921401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h6 id="辅索引-1">2）辅索引</h6><p>InnoDB的<strong>所有辅助索引都引用主键作为data域</strong>。例如，下图为定义在Col3上的一个辅助索引：</p><p><img src="https://img-blog.csdnimg.cn/20210523151044146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 辅助索引搜索需要检索两遍索引：首先检索<strong>辅助索引获得主键</strong>，然后用主键到<strong>主索引中检索获得数据记录</strong>。</p><h4 id="总结-1">总结</h4><p>InnoDB索引和MyISAM索引的区别：</p><ul><li><p>主索引的区别：InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</p></li><li><p>辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</p></li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQL/">MySQL</category>
      
      
      <category domain="http://example.com/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">存储引擎</category>
      
      <category domain="http://example.com/tags/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/">聚簇索引</category>
      
      
      <comments>http://example.com/2021/05/23/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E5%85%B6%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL索引底层实现</title>
      <link>http://example.com/2021/05/23/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link>
      <guid>http://example.com/2021/05/23/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Sun, 23 May 2021 01:14:45 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;一引入&quot;&gt;一、引入&lt;/h2&gt;
&lt;p&gt;索引的概念：索引是可以快速获取数据的数据结构。&lt;/p&gt;
&lt;p&gt;那么既然是数据结构，用什么数据结构实现呢？&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="一引入">一、引入</h2><p>索引的概念：索引是可以快速获取数据的数据结构。</p><p>那么既然是数据结构，用什么数据结构实现呢？</p><a id="more"></a><p>首先对于下面的表 <img src="https://img-blog.csdnimg.cn/20210522213925115.png" alt="在这里插入图片描述" /> 如果执行语句 <code>select * from t where t.money = 300;</code>，需会全表扫描，一条一条的遍历查询。</p><p><strong>查询一行数据至少和磁盘做一次I/O操作</strong>（I/O是很耗性能的），至少要做 7 次 I/O 操作。</p><h2 id="二索引的数据结构">二、索引的数据结构</h2><h4 id="avl树">1）AVL树</h4><p>那么利用AVL树的特性，将数据划分为两部分，可以降低时间复杂度。</p><p><img src="https://img-blog.csdnimg.cn/20210522214154182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 图示是最好的情况，近似于折半查找，时间复杂度为O(log2n)。但对于特殊数据，组成不平衡的AVL树，退化为顺序查找，效率为O(n)。 <img src="https://img-blog.csdnimg.cn/20210522214322790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h4 id="红黑树">2）红黑树</h4><p><img src="https://img-blog.csdnimg.cn/20210522214502148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 当单边的节点大于3时候，红黑树就会自动调整，这样可以解决二叉树的弊端。</p><p>但是红黑树同样也有弊端：</p><ul><li><p>当数据量特别大的时候，红黑树的高度特别大。</p></li><li><p>有可能查询的数据在叶子节点，那查询的次数也很大，且进行多次磁盘I/O操作，性能差。</p></li></ul><h4 id="b树">3） B树</h4><p><img src="https://img-blog.csdnimg.cn/2021052221511115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" />多路平衡查找树，M阶B树代表每个节点最多可以有M个子节点，所有非叶子节点在同一层。</p><p>B树有以下特点：</p><ul><li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子节点都位于同一层，并且叶子节点只有关键字，指向孩子的指针都为null。</li><li>每个节点都存有索引和数据，也就是对应的key和value。</li></ul><p>B树查找数据的时间复杂度最好为O(1)，即在第一个节点就查到，最差为O(logN)。</p><p>B树的弊端： 若一个节点的空间为16KB，若data中的数据过大，则一个节点能放的数据量较小，这样就会造成树的高度比较大（比红黑树高度小点）</p><h4 id="b树-1">4） B+树</h4><p><img src="https://img-blog.csdnimg.cn/20210522215648927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>B+树与B树的区别：</p><ul><li>B+树的非叶子节点只存储索引，不存储data，可以放更多索引</li><li>叶子节点包含所有索引字段，所有的data元素都存储在叶子节点</li><li><p>叶子节点使用指针连接，对 <code>select * from t where col2 &gt; 20</code> 的范围查找更快速 <img src="https://img-blog.csdnimg.cn/20210522222512889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p></li><li><p>时间复杂度固定为O(logN)</p></li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQL/">MySQL</category>
      
      
      <category domain="http://example.com/tags/%E7%B4%A2%E5%BC%95/">索引</category>
      
      
      <comments>http://example.com/2021/05/23/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux学习—权限、用户、系统指令</title>
      <link>http://example.com/2021/05/22/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9D%83%E9%99%90%E3%80%81%E7%94%A8%E6%88%B7%E3%80%81%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4/</link>
      <guid>http://example.com/2021/05/22/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9D%83%E9%99%90%E3%80%81%E7%94%A8%E6%88%B7%E3%80%81%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4/</guid>
      <pubDate>Sat, 22 May 2021 11:34:12 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;五管理使用者和设立权限的命令&quot;&gt;（五）管理使用者和设立权限的命令&lt;/h3&gt;
&lt;p&gt;执行命令&lt;code&gt;ls -l&lt;/code&gt; 的结果如下： &lt;img src=&quot;https://img-blog.csdnimg.cn/20210522092951254.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一列 10位代表文件类型和权限 第一位 如果是‘d’，代表目录；如果是‘-’，代表文件&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="五管理使用者和设立权限的命令">（五）管理使用者和设立权限的命令</h3><p>执行命令<code>ls -l</code> 的结果如下： <img src="https://img-blog.csdnimg.cn/20210522092951254.png" alt="在这里插入图片描述" /></p><ul><li><p>第一列 10位代表文件类型和权限 第一位 如果是‘d’，代表目录；如果是‘-’，代表文件</p><a id="more"></a><p>后9位每三个一组，第一组表示文件主人的权限；第二组表示文件主人同组成员的权限；第三组表示其他人的权限</p></li><li><p>第三列 代表文件拥有者</p></li><li><p>第四列 代表所属群组</p></li></ul><h6 id="chmod命令">1、chmod命令</h6><ul><li>改变许可权限 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x—文件可以被执行</span><br><span class="line">w—文件可以被写入</span><br><span class="line">r—文件可以被读取</span><br></pre></td></tr></table></figure></li><li>设定文件权限 <code>chmod 文件使用者(u/g/o) 增减(+/-) 权限(x/w/r) 文件</code> u—拥有文件的用户 g—用户所在群组 o—其他人 a—所有 举例： <img src="https://img-blog.csdnimg.cn/20210522095356850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 还可以用数字代替权限，4—w，2—r，1—x 下面两个命令等价： <code>chmod 751 a</code> <code>chmod u=rwx,g=rx,o=x a</code></li></ul><h6 id="useradd与userdel">2、useradd与userdel</h6><p>添加用户、删除用户 <code>useradd [用户名]</code> <code>userdel [参数] [用户名]</code> 参数：-r，删除用户及相关目录，彻底删除</p><h3 id="六用户设置命令">（六）用户设置命令</h3><h6 id="chgrp">1、chgrp</h6><p>用于变更文件或目录的所属群组 <code>chgrp 群组名称 文件名称</code> <img src="https://img-blog.csdnimg.cn/20210522192047136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h6 id="chown">2、chown</h6><p>将文件的拥有者改为指定的用户或组。 <img src="https://img-blog.csdnimg.cn/20210522192254672.png" alt="在这里插入图片描述" /> 举例： <img src="https://img-blog.csdnimg.cn/20210522192315372.png" alt="在这里插入图片描述" /></p><h6 id="su">3、su</h6><p>修改用户。</p><p><code>su 用户名</code> <img src="https://img-blog.csdnimg.cn/20210522192432941.png" alt="在这里插入图片描述" /></p><h3 id="七系统查看指令">（七）系统查看指令</h3><h6 id="exit">1、exit</h6><p>退出。文本模式下使用ctrl+D。</p><h6 id="reboot">2、reboot</h6><p>重新启动。 <img src="https://img-blog.csdnimg.cn/2021052219261529.png" alt="在这里插入图片描述" /></p><h6 id="halt和shutdown">3、halt和shutdown</h6><p>关机。 <img src="https://img-blog.csdnimg.cn/20210522192653797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h6 id="ps">4、ps</h6><p>查看在系统中哪些程序在执行及其执行的情况。（静态查看） <img src="https://img-blog.csdnimg.cn/20210522192806192.png" alt="在这里插入图片描述" /></p><h6 id="top">5、top</h6><p>查看目前程序的执行情景和内存使用。（动态查看） 几秒钟就更新一次系统状态，方便跟踪。</p><h6 id="kill">6、kill</h6><p>终止一个正在执行中的进程。 <code>kill 进程号</code></p><h6 id="date在这里插入图片描述">7.date<img src="https://img-blog.csdnimg.cn/20210522193059760.png" alt="在这里插入图片描述" /></h6><h6 id="cal">8.cal</h6><figure><img src="https://img-blog.csdnimg.cn/20210522193126666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h6 id="df">9.df</h6><p>检查硬盘的使用量</p><h6 id="du">10.du</h6><p>显示文件目录的大小 <code>du 参数 文件名</code></p><h3 id="九网络操作命令">（九）网络操作命令</h3><figure><img src="https://img-blog.csdnimg.cn/20210522193311519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</category>
      
      
      
      <comments>http://example.com/2021/05/22/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9D%83%E9%99%90%E3%80%81%E7%94%A8%E6%88%B7%E3%80%81%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux学习—文件备份、压缩、阅读、定位命令</title>
      <link>http://example.com/2021/05/21/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E3%80%81%E5%8E%8B%E7%BC%A9%E3%80%81%E9%98%85%E8%AF%BB%E3%80%81%E5%AE%9A%E4%BD%8D%E5%91%BD%E4%BB%A4/</link>
      <guid>http://example.com/2021/05/21/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E3%80%81%E5%8E%8B%E7%BC%A9%E3%80%81%E9%98%85%E8%AF%BB%E3%80%81%E5%AE%9A%E4%BD%8D%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Fri, 21 May 2021 01:37:16 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;三文件备份和压缩命令&quot;&gt;（三）、文件备份和压缩命令&lt;/h3&gt;
&lt;h6 id=&quot;bzip2&quot;&gt;1、bzip2&lt;/h6&gt;
&lt;p&gt;将源文件file压缩为file.bz2，压缩后无源文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bzip2 文件名称&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解压：&lt;code&gt;bunzip2 file.bz2&lt;/code&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="三文件备份和压缩命令">（三）、文件备份和压缩命令</h3><h6 id="bzip2">1、bzip2</h6><p>将源文件file压缩为file.bz2，压缩后无源文件</p><p><code>bzip2 文件名称</code></p><p>解压：<code>bunzip2 file.bz2</code></p><a id="more"></a><p>压缩文件 file.bz2 解压为 file，解压后无压缩文件</p><p>可以同时压缩多个文件 <img src="https://img-blog.csdnimg.cn/20210521091538915.png" alt="在这里插入图片描述" /></p><h6 id="gzip">2、gzip</h6><p><code>gzip file</code> <code>gunzip file.gz</code> 与bzip2规则一样 <img src="https://img-blog.csdnimg.cn/20210521091815502.png" alt="在这里插入图片描述" /></p><h6 id="tar">3、tar</h6><p>将文件或目录进行打包或解压缩 <code>tar [参数] [打包后的文件名] [需要打包的文件或目录]</code> 参数包括： <img src="https://img-blog.csdnimg.cn/2021052109214663.png" alt="在这里插入图片描述" /> 常用参数： - 打包：cvf - 解压缩：xvf</p><p>打包后的文件名：file.tar</p><p>举例： <img src="https://img-blog.csdnimg.cn/20210521092340345.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210521092400793.png" alt="在这里插入图片描述" /> 与bzip2、gzip的区别： 打包后不会删除源文件，解压后也不会删除压缩文件</p><h3 id="四文件阅读和定位命令">（四）文件阅读和定位命令</h3><h6 id="head">1、head</h6><p>默认查看文件开头的10行，通过设置可查看前xx行。 <code>head 文件名称</code> <code>head -20 file</code> 查看file的前20行</p><h6 id="tail">2、tail</h6><p>默认查看文件结尾的10行，通过设置可查看结尾的最后xx行。 <code>tail 文件名称</code> <code>tail -20 file</code> 查看file的后20行 有助于查看日志文件的最后10行来阅读重要的系统信息。</p><h6 id="more">3、more</h6><p>按页查看文件内容 <code>more [选项] [文件名称]</code> <img src="https://img-blog.csdnimg.cn/20210521093020319.png" alt="在这里插入图片描述" /> 使用more在文本文件中搜索关键字 <img src="https://img-blog.csdnimg.cn/202105210931181.png" alt="在这里插入图片描述" /> 当一个目录下的文件内容太多，用more来分页显示。与管道 | 结合起来。 <img src="https://img-blog.csdnimg.cn/20210521093212315.png" alt="在这里插入图片描述" /></p><h6 id="which">4、which</h6><p>依序从path环境变量所列的目录中找出命令的位置，并显示完整路径的名称。在找到第一个符合条件的程序文件时，就立刻停止搜索。 <code>which 命令</code></p><h6 id="whereis">5、whereis</h6><p>查找符合条件的文件，定位一些文件在文件系统中的位置。一般用于程序名的搜索。 <img src="https://img-blog.csdnimg.cn/2021052109344331.png" alt="在这里插入图片描述" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</category>
      
      
      <category domain="http://example.com/tags/Linux%E5%91%BD%E4%BB%A4/">Linux命令</category>
      
      
      <comments>http://example.com/2021/05/21/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E3%80%81%E5%8E%8B%E7%BC%A9%E3%80%81%E9%98%85%E8%AF%BB%E3%80%81%E5%AE%9A%E4%BD%8D%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>解锁一道会员题—LeetCode1245</title>
      <link>http://example.com/2021/05/20/%E8%A7%A3%E9%94%81%E4%B8%80%E9%81%93%E4%BC%9A%E5%91%98%E9%A2%98%E2%80%94LeetCode1245/</link>
      <guid>http://example.com/2021/05/20/%E8%A7%A3%E9%94%81%E4%B8%80%E9%81%93%E4%BC%9A%E5%91%98%E9%A2%98%E2%80%94LeetCode1245/</guid>
      <pubDate>Thu, 20 May 2021 09:12:01 GMT</pubDate>
      
      <description>&lt;p&gt;先由一道easy题入手 &lt;a href=&quot;https://leetcode-cn.com/problems/diameter-of-binary-tree/&quot;&gt;LeetCode 543&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>先由一道easy题入手 <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">LeetCode 543</a></p><a id="more"></a><p>二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 对于每个节点，直径即其<strong>左子树和右子树的深度的和</strong>，而对整个树，<strong>这些节点的直径中的最大值</strong>即是树的直径。 方法：采用dfs，建立辅助函数，函数返回值为以当前root节点为根节点的树的深度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历每个节点,此方法返回root为根节点的树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = depth(root.left);<span class="comment">//根节点为root的左子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> r = depth(root.right);<span class="comment">//根节点为root的右子树的深度</span></span><br><span class="line">        ans = Math.max(ans, l + r);<span class="comment">//更新树的直径</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面的铺垫，那看一下主角题目： <img src="https://img-blog.csdnimg.cn/20210513150943989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" />虽然是树，但已经转化为图的题。 任意一个节点的最大直径是<strong>从自身出发的所有路径中最长两条路径长度的和。</strong> 依然采用dfs，则辅助函数返回值为以当前节点root（父节点parent）为起点的路径的最大值。函数中需要维护一个最大长路径max1，和一个次长路径max2。并维护一个res，不断与<code>max1+max2</code> 进行比较，求最大值即为最长直径。</p><p>继续思考： 如果无向图中的路径有值呢？</p><p><img src="https://img-blog.csdnimg.cn/20210513210746152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 题目中给出的是edges关系。还需要建立一个新的Node类，和一个<code>List&lt;Node&gt;[]</code> 邻接表记录节点之间的关系。</p><p>辅助函数依然返回的是当前节点root为起点的一条路径的最长长度。 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *   int start;</span></span><br><span class="line"><span class="comment"> *   int end;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;  <span class="comment">// 邻接点结构</span></span><br><span class="line">        <span class="keyword">int</span> id, dist; <span class="comment">//id表示节点编号，dist表示距离</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> dist)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.dist = dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    List&lt;Node&gt;[] g; <span class="comment">// 保存邻接点</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> n, Interval[] Tree_edge, <span class="keyword">int</span>[] Edge_value)</span> </span>&#123;</span><br><span class="line">        g = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            g[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//每个节点的邻接点和距离值</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = Tree_edge[i].start, y = Tree_edge[i].end;</span><br><span class="line">            g[x].add(<span class="keyword">new</span> Node(y, Edge_value[i]));</span><br><span class="line">            g[y].add(<span class="keyword">new</span> Node(x, Edge_value[i]));</span><br><span class="line"> <span class="comment">//g[0]:Node(1,3) g[1]:Node(0,3),Node(2,2),Node(5,4) g[2]:Node(1,2),Node(3,1),Node(4,5) g[3]:Node(2,1) g4:Node(2,5) g[5]:Node(1,4)</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回当前节点root（父节点为parent）为起点的路径的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">         List&lt;Node&gt; list  = g[root];</span><br><span class="line">        <span class="keyword">int</span> max1 = <span class="number">0</span>; <span class="comment">// 以当前节点为起点的一条最大路径长度</span></span><br><span class="line">        <span class="keyword">int</span> max2 = <span class="number">0</span>; <span class="comment">// 以当前节点为起点的一条次大路径长度</span></span><br><span class="line">        <span class="keyword">for</span>(Node next : list)&#123;</span><br><span class="line">            <span class="comment">//防止走回头路</span></span><br><span class="line">            <span class="keyword">if</span>(next.id != parent)&#123;</span><br><span class="line">                <span class="keyword">int</span> max = dfs(next.id, root) + next.dist;</span><br><span class="line">                <span class="keyword">if</span>(max &gt;= max1)&#123;</span><br><span class="line">                    max2 = max1;</span><br><span class="line">                    max1 = max;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max &gt;= max2)&#123;</span><br><span class="line">                    max2 = max;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// max1+max2得到当前节点最大边长,与返回结果比较，更新最大值</span></span><br><span class="line">                res = Math.max(res, max1 + max2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回当前节点一条路径的最大长度</span></span><br><span class="line">        <span class="keyword">return</span> max1;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/LeetCode%E5%88%B7%E9%A2%98/">LeetCode刷题</category>
      
      
      <category domain="http://example.com/tags/%E5%9B%BE/">图</category>
      
      
      <comments>http://example.com/2021/05/20/%E8%A7%A3%E9%94%81%E4%B8%80%E9%81%93%E4%BC%9A%E5%91%98%E9%A2%98%E2%80%94LeetCode1245/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux学习—概述及对文件目录的操作</title>
      <link>http://example.com/2021/05/20/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C/</link>
      <guid>http://example.com/2021/05/20/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Thu, 20 May 2021 09:08:35 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;Linux的基本思想： 第一，一切都是文件；第二，每个软件都有确定的用途。其中一条详细讲就是系统的所有都可以归结为一个文件，包括命令、硬件和软件设备、操作系统等。 Linux支持多用户，各个用户之间互不影响。Linux可以使多个程序同时并独立地运行。&lt;/p&gt;
&lt;h2 id=&quot;二目录结构和vi编辑器&quot;&gt;二、目录结构和vi编辑器&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="一概述">一、概述</h2><p>Linux的基本思想： 第一，一切都是文件；第二，每个软件都有确定的用途。其中一条详细讲就是系统的所有都可以归结为一个文件，包括命令、硬件和软件设备、操作系统等。 Linux支持多用户，各个用户之间互不影响。Linux可以使多个程序同时并独立地运行。</p><h2 id="二目录结构和vi编辑器">二、目录结构和vi编辑器</h2><a id="more"></a><h3 id="一目录结构">（一）目录结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc：配置文件存放地</span><br><span class="line">&#x2F;home：用户的目录</span><br><span class="line">&#x2F;bin：可执行文件和常用的Linux命令</span><br><span class="line">&#x2F;root：root账户的home目录</span><br></pre></td></tr></table></figure><h3 id="二vi编辑器">（二）vi编辑器</h3><p>格式：<code>vi file_name</code> 功能：生成新文件或编辑、查看文件</p><p>由命令模式进入编辑模式 1）按 i 键，插入文本 2）按 a 键，追加文本</p><p>由编辑模式进入命令模式 按ETC键</p><p>可执行的操作： 1）:w 保存文件 2）:wq 保存并退出 3）:wq! 保存并强制退出</p><h2 id="三linux命令">三、Linux命令</h2><h3 id="一管理文件和目录">（一）管理文件和目录</h3><h6 id="pwd">1、pwd</h6><p>打印用户当前所处路径 <code>[root@localhost~]# pwd</code></p><h6 id="cd">2、cd</h6><p>改变用户所在目录 <code>[root@localhost~]# cd &lt;目录名&gt;</code> <img src="https://img-blog.csdnimg.cn/2021052016503643.png" alt="在这里插入图片描述" /></p><h6 id="ls">3、ls</h6><p>显示指定目录下的内容 <code>ls [参数] [目录或文件]</code> <img src="https://img-blog.csdnimg.cn/20210520165140826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h6 id="cat">4、cat</h6><p>显示文本内容 <code>cat 文本文件名字</code> 举例： <img src="https://img-blog.csdnimg.cn/20210520165308670.png" alt="在这里插入图片描述" /></p><h6 id="touch">5、touch</h6><p>创建文本 <code>touch 文本文件名字</code></p><h6 id="grep">6、grep</h6><p>在一堆文件中查找一个特定的字符串 <code>grep 字符串 文件名</code></p><h6 id="cp">7、cp</h6><p>复制文件，可以目标文件的指定位置 <code>cp 源文件 目标文件</code> 举例： <img src="https://img-blog.csdnimg.cn/20210520165542906.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210520165644469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h3 id="二对文件和目录的操作">（二）对文件和目录的操作</h3><h6 id="mv">1、mv</h6><p>对文件或目录进行移动，还可以进行重命名 <code>mv 源对象 目的对象</code> <img src="https://img-blog.csdnimg.cn/20210520165806502.png" alt="在这里插入图片描述" /> 举例： <img src="https://img-blog.csdnimg.cn/2021052016585269.png" alt="在这里插入图片描述" /><img src="https://img-blog.csdnimg.cn/20210520165904766.png" alt="在这里插入图片描述" /></p><h6 id="mkdir">2、mkdir</h6><p>创建目录 <code>mkdir [目录名1] [目录名2] [目录名3] ...</code> 举例： <img src="https://img-blog.csdnimg.cn/20210520170235301.png" alt="在这里插入图片描述" /></p><p>可以创建嵌套的目录，但只能嵌套一个 <code>mkdir -p aa/bb</code></p><h6 id="rmdir">3、rmdir</h6><p>删除目录 <code>rmdir [参数] [目录名1] [目录名2] ...</code> 可以删除多个嵌套目录 <code>rmdir -p aa/bb/cc</code></p><h6 id="rm">4、rm</h6><p>删除文件 <code>rm [参数] [文件]</code> <img src="https://img-blog.csdnimg.cn/20210520170411209.png" alt="在这里插入图片描述" /> 举例： <img src="https://img-blog.csdnimg.cn/20210520170524601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</category>
      
      
      <category domain="http://example.com/tags/Linux/">Linux</category>
      
      
      <comments>http://example.com/2021/05/20/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据结构面试题</title>
      <link>http://example.com/2021/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <guid>http://example.com/2021/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <pubDate>Thu, 29 Apr 2021 13:54:05 GMT</pubDate>
      
      <description>&lt;p&gt;数据结构是计算机存储、组织数据的方式。对于特定的数据结构(比如数组)，有些操作效率很高(读某个数组元素)，有些操作的效率很低(删除某个数组元素)。程序员的目标是为当前的问题选择最优的数据结构。&lt;/p&gt;
&lt;p&gt;八种常用数据结构：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>数据结构是计算机存储、组织数据的方式。对于特定的数据结构(比如数组)，有些操作效率很高(读某个数组元素)，有些操作的效率很低(删除某个数组元素)。程序员的目标是为当前的问题选择最优的数据结构。</p><p>八种常用数据结构：</p><a id="more"></a><p>一、数组 分为一维数组和多维数组。 优点：查询某个元素比较方便，时间复杂度为O(1)。 缺点：构建时必须分配一段连续的空间，添加和删除元素时间复杂度为O(n)</p><p>二、链表 也是线性结构，是由一系列节点组成的链，每一个节点保存了数据及指向下一节点的指针。 优点：灵活分配内存空间，在O(1)时间内删除或添加元素。 缺点： 查询第k个元素需要O(k)时间。 三、栈 栈中元素采用先进后出，常用操作包括push()、pop()、isEmpty()、peek()。 对于栈中数据来说，所有操作在栈顶完成，只能查看栈顶部的数据，向栈顶压入数据，也只能从栈顶弹出数据。 四、队列 与栈类似，都采用线性结构存储数据。队列采用先进先出。 对于队列的数据来说，只允许在队尾查看和添加数据，在队头查看和删除数据。双端队列的头尾都能在O(1)的时间内进行数据的查看、添加和删除。 五、图 由多个节点组成，节点间可以互相连接组成一个网络。图分为有向图和无向图。 六、树 分层的数据结构，由节点和连接节点的边组成。树是一种特殊的图，与图的区别在于没有循环。 树的节点可以分为根节点、子节点，子节点又包括非叶子节点和叶子节点。 二叉树和二叉查找树是最常用的树。 七、前缀树 与树类似，处理字符串问题非常高效。 八、哈希表</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">面试问题</category>
      
      
      <category domain="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>http://example.com/2021/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>一道阿里面试算法题</title>
      <link>http://example.com/2021/04/18/%E4%B8%80%E9%81%93%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</link>
      <guid>http://example.com/2021/04/18/%E4%B8%80%E9%81%93%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</guid>
      <pubDate>Sun, 18 Apr 2021 01:34:05 GMT</pubDate>
      
      <description>&lt;p&gt;面试过程中出的一道算法题，应该算easy程度吧，面试过程中理解错了，审题很重要！ 题目：给定一串括号，判断是否符合规则，即相应左右括号数量匹配，右括号出现在左括号右面。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>面试过程中出的一道算法题，应该算easy程度吧，面试过程中理解错了，审题很重要！ 题目：给定一串括号，判断是否符合规则，即相应左右括号数量匹配，右括号出现在左括号右面。</p><a id="more"></a><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：([)[]&#123;()&#125;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：)&#123;[(]&#125;)</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&#123;[(]&#125;)</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用map记录每种右括号的数量，遍历字符串，遇到左括号，将相应右括号数量+1；遇到右括号，如果此时value值为0或map还未放入元素，则返回false，否则相应value值-1。最后返回三个value值是否都为0。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 给定一个字符串，判断是否有效</span></span><br><span class="line"><span class="comment"> *（各种括号数量匹配即有效）</span></span><br><span class="line"><span class="comment"> * 输入：([)[]&#123;()&#125; 输出：false</span></span><br><span class="line"><span class="comment"> *      )&#123;[(]&#125;) 输出：true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainAlibaba</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = sc.nextLine();</span><br><span class="line">        System.out.println(helper(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="comment">//遇到左括号相应map的size + 1,遇到右括号-1</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : ch)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                map.put(<span class="string">&#x27;)&#x27;</span>, map.getOrDefault(<span class="string">&#x27;)&#x27;</span>, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                map.put(<span class="string">&#x27;]&#x27;</span>, map.getOrDefault(<span class="string">&#x27;]&#x27;</span>, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                map.put(<span class="string">&#x27;&#125;&#x27;</span>, map.getOrDefault(<span class="string">&#x27;&#125;&#x27;</span>, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.isEmpty() || map.get(<span class="string">&#x27;)&#x27;</span>) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> map.put(<span class="string">&#x27;)&#x27;</span>, map.get(<span class="string">&#x27;)&#x27;</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.isEmpty() || map.get(<span class="string">&#x27;]&#x27;</span>) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> map.put(<span class="string">&#x27;]&#x27;</span>, map.get(<span class="string">&#x27;]&#x27;</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.isEmpty() || map.get(<span class="string">&#x27;&#125;&#x27;</span>) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> map.put(<span class="string">&#x27;&#125;&#x27;</span>, map.get(<span class="string">&#x27;&#125;&#x27;</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(<span class="string">&#x27;)&#x27;</span>) == <span class="number">0</span> &amp;&amp; map.get(<span class="string">&#x27;]&#x27;</span>) == <span class="number">0</span> &amp;&amp; map.get(<span class="string">&#x27;&#125;&#x27;</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">面试问题</category>
      
      
      
      <comments>http://example.com/2021/04/18/%E4%B8%80%E9%81%93%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>4月15携程实习生笔试</title>
      <link>http://example.com/2021/04/16/4%E6%9C%8815%E6%90%BA%E7%A8%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95/</link>
      <guid>http://example.com/2021/04/16/4%E6%9C%8815%E6%90%BA%E7%A8%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95/</guid>
      <pubDate>Fri, 16 Apr 2021 09:34:03 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;第一题-盖房子&quot;&gt;第一题 盖房子&lt;/h2&gt;
&lt;p&gt;第一次在某个点建红房子“R&amp;quot;，之后每次在新房子左边建绿房子&amp;quot;G&amp;quot;，右边建红房子“R&amp;quot;。 输入一个n（1≤n≤12），输出过了n个月房子的排列。 要求： 输入非数字打印“N” 输入数字超出限制，打印“O&amp;quot; 样例： &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出GRR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出GGRRGRR&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="第一题-盖房子">第一题 盖房子</h2><p>第一次在某个点建红房子“R&quot;，之后每次在新房子左边建绿房子&quot;G&quot;，右边建红房子“R&quot;。 输入一个n（1≤n≤12），输出过了n个月房子的排列。 要求： 输入非数字打印“N” 输入数字超出限制，打印“O&quot; 样例： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入1</span><br><span class="line">输出R</span><br><span class="line">输入2</span><br><span class="line">输出GRR</span><br><span class="line">输入3</span><br><span class="line">输出GGRRGRR</span><br></pre></td></tr></table></figure> <a id="more"></a></p><p><strong>题解</strong></p><p>由每次的变化，想到构建二叉树，根节点是&quot;R”，左子节点都是“G&quot;，右子节点都是&quot;R&quot;，最后进行中序遍历得到结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    String val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(String val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main0415</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = sc.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;N&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span> || n &gt; <span class="number">12</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;O&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(createTree(<span class="keyword">new</span> TreeNode(<span class="string">&quot;R&quot;</span>), n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由root构建层数为depth的树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createTree</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(depth == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">         root.left = <span class="keyword">new</span> TreeNode(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">         root.right = <span class="keyword">new</span> TreeNode(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">         createTree(root.left, depth - <span class="number">1</span>);</span><br><span class="line">         createTree(root.right, depth - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历打印结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以做更进一步的简化，使用递归实现树的中序遍历</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main0415</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = sc.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;N&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span> || n &gt; <span class="number">12</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;O&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">System.out.println(helper(n, <span class="keyword">new</span> StringBuilder(<span class="string">&quot;R&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> sb;</span><br><span class="line">        <span class="keyword">return</span> helper(n - <span class="number">1</span>, <span class="keyword">new</span> StringBuilder(<span class="string">&quot;G&quot;</span>)).append(sb).append(helper(n - <span class="number">1</span>, <span class="keyword">new</span> StringBuilder(<span class="string">&quot;R&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题-包依赖问题">第二题 包依赖问题</h2><p>使用正整数表示包，对给定的被修改的包，求出所有受影响的包（去重）所代表数字的和，若无受影响的包则返回-1。直接依赖和间接依赖的包被修改均定义为受影响。 输入说明： 第一行为整数，表示被修改的包。 第二行开始的后续行都是数组，代表数组的第一个元素依赖后续的元素，注意数组元素可能只有1个，代表该包无依赖。 示例： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">4</span><br><span class="line">1,2</span><br><span class="line">3,4,5,6</span><br><span class="line">2,3</span><br><span class="line">6,4,2</span><br><span class="line">8,9</span><br><span class="line">10</span><br><span class="line">输出</span><br><span class="line">12</span><br></pre></td></tr></table></figure> <strong>题解</strong></p><p>输入的所有数据第一列依赖后几列的元素 <img src="https://img-blog.csdnimg.cn/202104161719158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 梳理依赖关系，就能得到包之间影响的对应关系 <img src="https://img-blog.csdnimg.cn/20210416171931616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>通过Integer类型的key和ArrayList类型的value值的map就能存储上面的关系。 然后通过队列queue将包及受影响的包入队，并加入set来统计总和。 <strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4</span></span><br><span class="line"><span class="comment"> * 1,2</span></span><br><span class="line"><span class="comment"> * 3,4,5,6</span></span><br><span class="line"><span class="comment"> * 2,3</span></span><br><span class="line"><span class="comment"> * 6,4,2</span></span><br><span class="line"><span class="comment"> * 8,9</span></span><br><span class="line"><span class="comment"> * 10</span></span><br><span class="line"><span class="comment"> * 输出：12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main04152</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        sc.nextLine();</span><br><span class="line">        HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            String[] s = sc.nextLine().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[s.length];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">                num[i] = Integer.parseInt(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> target = num[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">                <span class="comment">//将后面数字作为key，</span></span><br><span class="line">                <span class="keyword">int</span> key = num[i];</span><br><span class="line">                <span class="comment">//每个key对应一个list</span></span><br><span class="line">                ArrayList&lt;Integer&gt; al = map.getOrDefault(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                al.add(target);</span><br><span class="line">                map.put(key, al);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(helper(map, n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; map, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果map中没有target的key，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(target)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//将每个key对应value中的值加入队列</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        q.offer(target);</span><br><span class="line">        set.add(target);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="comment">//通过不断弹出cur循环找对应的value</span></span><br><span class="line">                <span class="keyword">int</span> cur = q.poll();</span><br><span class="line">                <span class="comment">//如果map中没有对应的，跳过</span></span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(cur)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//相对的value（list）中的值加入set</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m : map.get(cur))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(set.contains(m)) <span class="keyword">continue</span>;</span><br><span class="line">                    q.offer(m);</span><br><span class="line">                    set.add(m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s : set)&#123;</span><br><span class="line">            sum += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意去掉最初加入的target</span></span><br><span class="line">        <span class="keyword">return</span> sum - target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果： <img src="https://img-blog.csdnimg.cn/20210416172541449.png" alt="在这里插入图片描述" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%AC%94%E8%AF%95/">笔试</category>
      
      
      
      <comments>http://example.com/2021/04/16/4%E6%9C%8815%E6%90%BA%E7%A8%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试问题（一）Java集合</title>
      <link>http://example.com/2021/04/15/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89Java%E9%9B%86%E5%90%88/</link>
      <guid>http://example.com/2021/04/15/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89Java%E9%9B%86%E5%90%88/</guid>
      <pubDate>Thu, 15 Apr 2021 09:08:08 GMT</pubDate>
      
      <description>&lt;p&gt;准备了半个多月实习，虽然没有收到一个好结果，但在这个过程中不断总结，觉得还是学会了很多东西，分享一下已经总结过的面试知识点，以后一定还会持续更新！&lt;/p&gt;
&lt;h2 id=&quot;java集合&quot;&gt;Java集合&lt;/h2&gt;
&lt;p&gt;Java集合主要包括两种容器：Collection和Map。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>准备了半个多月实习，虽然没有收到一个好结果，但在这个过程中不断总结，觉得还是学会了很多东西，分享一下已经总结过的面试知识点，以后一定还会持续更新！</p><h2 id="java集合">Java集合</h2><p>Java集合主要包括两种容器：Collection和Map。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。</p><a id="more"></a><h4 id="listsetmap三者的区别">1. List、set、map三者的区别</h4><p>List有序可重复，Set无序不可重复。Map存储键值对，key无序不可重复，value无序可重复。 #### 2. ArrayList和LinkedList的区别 • 从底层结构：ArrayList底层是Object[]数组，LinkedList底层是双向链表。对ArrayList来说，访问元素复杂度为O(1)，插入删除元素复杂度O(n)；对LinkedList，插入删除元素复杂度为O(n)，获取头尾元素复杂度为O(1)。 • 从线程安全：都是不安全的。(Vector线程安全) #### 3. HashMap源码说一下（细说，从初始化到put、get、扩容、红黑树、1.8做了哪些优化） 一、初始化 1.7时，HashMap底层结构为数组+链表，形成链表散列。提供了四个重载的构造方法，初始化参数，主要是initialCapacity 初始容量，默认为16，和load factor负载因子默认为0.75。</p><p>二、put,get操作 table数组，存放Entry对，每个存放元素的位置称为桶。 当put(key,value)时，计算key的hashcode，再通过扰动函数得到hash值，hash &amp; (n - 1)即为桶的索引，也就是存放位置。当此位置没有元素，直接加入；若已有一个或多个元素（链表形式），调用equals()方法，若返回false，直接加入；若返回true，无法加入。 当get(key)时，根据key值计算hash，得到存放的数组索引，遍历对应的Entry对象链表，若有equals()返回true的entry返回value的值；否则，返回空。</p><p>三、扩容 <strong>首先什么时候要扩容呢？</strong> 当超过(load factor * current capacity)，就要进行扩容。比如初始值为16和0.75，意味着最多放12个元素，一旦超过12个，就需要扩容。</p><p><strong>为什么扩容是2的n次幂？</strong> 为了存取高效，减少碰撞，应使每条链表的长度大致相同，采用取模运算，即 hash % length。但取模没有位运算高效，源码中通过 hash &amp; (length-1)来实现。那么length为2的n次幂时，相当于与n个1进行与运算，更加减少碰撞。比如 len=8，2&amp;(len-1)=2，3&amp;(len-1)=3；len=5，2&amp;(len-1)=0，3&amp;(len-1)=0。</p><p>四、红黑树 jdk1.8 底层数据结构为数组+链表/红黑树，当链表长度大于阈值（默认8），且数组长度大于等于64时，会转化成红黑树，否则对数组进行扩容。</p><p>五、1.8优化 • 由数组+链表的结构改为数组+链表+红黑树。 • 简化了hash方法：h^(h&gt;&gt;&gt;16)，原理不变，1.7需要扰动4次。 • 扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。</p><h4 id="hashmap链表要转红黑树为什么阈值为8">4. Hashmap链表要转红黑树，为什么阈值为8？</h4><p>当链表长度大于8且数组长度大于等于64时，要转成红黑树；当红黑树大小为6时又退化成链表。和hashcode碰撞次数的泊松分布有关，主要为了寻找一种时间和空间的平衡。负载因子为0.75时，单个hash桶内元素个数为8的概率已经很小了。将7作为缓冲，等于7时不作转换，大于8时转为红黑树，小于等于6时转为链表。选择8是从概率统计角度选择的。 #### 5. 多线程Put可能发生的问题 当多线程执行put操作，会造成死循环。HashMap不是线程安全的，在并发执行put()时会发生扩容，可能会导致节点丢失，产生环形链表等情况，会导致get()方法出现死循环。 并发时推荐使用ConcurrentHashMap。 #### 6. ConcurrentHashMap的实现 jdk1.7 采用分段锁的思想，将HashMap的数组分割成小数组（Segment），Segment类继承了ReentrantLock（可重入锁）。每个Segment由HashEntry组成，HashEntry用于存储键值对数据。每把锁只锁容器的一部分数据，多线程访问容器里不同数据段的数据，不会存在锁竞争，提高并发访问率。 <img src="https://img-blog.csdnimg.cn/20210415170320962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="加粗样式" /></p><p>jdk1.8 摒弃了Segment分段锁，采用CAS+Sychronized保证并发安全。底层结构与HashMap相同，都是数组+链表/红黑树。Sychronized只锁当前链表或红黑树的首节点，这样只要hash不冲突，就不会产生并发，提高了效率。 <img src="https://img-blog.csdnimg.cn/2021041517034425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h4 id="concurranthashmap和hashtable的区别">7. ConcurrantHashMap和HashTable的区别</h4><p>• 从底层数据结构：HashTable和1.8之前的HashMap类似，采用数组+链表的结构。ConcurrentHashMap在1.7使用Segment数组（包含HashEntry数组）+链表，在1.8与HashMap1.8一样，使用分段数组+链表/红黑树。 • 从线程安全：HashTable使用全表锁，线程安全。ConcurrentHashMap在1.7采用分段锁，每把锁只锁容器的一部分数据，多个线程同时访问不同数据段的数据，提高了并发效率；在1.8使用CAS+Synchronized，Synchronized只锁链表或红黑树的首节点，只要hash不冲突，就不会产生并发安全问题。 #### 8. ConcurrantHashMap的 size如何计算 无论是JDK1.7还是JDK1.8中，ConcurrentHashMap的size()方法都是线程安全的，都是准确的计算出实际的数量，但是这个数据在并发场景下是随时都在变的。 调用size()方法会调用sumCount()方法，map 中键值对的个数通过求 baseCount 与 counterCells 非空元素的和得到。如果没有冲突，只将size的变化写入baseCount。发生冲突就用数组（counterCells）来存储后续size的变化。 #### 9. LinkedHashMap，如何在O(1)的时间里面删除一个元素 LinkedHashMap底层使用双向链表，每个节点包含两个指针：前驱节点和后继节点。删除节点时将前继节点的后继指针指向删除节点的后继节点，将后继节点的前驱指针执行删除节点的前继节点。即实现删除此元素。 HashMap存储的key无序，如果要求key有序，需要使用TreeMap，但选择TreeMap会有性能问题，时间复杂度为O(logn)。而LinkedHashMap可以平衡这些因素，能以O(1)时间复杂度查找元素，又保证key的有序性。 LinkedHashMap提供了两种key的顺序： • 访问顺序，可以实现LRU缓存 • 插入顺序，同一个key多次插入，不影响其顺序 #### 10. HashSet和HashMap的区别 首先HashSet实现了Set接口，HashMap实现了Map接口。 • 从底层数据结构：HashSet底层基于HashMap实现。 • 从线程安全：都不安全 • 从存储对象：HashSet存储无序，不可重复的元素，HashMap存储键值对，key和value都可以为null。 • 从添加元素：HashSet使用add()添加元素，HashMap使用push()方法添加元素。 #### 11. HashTable与hashMap的不同 • 从底层数据结构：HashTable底层为数组+链表，jdk8之后的HashMap在解决哈希冲突时有了较大变化，当链表长度大于8且数组长度大于64时转化为红黑树。HashTable没有这样的机制。 • 从线程安全：HashMap线程不安全，HashTable的实现方法都添加了Synchronized关键字来保证线程安全。 • 对 null key 和 null value的支持：HashMap可以存储null key和null value，但null key只有一个，null作为值可以有多个。HashTable不支持 null key 和 null value。 • 初始容量和扩容机制的不同：HashMap初始容量为16，每次扩为2倍（2次幂是为了减少碰撞）；HashTable初始容量为11，每次扩容为2n + 1。 #### 12. 自定义的类作为HashMap的key需要注意什么？ 需要重写equals()方法和hashcode()方法。 举个例子： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        HashMap&lt;Person, String&gt; map = <span class="keyword">new</span> HashMap&lt;Person, String&gt;();</span><br><span class="line"> </span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;001&quot;</span>), <span class="string">&quot;findingsea&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;002&quot;</span>), <span class="string">&quot;linyin&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;003&quot;</span>), <span class="string">&quot;henrylin&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;003&quot;</span>), <span class="string">&quot;findingsealy&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line"> </span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> Person(<span class="string">&quot;001&quot;</span>)));</span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> Person(<span class="string">&quot;002&quot;</span>)));</span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> Person(<span class="string">&quot;003&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 结果发现，key=new Person(&quot;003&quot;)的键值对添加了两次，获取value值时，输出的是三个null值。 Person 类需要重写equals()方法和hashcode()方法，为了执行put()时比较hashcode值判断是否相等，如果相等，继续调用equals()方法判断是否可以加入。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (id != <span class="keyword">null</span> ? !id.equals(person.id) : person.id != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id != <span class="keyword">null</span> ? id.hashCode() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 重新执行上述的检验程序时，得到的结果如下： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. &#123;Person@ba31&#x3D;findingsea, Person@ba32&#x3D;linyin, Person@ba33&#x3D;findingsealy&#125;</span><br><span class="line">2. findingsea</span><br><span class="line">3. linyin</span><br><span class="line">4. findingsealy</span><br></pre></td></tr></table></figure> #### 13. List遍历时删除元素 主要有以下3种方法： ① 使用Iterator的remove()方法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; platformList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    platformList.add(<span class="string">&quot;博客园&quot;</span>);</span><br><span class="line">    platformList.add(<span class="string">&quot;CSDN&quot;</span>);</span><br><span class="line">    platformList.add(<span class="string">&quot;掘金&quot;</span>);</span><br><span class="line">    Iterator&lt;String&gt; iterator = platformList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        String platform = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (platform.equals(<span class="string">&quot;博客园&quot;</span>)) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(platformList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 注意：使用list.remove()会抛出java.util.ConcurrentModificationException异常。 ② 使用for循环正序遍历 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; platformList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    platformList.add(<span class="string">&quot;博客园&quot;</span>);</span><br><span class="line">    platformList.add(<span class="string">&quot;CSDN&quot;</span>);</span><br><span class="line">    platformList.add(<span class="string">&quot;掘金&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; platformList.size(); i++) &#123;</span><br><span class="line">        String item = platformList.get(i);</span><br><span class="line">        <span class="keyword">if</span> (item.equals(<span class="string">&quot;博客园&quot;</span>)) &#123;</span><br><span class="line">            platformList.remove(i);</span><br><span class="line">            i = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(platformList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 注意删除元素后修正下标的值，防止漏过下一个元素。 删除首个元素后，变为 ③ 使用for循环倒序遍历 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; platformList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    platformList.add(<span class="string">&quot;博客园&quot;</span>);</span><br><span class="line">    platformList.add(<span class="string">&quot;CSDN&quot;</span>);</span><br><span class="line">    platformList.add(<span class="string">&quot;掘金&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = platformList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        String item = platformList.get(i);</span><br><span class="line">        <span class="keyword">if</span> (item.equals(<span class="string">&quot;掘金&quot;</span>)) &#123;</span><br><span class="line">            platformList.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(platformList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">面试问题</category>
      
      
      <category domain="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">面试问题</category>
      
      <category domain="http://example.com/tags/Java/">Java</category>
      
      
      <comments>http://example.com/2021/04/15/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89Java%E9%9B%86%E5%90%88/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
