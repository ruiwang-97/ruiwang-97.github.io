<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rui</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>去摘遥不可及的星星</description>
    <pubDate>Thu, 03 Jun 2021 08:54:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>try-catch-finally执行顺序</title>
      <link>http://example.com/2021/06/03/try-catch-finally%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link>
      <guid>http://example.com/2021/06/03/try-catch-finally%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid>
      <pubDate>Thu, 03 Jun 2021 08:50:42 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;异常处理方式之一：try-catch-finally&quot;&gt;&lt;a href=&quot;#异常处理方式之一：try-catch-finally&quot; class=&quot;headerlink&quot; title=&quot;异常处理方式之一：try-catch-finally&quot;&gt;&lt;/a&gt;异常处理方式之一：try-catch-finally&lt;/h2&gt;&lt;h4 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;headerlink&quot; title=&quot;格式&quot;&gt;&lt;/a&gt;格式&lt;/h4&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="异常处理方式之一：try-catch-finally"><a href="#异常处理方式之一：try-catch-finally" class="headerlink" title="异常处理方式之一：try-catch-finally"></a>异常处理方式之一：try-catch-finally</h2><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名)&#123;</span><br><span class="line"><span class="comment">//处理异常的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名)&#123;</span><br><span class="line"><span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常的方式3</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>try代码块中有异常时，会根据异常类型进入相应的catch。</li></ol><ol><li>finally可选，如果有finally，那finally中的代码一定会执行。</li></ol><p>问题：如果try、catch和finally中都有返回值，会返回什么结果呢？</p><h4 id="test1：没有异常"><a href="#test1：没有异常" class="headerlink" title="test1：没有异常"></a>test1：没有异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Try_catch_Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String res = test();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在try里&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;返回：try&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在catch里&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;返回：catch&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在finally里&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的结果：</p><p><img src="https://img-blog.csdnimg.cn/20210603162329852.png" alt=""></p><p>分析：没有异常所以没有执行catch中的代码，执行顺序是try=&gt;finally=&gt;return；</p><h4 id="test2：发生异常"><a href="#test2：发生异常" class="headerlink" title="test2：发生异常"></a>test2：发生异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Try_catch_Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String res = test();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在try里&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">5</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;返回：try&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在catch里&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;返回：catch&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在finally里&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的结果：</p><p><img src="https://img-blog.csdnimg.cn/20210603164136790.png" alt=""></p><p>分析：在try中发生异常时，没有正常返回，会在catch中捕获异常。执行顺序是try=&gt;catch=&gt;finally=&gt;return；</p><h4 id="test3：finally中有返回"><a href="#test3：finally中有返回" class="headerlink" title="test3：finally中有返回"></a>test3：finally中有返回</h4><p>上面已经分析了不发生异常时不进入catch，finally的语句又一定会执行。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Try_catch_Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String res = test();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在try里&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;返回：try&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在catch里&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;返回：catch&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在finally里&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;返回：finally&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>测试的结果为：</p><p><img src="https://img-blog.csdnimg.cn/20210603164450246.png" alt=""><br>如果发生异常，进入catch，但最终返回的仍是finally语句的结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Try_catch_Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String res = test();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在try里&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">5</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;返回：try&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在catch里&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;返回：catch&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在finally里&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;返回：finally&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的结果为：</p><p><img src="https://img-blog.csdnimg.cn/20210603164550241.png" alt=""></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol><li>try中没有异常时不会执行catch，出现异常时执行顺序为try-catch-finally</li></ol><ol><li>finally中有return语句时，会忽略try、catch中的返回语句，只返回finally的结果。</li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java-SE/">Java SE</category>
      
      
      <category domain="http://example.com/tags/%E5%BC%82%E5%B8%B8/">异常</category>
      
      
      <comments>http://example.com/2021/06/03/try-catch-finally%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MyBatis防止SQL注入</title>
      <link>http://example.com/2021/06/01/MyBatis%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5/</link>
      <guid>http://example.com/2021/06/01/MyBatis%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5/</guid>
      <pubDate>Tue, 01 Jun 2021 08:29:53 GMT</pubDate>
      
      <description>&lt;p&gt;MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。&lt;/p&gt;
&lt;p&gt;动态 sql 是 mybatis 的主要特性之一，在mybatis中我们可以把参数传到xml文件，由mybatis对sql及其语法进行解析，mybatis支持使用${}和#{}。&lt;/p&gt;
&lt;p&gt;那么&lt;code&gt;$&amp;#123;&amp;#125;&lt;/code&gt;和&lt;code&gt;#&amp;#123;&amp;#125;&lt;/code&gt;有什么区别呢？&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><p>动态 sql 是 mybatis 的主要特性之一，在mybatis中我们可以把参数传到xml文件，由mybatis对sql及其语法进行解析，mybatis支持使用${}和#{}。</p><p>那么<code>$&#123;&#125;</code>和<code>#&#123;&#125;</code>有什么区别呢？</p><a id="more"></a><p>mybatis 在<strong>对 sql 语句进行预编译之前，会对 sql 进行动态解析</strong>。</p><h3 id="一">一、<code>#&#123;&#125;</code></h3><p><code>#&#123;&#125;</code>是sql的参数占位符。<code>#&#123;&#125;</code>相当于JDBC中的PreparedStatement，对于传入的参数，在预处理阶段使用 <code>?</code> 代替，真正查询的时候即在数据库管理系统中（DBMS）才代入参数。</p><p>例如：</p><p>mapper.xml中的sql语句: <code>select * from user where name = #&#123;name&#125;;</code> 解析为： <code>select * from user where name = ?;</code> 一个<code>#&#123;&#125;</code>被解析为一个参数占位符 <code>?</code>，不管传入什么参数，打印的sql都是这样的。</p><p>执行时，直接使用编译好的SQL，替换占位符<code>?</code>就可以了。因为<em>SQL注入只能对编译过程起作用</em>，所以这样的方式就很好地避免了SQL注入的问题。</p><h3 id="二">二、<code>$&#123;&#125;</code></h3><p><code>$&#123;&#125;</code>是properties文件中的变量占位符，仅仅为一个纯粹的String替换。</p><p>上面的例子传递参数为 &quot;admin&quot; 时，sql解析为 <code>select * from user where name = &quot;admin&quot;;</code> 预编译之前的 SQL 语句已经不包含变量 name 了。</p><p>如果传递参数为 user;delet user;--，那么sql动态解析阶段之后，预编译之前的sql将变为 <code>select * from user;delete user; -- where name = ?;</code></p><p><code>--</code>之后的语句将作为注释，不起作用，因此本来的一条查询语句偷偷的包含了一个删除表数据的 SQL！</p><h3 id="三总结">三、总结</h3><p>#{}是经过预编译的，是安全的；${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。</p><h3 id="四sql预编译">四、sql预编译</h3><ol type="1"><li>定义</li></ol><p>sql 预编译指的是数据库驱动在发送 sql 语句和参数给 DBMS 之前对 sql 语句进行编译，这样 DBMS 执行 sql 时，就不需要重新编译。</p><ol start="2" type="1"><li>为什么需要预编译</li></ol><p>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。</p><p>1）预编译阶段可以优化 sql 的执行。</p><p>预编译之后的 sql 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的sql，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。</p><p>2）预编译语句对象可以重复利用。</p><p>把一个 sql 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个sql，可以直接使用这个缓存的 PreparedState 对象。</p><p>mybatis 默认情况下，将对所有的 sql 进行预编译。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MyBatis/">MyBatis</category>
      
      
      
      <comments>http://example.com/2021/06/01/MyBatis%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉树的镜像—输入输出处理</title>
      <link>http://example.com/2021/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/</link>
      <guid>http://example.com/2021/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/</guid>
      <pubDate>Fri, 28 May 2021 04:54:38 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/&quot;&gt;剑指 Offer 27. 二叉树的镜像&lt;/a&gt;&lt;br&gt;比较简单，可以采用递归也可以借助栈操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在处理输入时，建立一个TreeNode类，并生成树，镜像之后比较层序遍历结果。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a><br>比较简单，可以采用递归也可以借助栈操作。</p><p><strong>思路</strong></p><p>在处理输入时，建立一个TreeNode类，并生成树，镜像之后比较层序遍历结果。</p><a id="more"></a><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;<span class="keyword">this</span>.val = val;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main0528</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归 此函数的作用是返回以root为根节点的镜像树</span></span><br><span class="line">        <span class="comment">//对于左右子节点，递归调用此函数，再对结果进行交换</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode l = mirrorTree(root.right);</span><br><span class="line">        TreeNode r = mirrorTree(root.left);</span><br><span class="line">        root.left = l;</span><br><span class="line">        root.right = r;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//层序遍历打印树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        TreeNode left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        TreeNode left1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        TreeNode right1 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        TreeNode right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        TreeNode left2 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        TreeNode right2 = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">        root.left = left;</span><br><span class="line">        root.right = right;</span><br><span class="line">        left.left = left1;</span><br><span class="line">        left.right = right1;</span><br><span class="line">        right.left = left2;</span><br><span class="line">        right.right = right2;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = build();</span><br><span class="line">        bfs(root);</span><br><span class="line">        mirrorTree(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        bfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/LeetCode%E5%88%B7%E9%A2%98/">LeetCode刷题</category>
      
      
      <category domain="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</category>
      
      
      <comments>http://example.com/2021/05/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>招银提前批SQL题</title>
      <link>http://example.com/2021/05/27/%E6%8B%9B%E9%93%B6%E6%8F%90%E5%89%8D%E6%89%B9SQL%E9%A2%98/</link>
      <guid>http://example.com/2021/05/27/%E6%8B%9B%E9%93%B6%E6%8F%90%E5%89%8D%E6%89%B9SQL%E9%A2%98/</guid>
      <pubDate>Thu, 27 May 2021 13:23:09 GMT</pubDate>
      
      <description>&lt;p&gt;面试馆出的题很简单，奈何平时练的都是select，好久没用过update和delete了。&lt;/p&gt;
&lt;p&gt;以面养面，继续总结！&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>面试馆出的题很简单，奈何平时练的都是select，好久没用过update和delete了。</p><p>以面养面，继续总结！</p><p>题目：</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20210527211246813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p><p>建表： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> employees;  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (  </span><br><span class="line">     <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">4</span>) primary <span class="keyword">key</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">     <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">     s_x <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">     s_y <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">   ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="number">1001</span>,<span class="string">&#x27;张三&#x27;</span>, <span class="number">3000</span>, <span class="number">5000</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="number">1002</span>,<span class="string">&#x27;李四&#x27;</span>, <span class="number">2000</span>, <span class="number">1000</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees <span class="keyword">VALUES</span> (<span class="number">1003</span>,<span class="string">&#x27;张五&#x27;</span>, <span class="number">4000</span>, <span class="number">1000</span>); </span><br></pre></td></tr></table></figure></p><p>更新语句：<code>update 表名 set 字段 = 新值 where 条件;</code> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> employees <span class="keyword">set</span> salary_x = <span class="number">9000</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&#x27;李四&#x27;</span>;</span><br></pre></td></tr></table></figure> 查询 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">min</span>(s_x + s_y) <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQl/">MySQl</category>
      
      
      
      <comments>http://example.com/2021/05/27/%E6%8B%9B%E9%93%B6%E6%8F%90%E5%89%8D%E6%89%B9SQL%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java多态之左右</title>
      <link>http://example.com/2021/05/26/Java%E5%A4%9A%E6%80%81%E4%B9%8B%E5%B7%A6%E5%8F%B3/</link>
      <guid>http://example.com/2021/05/26/Java%E5%A4%9A%E6%80%81%E4%B9%8B%E5%B7%A6%E5%8F%B3/</guid>
      <pubDate>Wed, 26 May 2021 07:44:30 GMT</pubDate>
      
      <description>&lt;p&gt;学习Java的人都很熟悉多态。&lt;/p&gt;
&lt;p&gt;多态即事物的多种状态，比如人，分男人女人，也可以分学生老师等。&lt;/p&gt;
&lt;p&gt;多态的实现：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>学习Java的人都很熟悉多态。</p><p>多态即事物的多种状态，比如人，分男人女人，也可以分学生老师等。</p><p>多态的实现：</p><a id="more"></a><ul><li>继承（类 / 实现接口）</li><li>重写</li><li>向上转型 所谓向上转型即由子到父。父类引用指向子类对象。<code>Person p = new Student();</code></li></ul><p>那么Person类和Student类有自己的变量和方法，如果子类有重写的方法，或子类没有父类的方法，或父类的方法私有，在编译和运行时都会出现什么情况呢？</p><p>以下面代码为例： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        p.age = <span class="number">14</span>;</span><br><span class="line">        <span class="comment">//p.stuNumber=1;编译不通过</span></span><br><span class="line">        p.eat();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//p.study();编译不通过</span></span><br><span class="line">        p.talk();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//p.test();//编译不通过</span></span><br><span class="line">        p.test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> stuNumber;<span class="comment">//子类有的属性，父类没有</span></span><br><span class="line">    <span class="keyword">int</span> gender;<span class="comment">//0-男</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生也要吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生要学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生也要讲话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> gender;<span class="comment">//0-男</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人要吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人要讲话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有方法不能被重写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我只有父类有哦！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 运行之后的结果：</p><p><img src="https://img-blog.csdnimg.cn/20210526153641647.png" /></p><p>可以总结规律：</p><ol type="1"><li><p>对于成员变量：编译看左边，运行看左边 也就是如果父类中没有子类的变量，编译不通过；子类中也有父类的变量，运行父类的。</p></li><li><p>对于成员方法：编译看左边，运行看右边 父类中没有子类的方法，编译不通过；子类重写了父类的成员方法，运行子类的。</p></li><li><p>对于静态方法：编译看左边，运行看左边 子类重写了父类的静态方法，但还是运行父类的。</p></li></ol><p>再来个例子思考一下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main0520</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();</span><br><span class="line">        a.show();</span><br><span class="line">        B b = <span class="keyword">new</span> C();</span><br><span class="line">        b.show();</span><br><span class="line">        <span class="comment">//成员方法编译看左运行看右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        show2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爱&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 结果是什么呢？</p><p>点个赞再往下拉吧~</p><p>· · ·</p><p>· · ·</p><p>· · ·</p><p>· · ·</p><p>· · · <img src="https://img-blog.csdnimg.cn/20210526154215304.png" alt="在这里插入图片描述" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java-SE/">Java SE</category>
      
      
      <category domain="http://example.com/tags/%E5%A4%9A%E6%80%81/">多态</category>
      
      
      <comments>http://example.com/2021/05/26/Java%E5%A4%9A%E6%80%81%E4%B9%8B%E5%B7%A6%E5%8F%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL-MVCC、当前读、快照读</title>
      <link>http://example.com/2021/05/24/MySQL-MVCC%E3%80%81%E5%BD%93%E5%89%8D%E8%AF%BB%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB/</link>
      <guid>http://example.com/2021/05/24/MySQL-MVCC%E3%80%81%E5%BD%93%E5%89%8D%E8%AF%BB%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB/</guid>
      <pubDate>Mon, 24 May 2021 04:38:40 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;mvcc&quot;&gt;MVCC&lt;/h2&gt;
&lt;p&gt;多版本并发控制，通过保存数据在每个时间点的快照来实现。&lt;/p&gt;
&lt;p&gt;InnoDB的MVCC通过在&lt;strong&gt;每行记录后面保存两个隐藏的列&lt;/strong&gt;来实现，一列保存&lt;strong&gt;行的创建时间&lt;/strong&gt;，一列保存&lt;strong&gt;行的删除时间&lt;/strong&gt;，这个时间指的是系统版本号。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="mvcc">MVCC</h2><p>多版本并发控制，通过保存数据在每个时间点的快照来实现。</p><p>InnoDB的MVCC通过在<strong>每行记录后面保存两个隐藏的列</strong>来实现，一列保存<strong>行的创建时间</strong>，一列保存<strong>行的删除时间</strong>，这个时间指的是系统版本号。</p><a id="more"></a><figure><img src="https://img-blog.csdnimg.cn/20210524122455323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><p>MVCC<strong>只在读已提交（RC）和可重复读（RR）</strong>两个隔离级别下工作。</p><h2 id="快照读">快照读</h2><p>读取记录的可见版本（有可能是历史版本），不用加锁。</p><p>简单的select操作，不包括 <code>select ... lock in share mode</code>，<code>select ... for update</code>。</p><ul><li><p>RC：每次select都生成一个快照读，总是读取已提交的最新数据行</p></li><li><p>RR：第一次select生成快照读，读取上一次的快照</p></li></ul><p>举例： <img src="https://img-blog.csdnimg.cn/2021052412263796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210524122720935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>对于操作的前四行，即只有事务2已提交</p><ul><li><p>读已提交： 未提交的事务id：[1,3] 最大的事务id：3 每一次查询都生成一个快照读，所以事务4的查询结果为29。</p></li><li><p>可重复读： RR第一次查询会生成快照，对一个事务，每次都沿用第一次的快照，直接复制一份之前的快照。 则在RR下，事务4再次查询的结果将会是29，而不是图中RC情况下的30。</p></li></ul><h2 id="当前读">当前读</h2><p>读取的是最新版本，并且对读取的记录加锁。</p><p><code>select...lock in share mode (共享读锁)</code> <code>select...for update</code> <code>update , delete , insert</code></p><p>上面形式都属于当前读。</p><h4 id="当前读的实现方式">当前读的实现方式</h4><p>使用next-key锁(行记录锁+Gap间隙锁)实现 <img src="https://img-blog.csdnimg.cn/20210524212217638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p><h4 id="rr级别怎样防止幻读">RR级别怎样防止幻读？</h4><p>RR级别下只要对 SELECT 操作也手动加行（X）锁即可类似 SERIALIZABLE 级别（它会对 SELECT 隐式加锁） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里需要用 X锁， 用 LOCK IN SHARE MODE 拿到 S锁 后我们没办法做 写操作</span><br><span class="line">SELECT &#96;id&#96; FROM &#96;users&#96; WHERE &#96;id&#96; &#x3D; 1 FOR UPDATE;</span><br></pre></td></tr></table></figure> 如果 id = 1 的记录存在则会被加行（X）锁；如果不存在，则会加 next-key lock/ gap 锁（范围行锁），即记录存在与否，mysql 都会对记录对应的索引加锁，其他事务是无法操作的。 <img src="https://img-blog.csdnimg.cn/20210524212316380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 如图，表t2有主键，score字段有索引idc_scaore，在事务中查询t2表score&lt;80的记录，加了一个S锁（lock in share mode）。 在另一个事务中插入score=74，无法插入成功，因为有gap锁；插入score=90成功，因为不在此区间内。 <img src="https://img-blog.csdnimg.cn/2021052421240962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQL/">MySQL</category>
      
      
      <category domain="http://example.com/tags/MVCC/">MVCC</category>
      
      
      <comments>http://example.com/2021/05/24/MySQL-MVCC%E3%80%81%E5%BD%93%E5%89%8D%E8%AF%BB%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL存储引擎及其索引实现</title>
      <link>http://example.com/2021/05/23/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E5%85%B6%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/</link>
      <guid>http://example.com/2021/05/23/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E5%85%B6%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Sun, 23 May 2021 07:17:15 GMT</pubDate>
      
      <description>&lt;p&gt;存储引擎指&lt;strong&gt;表&lt;/strong&gt;的类型及表在计算机上的存储方式。&lt;/p&gt;
&lt;p&gt;主要的存储引擎有InnoDB、MyISAM、Memory等。&lt;/p&gt;
&lt;h4 id=&quot;myiasm&quot;&gt;MyIASM&lt;/h4&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>存储引擎指<strong>表</strong>的类型及表在计算机上的存储方式。</p><p>主要的存储引擎有InnoDB、MyISAM、Memory等。</p><h4 id="myiasm">MyIASM</h4><a id="more"></a><h5 id="使用这个存储引擎每个myisam在磁盘上存储三个文件">1、使用这个存储引擎，每个MyISAM在磁盘上存储三个文件。</h5><p>• frm文件：存储表的定义数据</p><p>• MYD文件：存放<strong>表具体记录的数据</strong></p><p>• MYI文件：存储<strong>索引</strong></p><h5 id="特点">2、特点：</h5><ul><li><p>不支持事务，每次查询具有原子性</p></li><li><p>支持表级锁，每次操作对整个表加锁</p></li><li><p>采用<strong>非聚簇索引</strong>，索引文件与数据文件分离。<strong>索引文件的数据域存储指向数据记录的地址</strong>。辅助索引与主键索引基本一致，只是主索引要求key是唯一的，<strong>辅索引的key不用保证唯一性</strong>。</p></li></ul><h5 id="主键索引与辅助索引">3、主键索引与辅助索引</h5><h6 id="主索引">1）主索引</h6><p>先加载MYI文件，其中存放索引，找到对应地址之后，将MYD文件加载到内存，根据刚才得到的地址找到对应行数据，返回给用户。 <img src="https://img-blog.csdnimg.cn/2021052311210883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 上图是MyISAM主键索引，设表一共有三列，假设我们以Col1为主键。</p><h6 id="辅索引">2）辅索引</h6><p>如果在Col2上建立一个辅助索引，如图 <img src="https://img-blog.csdnimg.cn/2021052315003242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 同样data域存放数据记录的地址，但辅助索引的key可以重复。</p><h5 id="总结">总结</h5><p>因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。 MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h4 id="memory">Memory</h4><p>将数据存在内存 - 表级锁</p><ul><li><p>由于数据存在内存中，一旦服务器出现故障，数据都会丢失</p></li><li><p>默认使用hash索引</p></li></ul><h4 id="innodb">InnoDB</h4><p>默认的数据库存储引擎。</p><h5 id="特点-1">1、特点：</h5><ul><li><p>支持事务。默认事务隔离级别为可重复读（RR），通过MVCC实现。</p></li><li><p>支持行级锁，可以支持更高的并发。</p></li><li><p>支持外键约束；外键约束降低了表的查询速度，但增加了表之间的耦合度。</p></li><li><p>存在缓冲管理。通过缓冲池，将索引和数据全部缓存起来，加快查询速度。</p></li><li><p>采用聚簇索引（索引的数据域存储数据文件本身）</p></li></ul><h5 id="主键索引与辅助索引-1">2、主键索引与辅助索引</h5><p>InnoDB也使用B+树作为索引结构，但区别在于<strong>InnoDB的数据文件本身就是索引文件，InnoDB辅助索引的data域存储相应记录主键的值而不是地址。</strong></p><h6 id="主索引-1">1）主索引</h6><p>InnoDB的表数据文件本身就是按B+树组织的一个数据结构，<strong>树节点data域保存完整的数据记录</strong>。这个<strong>索引的key是数据表的主键</strong>，因此InnoDB表数据文件本身就是主索引。 <img src="https://img-blog.csdnimg.cn/20210523150921401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h6 id="辅索引-1">2）辅索引</h6><p>InnoDB的<strong>所有辅助索引都引用主键作为data域</strong>。例如，下图为定义在Col3上的一个辅助索引：</p><p><img src="https://img-blog.csdnimg.cn/20210523151044146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 辅助索引搜索需要检索两遍索引：首先检索<strong>辅助索引获得主键</strong>，然后用主键到<strong>主索引中检索获得数据记录</strong>。</p><h4 id="总结-1">总结</h4><p>InnoDB索引和MyISAM索引的区别：</p><ul><li><p>主索引的区别：InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</p></li><li><p>辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</p></li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQL/">MySQL</category>
      
      
      <category domain="http://example.com/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">存储引擎</category>
      
      <category domain="http://example.com/tags/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/">聚簇索引</category>
      
      
      <comments>http://example.com/2021/05/23/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E5%85%B6%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL索引底层实现</title>
      <link>http://example.com/2021/05/23/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link>
      <guid>http://example.com/2021/05/23/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Sun, 23 May 2021 01:14:45 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;一引入&quot;&gt;一、引入&lt;/h2&gt;
&lt;p&gt;索引的概念：索引是可以快速获取数据的数据结构。&lt;/p&gt;
&lt;p&gt;那么既然是数据结构，用什么数据结构实现呢？&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="一引入">一、引入</h2><p>索引的概念：索引是可以快速获取数据的数据结构。</p><p>那么既然是数据结构，用什么数据结构实现呢？</p><a id="more"></a><p>首先对于下面的表 <img src="https://img-blog.csdnimg.cn/20210522213925115.png" alt="在这里插入图片描述" /> 如果执行语句 <code>select * from t where t.money = 300;</code>，需会全表扫描，一条一条的遍历查询。</p><p><strong>查询一行数据至少和磁盘做一次I/O操作</strong>（I/O是很耗性能的），至少要做 7 次 I/O 操作。</p><h2 id="二索引的数据结构">二、索引的数据结构</h2><h4 id="avl树">1）AVL树</h4><p>那么利用AVL树的特性，将数据划分为两部分，可以降低时间复杂度。</p><p><img src="https://img-blog.csdnimg.cn/20210522214154182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 图示是最好的情况，近似于折半查找，时间复杂度为O(log2n)。但对于特殊数据，组成不平衡的AVL树，退化为顺序查找，效率为O(n)。 <img src="https://img-blog.csdnimg.cn/20210522214322790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h4 id="红黑树">2）红黑树</h4><p><img src="https://img-blog.csdnimg.cn/20210522214502148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 当单边的节点大于3时候，红黑树就会自动调整，这样可以解决二叉树的弊端。</p><p>但是红黑树同样也有弊端：</p><ul><li><p>当数据量特别大的时候，红黑树的高度特别大。</p></li><li><p>有可能查询的数据在叶子节点，那查询的次数也很大，且进行多次磁盘I/O操作，性能差。</p></li></ul><h4 id="b树">3） B树</h4><p><img src="https://img-blog.csdnimg.cn/2021052221511115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" />多路平衡查找树，M阶B树代表每个节点最多可以有M个子节点，所有非叶子节点在同一层。</p><p>B树有以下特点：</p><ul><li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子节点都位于同一层，并且叶子节点只有关键字，指向孩子的指针都为null。</li><li>每个节点都存有索引和数据，也就是对应的key和value。</li></ul><p>B树查找数据的时间复杂度最好为O(1)，即在第一个节点就查到，最差为O(logN)。</p><p>B树的弊端： 若一个节点的空间为16KB，若data中的数据过大，则一个节点能放的数据量较小，这样就会造成树的高度比较大（比红黑树高度小点）</p><h4 id="b树-1">4） B+树</h4><p><img src="https://img-blog.csdnimg.cn/20210522215648927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>B+树与B树的区别：</p><ul><li>B+树的非叶子节点只存储索引，不存储data，可以放更多索引</li><li>叶子节点包含所有索引字段，所有的data元素都存储在叶子节点</li><li><p>叶子节点使用指针连接，对 <code>select * from t where col2 &gt; 20</code> 的范围查找更快速 <img src="https://img-blog.csdnimg.cn/20210522222512889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p></li><li><p>时间复杂度固定为O(logN)</p></li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQL/">MySQL</category>
      
      
      <category domain="http://example.com/tags/%E7%B4%A2%E5%BC%95/">索引</category>
      
      
      <comments>http://example.com/2021/05/23/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux学习—权限、用户、系统指令</title>
      <link>http://example.com/2021/05/22/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9D%83%E9%99%90%E3%80%81%E7%94%A8%E6%88%B7%E3%80%81%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4/</link>
      <guid>http://example.com/2021/05/22/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9D%83%E9%99%90%E3%80%81%E7%94%A8%E6%88%B7%E3%80%81%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4/</guid>
      <pubDate>Sat, 22 May 2021 11:34:12 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;五管理使用者和设立权限的命令&quot;&gt;（五）管理使用者和设立权限的命令&lt;/h3&gt;
&lt;p&gt;执行命令&lt;code&gt;ls -l&lt;/code&gt; 的结果如下： &lt;img src=&quot;https://img-blog.csdnimg.cn/20210522092951254.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一列 10位代表文件类型和权限 第一位 如果是‘d’，代表目录；如果是‘-’，代表文件&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="五管理使用者和设立权限的命令">（五）管理使用者和设立权限的命令</h3><p>执行命令<code>ls -l</code> 的结果如下： <img src="https://img-blog.csdnimg.cn/20210522092951254.png" alt="在这里插入图片描述" /></p><ul><li><p>第一列 10位代表文件类型和权限 第一位 如果是‘d’，代表目录；如果是‘-’，代表文件</p><a id="more"></a><p>后9位每三个一组，第一组表示文件主人的权限；第二组表示文件主人同组成员的权限；第三组表示其他人的权限</p></li><li><p>第三列 代表文件拥有者</p></li><li><p>第四列 代表所属群组</p></li></ul><h6 id="chmod命令">1、chmod命令</h6><ul><li>改变许可权限 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x—文件可以被执行</span><br><span class="line">w—文件可以被写入</span><br><span class="line">r—文件可以被读取</span><br></pre></td></tr></table></figure></li><li>设定文件权限 <code>chmod 文件使用者(u/g/o) 增减(+/-) 权限(x/w/r) 文件</code> u—拥有文件的用户 g—用户所在群组 o—其他人 a—所有 举例： <img src="https://img-blog.csdnimg.cn/20210522095356850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 还可以用数字代替权限，4—w，2—r，1—x 下面两个命令等价： <code>chmod 751 a</code> <code>chmod u=rwx,g=rx,o=x a</code></li></ul><h6 id="useradd与userdel">2、useradd与userdel</h6><p>添加用户、删除用户 <code>useradd [用户名]</code> <code>userdel [参数] [用户名]</code> 参数：-r，删除用户及相关目录，彻底删除</p><h3 id="六用户设置命令">（六）用户设置命令</h3><h6 id="chgrp">1、chgrp</h6><p>用于变更文件或目录的所属群组 <code>chgrp 群组名称 文件名称</code> <img src="https://img-blog.csdnimg.cn/20210522192047136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h6 id="chown">2、chown</h6><p>将文件的拥有者改为指定的用户或组。 <img src="https://img-blog.csdnimg.cn/20210522192254672.png" alt="在这里插入图片描述" /> 举例： <img src="https://img-blog.csdnimg.cn/20210522192315372.png" alt="在这里插入图片描述" /></p><h6 id="su">3、su</h6><p>修改用户。</p><p><code>su 用户名</code> <img src="https://img-blog.csdnimg.cn/20210522192432941.png" alt="在这里插入图片描述" /></p><h3 id="七系统查看指令">（七）系统查看指令</h3><h6 id="exit">1、exit</h6><p>退出。文本模式下使用ctrl+D。</p><h6 id="reboot">2、reboot</h6><p>重新启动。 <img src="https://img-blog.csdnimg.cn/2021052219261529.png" alt="在这里插入图片描述" /></p><h6 id="halt和shutdown">3、halt和shutdown</h6><p>关机。 <img src="https://img-blog.csdnimg.cn/20210522192653797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h6 id="ps">4、ps</h6><p>查看在系统中哪些程序在执行及其执行的情况。（静态查看） <img src="https://img-blog.csdnimg.cn/20210522192806192.png" alt="在这里插入图片描述" /></p><h6 id="top">5、top</h6><p>查看目前程序的执行情景和内存使用。（动态查看） 几秒钟就更新一次系统状态，方便跟踪。</p><h6 id="kill">6、kill</h6><p>终止一个正在执行中的进程。 <code>kill 进程号</code></p><h6 id="date在这里插入图片描述">7.date<img src="https://img-blog.csdnimg.cn/20210522193059760.png" alt="在这里插入图片描述" /></h6><h6 id="cal">8.cal</h6><figure><img src="https://img-blog.csdnimg.cn/20210522193126666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h6 id="df">9.df</h6><p>检查硬盘的使用量</p><h6 id="du">10.du</h6><p>显示文件目录的大小 <code>du 参数 文件名</code></p><h3 id="九网络操作命令">（九）网络操作命令</h3><figure><img src="https://img-blog.csdnimg.cn/20210522193311519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</category>
      
      
      
      <comments>http://example.com/2021/05/22/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%9D%83%E9%99%90%E3%80%81%E7%94%A8%E6%88%B7%E3%80%81%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux学习—文件备份、压缩、阅读、定位命令</title>
      <link>http://example.com/2021/05/21/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E3%80%81%E5%8E%8B%E7%BC%A9%E3%80%81%E9%98%85%E8%AF%BB%E3%80%81%E5%AE%9A%E4%BD%8D%E5%91%BD%E4%BB%A4/</link>
      <guid>http://example.com/2021/05/21/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E3%80%81%E5%8E%8B%E7%BC%A9%E3%80%81%E9%98%85%E8%AF%BB%E3%80%81%E5%AE%9A%E4%BD%8D%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Fri, 21 May 2021 01:37:16 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;三文件备份和压缩命令&quot;&gt;（三）、文件备份和压缩命令&lt;/h3&gt;
&lt;h6 id=&quot;bzip2&quot;&gt;1、bzip2&lt;/h6&gt;
&lt;p&gt;将源文件file压缩为file.bz2，压缩后无源文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bzip2 文件名称&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解压：&lt;code&gt;bunzip2 file.bz2&lt;/code&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="三文件备份和压缩命令">（三）、文件备份和压缩命令</h3><h6 id="bzip2">1、bzip2</h6><p>将源文件file压缩为file.bz2，压缩后无源文件</p><p><code>bzip2 文件名称</code></p><p>解压：<code>bunzip2 file.bz2</code></p><a id="more"></a><p>压缩文件 file.bz2 解压为 file，解压后无压缩文件</p><p>可以同时压缩多个文件 <img src="https://img-blog.csdnimg.cn/20210521091538915.png" alt="在这里插入图片描述" /></p><h6 id="gzip">2、gzip</h6><p><code>gzip file</code> <code>gunzip file.gz</code> 与bzip2规则一样 <img src="https://img-blog.csdnimg.cn/20210521091815502.png" alt="在这里插入图片描述" /></p><h6 id="tar">3、tar</h6><p>将文件或目录进行打包或解压缩 <code>tar [参数] [打包后的文件名] [需要打包的文件或目录]</code> 参数包括： <img src="https://img-blog.csdnimg.cn/2021052109214663.png" alt="在这里插入图片描述" /> 常用参数： - 打包：cvf - 解压缩：xvf</p><p>打包后的文件名：file.tar</p><p>举例： <img src="https://img-blog.csdnimg.cn/20210521092340345.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210521092400793.png" alt="在这里插入图片描述" /> 与bzip2、gzip的区别： 打包后不会删除源文件，解压后也不会删除压缩文件</p><h3 id="四文件阅读和定位命令">（四）文件阅读和定位命令</h3><h6 id="head">1、head</h6><p>默认查看文件开头的10行，通过设置可查看前xx行。 <code>head 文件名称</code> <code>head -20 file</code> 查看file的前20行</p><h6 id="tail">2、tail</h6><p>默认查看文件结尾的10行，通过设置可查看结尾的最后xx行。 <code>tail 文件名称</code> <code>tail -20 file</code> 查看file的后20行 有助于查看日志文件的最后10行来阅读重要的系统信息。</p><h6 id="more">3、more</h6><p>按页查看文件内容 <code>more [选项] [文件名称]</code> <img src="https://img-blog.csdnimg.cn/20210521093020319.png" alt="在这里插入图片描述" /> 使用more在文本文件中搜索关键字 <img src="https://img-blog.csdnimg.cn/202105210931181.png" alt="在这里插入图片描述" /> 当一个目录下的文件内容太多，用more来分页显示。与管道 | 结合起来。 <img src="https://img-blog.csdnimg.cn/20210521093212315.png" alt="在这里插入图片描述" /></p><h6 id="which">4、which</h6><p>依序从path环境变量所列的目录中找出命令的位置，并显示完整路径的名称。在找到第一个符合条件的程序文件时，就立刻停止搜索。 <code>which 命令</code></p><h6 id="whereis">5、whereis</h6><p>查找符合条件的文件，定位一些文件在文件系统中的位置。一般用于程序名的搜索。 <img src="https://img-blog.csdnimg.cn/2021052109344331.png" alt="在这里插入图片描述" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</category>
      
      
      <category domain="http://example.com/tags/Linux%E5%91%BD%E4%BB%A4/">Linux命令</category>
      
      
      <comments>http://example.com/2021/05/21/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E3%80%81%E5%8E%8B%E7%BC%A9%E3%80%81%E9%98%85%E8%AF%BB%E3%80%81%E5%AE%9A%E4%BD%8D%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
