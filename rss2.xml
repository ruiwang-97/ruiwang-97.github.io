<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rui</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>去摘遥不可及的星星</description>
    <pubDate>Mon, 08 Mar 2021 11:48:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>狂神MyBatis笔记</title>
      <link>http://example.com/2021/03/08/%E7%8B%82%E7%A5%9EMyBatis%E7%AC%94%E8%AE%B0/</link>
      <guid>http://example.com/2021/03/08/%E7%8B%82%E7%A5%9EMyBatis%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Mon, 08 Mar 2021 11:47:53 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;代码实现&quot;&gt;代码实现&lt;/h2&gt;
&lt;p&gt;数据持久层mapper中只需要接口UserMapper，不需要实现类，而是通过.xml文件的naemespace绑定对应接口。&lt;/p&gt;
&lt;h3 id=&quot;编写代码&quot;&gt;编写代码&lt;/h3&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="代码实现">代码实现</h2><p>数据持久层mapper中只需要接口UserMapper，不需要实现类，而是通过.xml文件的naemespace绑定对应接口。</p><h3 id="编写代码">编写代码</h3><a id="more"></a><ul><li><p>实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String pwd;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Mapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口实现类由原来的...Impl转为一个Mapper配置文件...Mapper.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace = 绑定一个对应的Mapper接口 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 千万不能写错!!!! --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 查询语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 里面的id对应上面接口的方法名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="crud">CRUD</h3><h4 id="namespace">1. namespace</h4><p>namespace中的包名要和mapper接口的包名一致</p><h4 id="selectinsertupdatedelete语句">2. select、insert、update、delete语句</h4><ul><li>id：对应接口的方法名</li><li>parameterType：参数类型</li><li>resultType：Sql语句执行的返回值</li></ul><p>例1：实现根据id查询用户</p><ol type="1"><li><p>Mapper接口中添加方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在UserMapper.xml中添加Select语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 查询语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 里面的id对应上面接口的方法名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据id查询用户，用&#x27;#&#x27;取方法参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from User whele id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>例2：增加用户</p><ol type="1"><li><p>Mapper接口中添加方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//添加用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在UserMapper.xml中添加Select语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 查询语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 里面的id对应上面接口的方法名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据id查询用户，用&#x27;#&#x27;取方法参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from User whele id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插入用户,对象中对属性可以直接取出来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parametertype</span>&quot;<span class="attr">com.wu.pojo.User</span>&quot;&gt;</span></span><br><span class="line">insert into user(id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>例3：修改用户</p><ol type="1"><li><p>Mapper接口中添加方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//添加用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">//修改用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在UserMapper.xml中添加Select语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 查询语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 里面的id对应上面接口的方法名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据id查询用户，用&#x27;#&#x27;取方法参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from User whele id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插入用户,对象中对属性可以直接取出来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parametertype</span>&quot;<span class="attr">com.wu.pojo.User</span>&quot;&gt;</span></span><br><span class="line">insert into user(id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--更新用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">update user set name=#&#123;name&#125;,pwd =#&#123;pwd&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>例4：删除用户</p><ol type="1"><li><p>Mapper接口中添加方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//添加用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">//修改用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">//删除用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在UserMapper.xml中添加Select语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 查询语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 里面的id对应上面接口的方法名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据id查询用户，用&#x27;#&#x27;取方法参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from User whele id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插入用户,对象中对属性可以直接取出来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parametertype</span>&quot;<span class="attr">com.wu.pojo.User</span>&quot;&gt;</span></span><br><span class="line">insert into user(id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--更新用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">update user set name=#&#123;name&#125;,pwd =#&#123;pwd&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--删除用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    delete from user where id =#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="万能map">3. 万能map</h4><p>实体类，或数据库中的表，字段或参数过多，考虑使用Map。</p><ul><li>在 UserMapper 添加接口方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">getUserById2</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>在UserMapper.xml中添加该方法的语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个后面的参数对应map的key，名字可以自己随便取，不要求和实体类一一对应--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">select * from user where id = #&#123;userid&#125; and name =#&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类中测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">map.put(<span class="string">&quot;userid&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">User user = mapper.getUserById2(map);</span><br><span class="line">System.out.println(user);</span><br><span class="line">sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map传递参数，直接在sql中取出key即可！ 【parameter=“map”】</p><p>对象传递参数，直接在sql中取出对象的属性即可！ 【parameter=“Object”】</p><p>只有一个基本类型参数的情况下，可以直接在sql中取到</p><p>多个参数用Map , <strong>或者注解！</strong></p></li></ul><h4 id="模糊查询">4. 模糊查询</h4><ul><li><p>在 UserMapper 添加接口方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserLike</span><span class="params">(String value)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在UserMapper.xml中添加该方法的语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--也可以用concat拼接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList2&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wu.pojo.User&quot;</span>&gt;</span></span><br><span class="line">select * from user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/">SpringBoot学习</category>
      
      
      <category domain="http://example.com/tags/SpringBoot/">SpringBoot</category>
      
      <category domain="http://example.com/tags/MyBatis/">MyBatis</category>
      
      
      <comments>http://example.com/2021/03/08/%E7%8B%82%E7%A5%9EMyBatis%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringBoot员工管理项目</title>
      <link>http://example.com/2021/03/07/SpringBoot%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/</link>
      <guid>http://example.com/2021/03/07/SpringBoot%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/</guid>
      <pubDate>Sun, 07 Mar 2021 08:50:06 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;jdk1.8&lt;/li&gt;
&lt;li&gt;maven 3.3.9&lt;/li&gt;
&lt;li&gt;SpringBoot 2.1.8&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;导入静态资源&quot;&gt;导入静态资源&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/13P_1dRRWxqzdQFG1Y1I3UQ&quot;&gt;百度网盘链接&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="环境准备">环境准备</h2><ul><li>jdk1.8</li><li>maven 3.3.9</li><li>SpringBoot 2.1.8</li></ul><h2 id="导入静态资源">导入静态资源</h2><p><a href="https://pan.baidu.com/s/13P_1dRRWxqzdQFG1Y1I3UQ">百度网盘链接</a></p><a id="more"></a><p>提取码：wrbg</p><p>将asserts目录下的css、img、js等静态资源放置static目录下 <img src="https://img-blog.csdnimg.cn/20210307154859589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 将html静态资源放置templates目录下 <img src="https://img-blog.csdnimg.cn/20210307154922944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="创建项目">创建项目</h2><ul><li>File-New-Project-Spring Initializr快速创建Spring Boot项目，修改Group名，注意Java Version版本的选择为8。</li><li>引入依赖，选择Web-Spring Web，Template Engines-Thymeleaf，Lombok，如图所示。<img src="https://img-blog.csdnimg.cn/20210307153538485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ## 模拟数据库 ### 1. 创建数据库实体类 新建 pojo 包，用来存放实体类</li></ul><p>在 pojo 包下创建一个部门表Department和一个员工表Employee <img src="https://img-blog.csdnimg.cn/20210307155123929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ##### 部门表： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String departmentName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##### 员工表： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Integer gender;<span class="comment">//0:女 1：男</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(Integer id, String lastName, String email, Integer gender, Department department)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.department = department;</span><br><span class="line">        <span class="comment">//默认的创建日期</span></span><br><span class="line">        <span class="keyword">this</span>.birth = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><p>由于导入了lombok依赖，使用@Data注解即可get属性，<span class="citation" data-cites="AllArgsConstructor有参构造">@AllArgsConstructor有参构造</span>，<span class="citation" data-cites="NoArgsConstructor无参构造">@NoArgsConstructor无参构造</span>。</p></blockquote><h3 id="编写dao层">2. 编写Dao层</h3><p>模拟数据库，完成对员工的增删改查任务。 ##### 部门Dao <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟数据库中的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Department&gt; department = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        department = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//创建一个部门表</span></span><br><span class="line"></span><br><span class="line">        department.put(<span class="number">1</span>, <span class="keyword">new</span> Department(<span class="number">1</span>, <span class="string">&quot;市场部&quot;</span>));</span><br><span class="line">        department.put(<span class="number">2</span>, <span class="keyword">new</span> Department(<span class="number">2</span>, <span class="string">&quot;教学部&quot;</span>));</span><br><span class="line">        department.put(<span class="number">3</span>, <span class="keyword">new</span> Department(<span class="number">4</span>, <span class="string">&quot;运营部&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得所有部门信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Department&gt; <span class="title">getDepartment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> department.values();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过id获得部门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartmentById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> department.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##### 员工Dao <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟数据库中的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DepartmentDao departmentDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        employees = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//创建一个部门表</span></span><br><span class="line">employees.put(<span class="number">101</span>, <span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">&quot;张晓明&quot;</span>,<span class="string">&quot;vdx342@qq.com&quot;</span>, <span class="number">1</span>, <span class="keyword">new</span> Department(<span class="number">1</span>, <span class="string">&quot;市场部&quot;</span>)));</span><br><span class="line">        employees.put(<span class="number">102</span>, <span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">&quot;黄校长&quot;</span>, <span class="string">&quot;qas261@162.com&quot;</span>,<span class="number">0</span>, <span class="keyword">new</span> Department(<span class="number">2</span>,<span class="string">&quot;教学部&quot;</span>)));</span><br><span class="line">        employees.put(<span class="number">103</span>, <span class="keyword">new</span> Employee(<span class="number">103</span>,<span class="string">&quot;王例子&quot;</span>, <span class="string">&quot;edf123261@162.com&quot;</span>,<span class="number">0</span>, <span class="keyword">new</span> Department(<span class="number">3</span>,<span class="string">&quot;运营部&quot;</span>)));</span><br><span class="line">        employees.put(<span class="number">104</span>, <span class="keyword">new</span> Employee(<span class="number">104</span>,<span class="string">&quot;安吉拉&quot;</span>, <span class="string">&quot;wd561@162.com&quot;</span>,<span class="number">1</span>, <span class="keyword">new</span> Department(<span class="number">4</span>,<span class="string">&quot;运营部&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主键自增</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer initId = <span class="number">104</span>;</span><br><span class="line">    <span class="comment">//增加一个员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmployee</span><span class="params">(Employee emp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(emp.getId() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            emp.setId(initId++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//emp部门由调用DepartmentDao包中的getDepartmentById()方法得到</span></span><br><span class="line">        emp.setDepartment(departmentDao.getDepartmentById(emp.getDepartment().getId()));</span><br><span class="line">        employees.put(emp.getId(), emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询全部员工信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employees.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过id查询员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpById</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employees.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        employees.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 具体实现</p><h3 id="一-默认访问首页">(一) 默认访问首页</h3><p>在controller类可以使用RequestMapping，浏览器发送 “/” 请求来到 templates 下的 index.html 页面。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&#123;&quot;/&quot;,&quot;/index.html&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样每次都定义一个空方法比较麻烦，在MyMvcConfig 类中写webMvcConfigurer方法使所有组件一起起作用。修改引入的index.html 名为 login.html。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加视图映射</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span></span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/index.html&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">｝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 将html文件其中的语法改为Thymeleaf，所有页面的静态资源都需要使用其接管。注意所有html都需要引入Thymeleaf命名空间。 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">xmlns:th=&quot;http://www.thymeleaf.org&quot;</span><br></pre></td></tr></table></figure> 例如，在 <code>index.html</code> 中 <img src="https://img-blog.csdnimg.cn/20210307160557602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 其他页面亦是如此，再次测试访问，正确显示页面</p><p>在application.properties修改url路径 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/kuang</span></span><br></pre></td></tr></table></figure> 运行，显示首页为 <img src="https://img-blog.csdnimg.cn/20210307162325534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h3 id="二国际化">（二）国际化</h3><h4 id="编写国际化配置文件抽取页面需要显示的国际化消息">1）、编写国际化配置文件，抽取页面需要显示的国际化消息</h4><p>在resources 下新建 i18n 包，包中新建配置文件<code>login.properties</code>和<code>login_en_US.properties</code>，自动生成如下形式： <img src="https://img-blog.csdnimg.cn/20210307161252704.png" alt="在这里插入图片描述" /></p><p>右键选择Add ... 下方 + 添加新语言，输入<code>zh_CN</code> 自动生成 <code>login_zh_CN.properties</code> <img src="https://img-blog.csdnimg.cn/20210307161350762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>在 Settings/Preferences 中找到 File Encodings，选为<strong>UTF8</strong>，并勾选自动转为ascii码。（此次是一个坑，不这样设置后面页面显示会出现乱码。） <img src="https://img-blog.csdnimg.cn/20201216233022753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 添加属性： <img src="https://img-blog.csdnimg.cn/20201217090321556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>配置好的文件如图 <img src="https://img-blog.csdnimg.cn/20210307161441122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210307161455434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210307161509114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h4 id="spring-boot自动配置好了管理国际化资源文件的组件">2）、Spring Boot自动配置好了管理国际化资源文件的组件</h4><p>我们的配置文件可以直接放在类路径下叫messages.properties。现在把配置文件放在i18n下，只需在application.properties下修改包名。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.messages.basename&#x3D;i18n&#x2F;login</span><br></pre></td></tr></table></figure> #### 3）、去页面获取国际化的值（#{})</p><p>在index.html 文件的相应位置用<code>th:**=&quot;#&#123;&#125;&quot;</code>修改 <img src="https://img-blog.csdnimg.cn/20201217201628675.png" alt="在这里插入图片描述" /> 此时显示页面为 <img src="https://img-blog.csdnimg.cn/20201217202555905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 此时，根据浏览器语言设置的信息即可切换中英文显示页面</p><h4 id="点击链接切换国际化">4）、点击链接切换国际化</h4><p>上述实现了登录首页显示为中文，我们在index.html页面中可以看到两个标签</p><p><code>&lt;a class=&quot;btn btn-sm&quot;&gt;中文&lt;/a&gt;</code> <code>&lt;a class=&quot;btn btn-sm&quot;&gt;English&lt;/a&gt;</code> 也就对应着视图中的 <img src="https://img-blog.csdnimg.cn/2021030716202535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 那么我们怎么通过这两个标签实现中英文切换呢?</p><p>首先在这两个标签上加上跳转链接并带上相应的参数 <img src="https://img-blog.csdnimg.cn/2021030716180356.png" alt="在这里插入图片描述" /></p><p>此时点击中文链接，url为 <img src="https://img-blog.csdnimg.cn/20210307162130307.png" alt="在这里插入图片描述" /></p><p>点击英文链接，显示页面为 <img src="https://img-blog.csdnimg.cn/20210307162140863.png" alt="在这里插入图片描述" /></p><p>但还没有实现点击链接切换。</p><p>先分析一下源码，首先搜索WebMvcAutoConfiguration，可以在其中找到关于一个方法 <code>localeResolver()</code> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果用户配置了,则使用用户配置好的</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FixedLocaleResolver(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//用户没有配置,则使用默认的</span></span><br><span class="line">   AcceptHeaderLocaleResolver localeResolver = <span class="keyword">new</span> AcceptHeaderLocaleResolver();</span><br><span class="line">   localeResolver.setDefaultLocale(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">   <span class="keyword">return</span> localeResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 再点开默认地区解析器的AcceptHeaderLocaleResolver对象，点击此类查看源码 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHeaderLocaleContextResolver</span> <span class="keyword">implements</span> <span class="title">LocaleContextResolver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Locale&gt; supportedLocales = <span class="keyword">new</span> ArrayList(<span class="number">4</span>);</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Locale defaultLocale;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcceptHeaderLocaleContextResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 可以发现它继承了LocaleResolver接口，实现了地区解析</p><p>类似地，我们只需要编写一个自己的地区解析器，继承LocaleResolver接口，重写其方法即可。</p><h5 id="编写区域解析器">编写区域解析器</h5><p><img src="https://img-blog.csdnimg.cn/20210307163114219.png" alt="在这里插入图片描述" /> 并重写<code>resolveLocale</code> 方法，对应着index.html 文件中请求参数 l - 如果点击中文按钮，则跳转到/index.html(l='zh_CN')页面 - 如果点击English按钮，则跳转到/index.html(l='en_US')页面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocalResolver</span> <span class="keyword">implements</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析请求</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果获取请求中的语言参数链接，就构造一个自己的</span></span><br><span class="line">        String language = request.getParameter(<span class="string">&quot;l&quot;</span>);<span class="comment">//l对应着index.html文件中的跳转链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(language);</span></span><br><span class="line">        <span class="comment">//如果没有就使用默认</span></span><br><span class="line">        Locale locale = Locale.getDefault();</span><br><span class="line">        <span class="comment">//如果请求的链接携带了国际化参数，就构造一个自己的</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(language))&#123;</span><br><span class="line">            String[] s = language.split(<span class="string">&quot;_&quot;</span>);<span class="comment">//zh_CN</span></span><br><span class="line">            <span class="comment">//国家、地区</span></span><br><span class="line">             locale = <span class="keyword">new</span> Locale(s[<span class="number">0</span>], s[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注入容器">注入容器</h5><p>向容器中注入自定义的国际化组件才能生效</p><p>在<code>MyMvcConfig</code> 中添加代码 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyLocalResolver();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 重启项目即可实现国际化切换！</p><p>点击Engilsh <img src="https://img-blog.csdnimg.cn/20210307163828380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 点击中文<img src="https://img-blog.csdnimg.cn/20210307163856219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/SpringBoot%E5%AD%A6%E4%B9%A0/">SpringBoot学习</category>
      
      
      <category domain="http://example.com/tags/SpringBoot/">SpringBoot</category>
      
      <category domain="http://example.com/tags/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/">员工管理项目</category>
      
      
      <comments>http://example.com/2021/03/07/SpringBoot%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>单调栈的三个问题</title>
      <link>http://example.com/2021/03/03/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/</link>
      <guid>http://example.com/2021/03/03/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Wed, 03 Mar 2021 06:34:13 GMT</pubDate>
      
      <description>&lt;p&gt;一上午做了三道单调栈的问题，算是小摸了一下单调栈的套路，虽然很难想，掌握了规律还是很好做出来的！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/largest-rectangle-in-histogram/&quot;&gt;84，柱状图中最大的矩形，hard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/daily-temperatures/&quot;&gt;739，每日温度，medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water/&quot;&gt;42，接雨水，hard&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>一上午做了三道单调栈的问题，算是小摸了一下单调栈的套路，虽然很难想，掌握了规律还是很好做出来的！</p><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84，柱状图中最大的矩形，hard</a></p><p><a href="https://leetcode-cn.com/problems/daily-temperatures/">739，每日温度，medium</a></p><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42，接雨水，hard</a></p><a id="more"></a><h5 id="柱状图中最大的矩形hard">84，柱状图中最大的矩形，hard</h5><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" /></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" /></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>先考虑暴力解法，也就是对数组的每个高度来说，向左找、向右找到第一个比它小的高度，即可确定矩阵的宽，很容易就得到最大面积。</p><p>但这样时间复杂度比较高，每个元素都要循环两遍，为<em>O</em>(N<sup>2</sup>)，考虑怎么优化呢？</p><p>以空间换时间，对每个元素向后找比它小的，才能计算面积，符合【栈】先进后出的规则。用一个单调栈来记录<strong>下标</strong>（高度可以用下标来表示），这样就能很清楚的确定形成矩形的宽了。</p><p>如果当前的高度比它之前的高度（栈顶元素的高度）严格小于的时候，就可以直接确定以栈顶元素为高的矩形的面积，向左回退的时候，其实就可以当中间这些柱形不存在一样。</p><p>还有一个细节，为了确定数组两端元素的高为矩形的面积，在数组两端添加比 1 小的元素，这样就始终保证栈非空。</p><p>下面图帮助理解</p><p><img src="https://pic.leetcode-cn.com/7e876ae756613053b3432cebc9274e9dbdaafd2e6b8492d37fc34ee98f7655ea-%E5%9B%BE%E7%89%87.png" /></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line"><span class="comment">// //暴力解</span></span><br><span class="line"><span class="comment">//         int res = 0;</span></span><br><span class="line"><span class="comment">//         for(int i = 0; i &lt; heights.length; i++)&#123;</span></span><br><span class="line"><span class="comment">//             int left = i;</span></span><br><span class="line"><span class="comment">//             int right = i;</span></span><br><span class="line"><span class="comment">//             //向左找可以构成矩形的</span></span><br><span class="line"><span class="comment">//             while(left &gt; 0 &amp;&amp; heights[left - 1] &gt;= heights[i])&#123;</span></span><br><span class="line"><span class="comment">//                 left--;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             //向右找可以构成矩形的</span></span><br><span class="line"><span class="comment">//             while(right &lt; heights.length - 1 &amp;&amp; heights[right + 1] &gt;= heights[i])&#123;</span></span><br><span class="line"><span class="comment">//                 right++;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             int width = right - left + 1;</span></span><br><span class="line"><span class="comment">//             res = Math.max(res, width * heights[i]);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//单调栈：将数组左右两侧各加 &lt; 1 的柱子，这样所有元素的左边都比当前柱子小，只需找到右边第一个比当前柱子小的，即可确定以当前高度为高的矩形面积（宽即为左右两边第一个比当前柱子小的两柱子之间距离，左边即为栈顶元素）</span></span><br><span class="line">        <span class="comment">//重构数组</span></span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">2</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        nums[len + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            nums[i] = heights[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单调栈中确定以数组每个元素的高度确定矩形的面积，并维护最大值res</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//当前高度比栈顶高度小即可确定栈顶元素的高度为高的矩形面积</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i] &lt; nums[stack.peekLast()])&#123;</span><br><span class="line">                <span class="comment">//栈顶元素出栈</span></span><br><span class="line">                <span class="keyword">int</span> h = nums[stack.removeLast()];</span><br><span class="line">                <span class="comment">//栈顶元素的高度为高的矩形面积</span></span><br><span class="line">                res = Math.max(res, h * (i - stack.peekLast() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="每日温度medium">739，每日温度，medium</h5><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><p><strong>题解</strong></p><p>首先想到暴力解法，两层for循环，搜索每个元素后面比它大的值，就得到每个元素需要等待的天数。</p><p>此题目的是<u>向右</u>找到比当前索引对应的高度 高 的 第一个柱体，所以需要维护一个递减栈。</p><p>遍历数组元素，当前索引对应的高度比栈顶元素对应高度 大，即弹出栈顶并将索引差记录到结果数组。</p><figure><img src="https://pic.leetcode-cn.com/1614494588-CkmPkk-%E6%A0%88739%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%E6%AD%A3%E5%BA%8F%E5%8A%A8%E7%94%BB1.gif" alt="动画演示" /><figcaption>动画演示</figcaption></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> idx = stack.pop();</span><br><span class="line">                res[idx] = i - idx;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接雨水hard">42，接雨水，hard</h5><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" /></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>依然是遍历到右面不比自己低的柱子时，会形成坑接住雨水。所以采用【单调栈】。</p><p>维护一个递减的单调栈，仍记录下标，栈中每个元素表示接雨水的【左侧柱体】。</p><p>遍历数组元素，当前元素对应高度大于栈顶元素对应高度，则能形成雨水，栈顶元素弹出，并记录其索引，去除栈中元素对应高度重复的元素（为了不重复计算）。计算雨水时，仍然采用高度*宽度，<code>宽度 = 当前遍历索引 - 栈顶索引 - 1</code>；<code>高度 = 两侧柱体取最矮的 - 上面记录的弹出栈的索引对应的高度</code>。因为以记录的柱体作为左侧柱体的雨水已经计算过了！</p><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/dan-diao-zhan-jie-jue-jie-yu-shui-wen-ti-by-sweeti/">可以跟着甜姨的图解理解一下</a></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;        </span><br><span class="line"><span class="keyword">if</span>(height.length == <span class="number">0</span> || height == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peekLast()])&#123;</span><br><span class="line">                <span class="keyword">int</span> popIdx = stack.removeLast();</span><br><span class="line">                <span class="comment">//去除高度重复的栈顶</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[stack.peekLast()] == height[popIdx])&#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//计算雨水面积</span></span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = stack.peekLast();</span><br><span class="line">                    <span class="comment">//雨水面积为 宽*高，宽是当前元素与栈顶元素的距离，高取雨水两边的较矮高度-已经计算过的高度</span></span><br><span class="line">                    res += (i - idx - <span class="number">1</span>) * (Math.min(height[i], height[idx]) - height[popIdx]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>这三道题都可以用单调栈来解，各自也有不同的解法。总的来说，【单调栈】以空间换时间，使暴力解法的左右两次循环变为朝一个方向循环一次。在向左。</p><p>还有一个细节，就是记录下标，而不是将元素值入栈，这是为了方便计算间隔来计算面积，写代码时要提醒自己。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/LeetCode%E5%88%B7%E9%A2%98/">LeetCode刷题</category>
      
      
      <category domain="http://example.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</category>
      
      
      <comments>http://example.com/2021/03/03/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>狂神HTML笔记</title>
      <link>http://example.com/2021/03/02/%E7%8B%82%E7%A5%9EHTML%E7%AC%94%E8%AE%B0/</link>
      <guid>http://example.com/2021/03/02/%E7%8B%82%E7%A5%9EHTML%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Tue, 02 Mar 2021 07:43:34 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;初识html&quot;&gt;1.初识HTML：&lt;/h1&gt;
&lt;figure&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210302152918212.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;
&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="初识html">1.初识HTML：</h1><figure><img src="https://img-blog.csdnimg.cn/20210302152918212.png" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><a id="more"></a><h1 id="元素标签属性内容">2.元素=标签+属性+内容</h1><h3 id="网页基本标签">（1）网页基本标签</h3><ol type="1"><li>标题标签 <code>&lt;h1&gt;一级标签&lt;/h1&gt;</code> <code>&lt;h2&gt;二级标签&lt;/h2&gt;</code></li><li>段落标签 <code>&lt;p&gt;跑得快 跑得快&lt;/p&gt;</code></li><li>水平线标签 <code>&lt;hr/&gt;</code></li><li>换行标签 <code>跑得快 跑得快&lt;br/&gt;</code></li><li>粗体、斜体 <code>&lt;strong&gt;i love u&lt;/strong&gt;</code> <code>&lt;em&gt;i love u&lt;/em&gt;</code></li><li>特殊符号 空格：  <code>空&amp;nbsp;&amp;nbsp; 格</code> 大于：&gt; <code>4 &amp;gt;3</code> 小于：&lt; <code>2 &amp;lt;4</code></li></ol><h3 id="图像标签">（2）图像标签</h3><p><img src="https://img-blog.csdnimg.cn/20210302153014705.png" alt="在这里插入图片描述" /> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--img学习</span></span><br><span class="line"><span class="comment">    src:图片地址，推荐使用相对路径</span></span><br><span class="line"><span class="comment">    ../ ——上一级目录</span></span><br><span class="line"><span class="comment">    alt:图片名字（必填）</span></span><br><span class="line"><span class="comment">    title：鼠标悬停时显示的信息</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../resource/image/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;狂神头像&quot;</span> <span class="attr">title</span>=<span class="string">&quot;悬停&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure> ### （3）超链接标签 <img src="https://img-blog.csdnimg.cn/20210302153042809.png" alt="在这里插入图片描述" /></p><p>href：必填，表示要跳转到哪个页面 target：表示窗口在哪里打开</p><h4 id="a页面间链接">a、页面间链接</h4><p><img src="https://img-blog.csdnimg.cn/20210302153104395.png" alt="在这里插入图片描述" /> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;1.我的第一个网页.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>点我跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure> 图片链接： <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;1.我的第一个网页.html&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../resource/image/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;狂神头像&quot;</span> <span class="attr">title</span>=<span class="string">&quot;悬停&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure> #### b、锚链接 1. 需要一个锚标记 2. 跳转到标记 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--锚标记：top--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span> = <span class="string">&quot;top&quot;</span>&gt;</span>顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用&quot;#&quot;标记 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure> #### c、功能性链接 1. 邮件链接：mailto 3. QQ链接：搜索QQ推广，在推广工具中获取 <img src="https://img-blog.csdnimg.cn/20210302153249536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h3 id="补充块元素和行内元素">【补充】块元素和行内元素</h3><figure><img src="https://img-blog.csdnimg.cn/20210302153428454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h3 id="列表标签">（4）列表标签</h3><p><img src="https://img-blog.csdnimg.cn/20210302153452335.png" /></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--有序列表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>C/C++<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--无序列表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>C/C++<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自定义列表</span></span><br><span class="line"><span class="comment">    dl: 标签</span></span><br><span class="line"><span class="comment">    dt: 列表名称</span></span><br><span class="line"><span class="comment">    dd: 列表内容</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>学科<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>C/C++<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表格标签">（5）表格标签</h3><p><img src="https://img-blog.csdnimg.cn/2021030215354221.png" alt="在这里插入图片描述" /> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--表格 table</span></span><br><span class="line"><span class="comment">    行 tr</span></span><br><span class="line"><span class="comment">    列 td--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第一行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>学生成绩<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第二、三行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>狂神<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第四、五行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>Rui<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure> 效果： <img src="https://img-blog.csdnimg.cn/2021030215361459.png" alt="在这里插入图片描述" /></p><h3 id="媒体元素">（6）媒体元素</h3><figure><img src="https://img-blog.csdnimg.cn/20210302153633166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><h1 id="页面结构">3.页面结构</h1><p><img src="https://img-blog.csdnimg.cn/20210302153706454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> # 4.内联框架： <img src="https://img-blog.csdnimg.cn/20210302153731285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> # 5.初识表单post和get提交： <img src="https://img-blog.csdnimg.cn/20210302153813566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;1.我的第一个网页.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--文本输入框--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--密码框--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure> # 6.表单元素格式： <img src="https://img-blog.csdnimg.cn/20210302153857716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ### （1）文本框和单选框 <img src="https://img-blog.csdnimg.cn/20210302153922502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="文本框：" /> ### （2）按钮和多选框： <img src="https://img-blog.csdnimg.cn/20210302153941380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ### （3）下拉框、文本域和文件域： <img src="https://img-blog.csdnimg.cn/20210302154007639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210302154020877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ### （4）简单验证和滑块： <img src="https://img-blog.csdnimg.cn/20210302154045550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ## 表单的应用 <img src="https://img-blog.csdnimg.cn/20210302154121694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="只读：无法修改 添加readonly" /> ## 表单初级验证 <img src="https://img-blog.csdnimg.cn/20210302154149223.png" alt="输入框默认显示内容" /></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <category domain="http://example.com/tags/html/">html</category>
      
      
      <comments>http://example.com/2021/03/02/%E7%8B%82%E7%A5%9EHTML%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>类变量、成员变量、局部变量存放位置比较</title>
      <link>http://example.com/2021/03/01/%E7%B1%BB%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE%E6%AF%94%E8%BE%83/</link>
      <guid>http://example.com/2021/03/01/%E7%B1%BB%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE%E6%AF%94%E8%BE%83/</guid>
      <pubDate>Mon, 01 Mar 2021 08:08:19 GMT</pubDate>
      
      <description>&lt;p&gt;三种变量易混淆，在学JVM的过程中分不清它们的存放位置，特此梳理比较。&lt;/p&gt;
&lt;p&gt;一、实例变量&lt;/p&gt;
&lt;p&gt;也叫成员变量、全局变量。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>三种变量易混淆，在学JVM的过程中分不清它们的存放位置，特此梳理比较。</p><p>一、实例变量</p><p>也叫成员变量、全局变量。</p><a id="more"></a><ul><li>定义在类中、方法外，有默认初始值。</li><li>通过对象的引用来访问实例变量。</li><li>随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。</li></ul><p>二、类变量</p><p>也叫静态变量。</p><ul><li>定义在类中、方法外，有关键字 static 修饰，有默认初始值。</li><li>可以通过对象调用，也可以通过类名调用。</li><li>生命周期与类共存亡。</li><li>对象的引用存放在<strong>方法区</strong>，如果用关键字 new 为引用类型的静态变量分配对象，该对象在堆中的地址也会存放在方法区。！但是<strong>对象本身仍在堆内存中</strong>。</li></ul><p>三、局部变量</p><ul><li>定义在方法中，或者方法的形参，没有初始化值。</li><li>生命周期与方法共存亡。</li><li>存放在栈中。局部的对象的引用所指对象在堆中的<strong>地址</strong>在存储在了栈中。</li></ul><p>举例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObjTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();<span class="comment">//静态变量、类变量</span></span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();<span class="comment">//实例变量、成员变量</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();<span class="comment">//局部变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>静态变量staticObj 随着Test的类型信息存放在<strong>方法区</strong></li><li>成员变量instance0bj 随着Test的对象实例存放在<strong>Java堆</strong></li><li>局部变量localobj则是存放在foo() 方法栈帧的局部变量表中。</li><li>三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例 即new() 必然会在Java堆中分配。</li></ul><p>再举个例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">PersonDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="comment">//局部变量p和形参args都在main方法的栈帧中</span></span><br><span class="line">        <span class="comment">//new Person()对象在堆中分配空间</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">//sum在栈中，new int[10]在堆中分配空间</span></span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;   <span class="comment">//实例变量name和age在堆(Heap)中分配空间</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//类变量(引用类型)name1和&quot;cn&quot;都在方法区(Method Area)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name1 = <span class="string">&quot;cn&quot;</span>;</span><br><span class="line">    <span class="comment">//类变量(引用类型)name2在方法区(Method Area)</span></span><br><span class="line">    <span class="comment">//new String(&quot;cn&quot;)对象在堆(Heap)中分配空间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name2 = <span class="keyword">new</span> String(<span class="string">&quot;cn&quot;</span>);</span><br><span class="line">    <span class="comment">//num在堆中，new int[10]也在堆中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    Person(String name,<span class="keyword">int</span> age)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//this及形参name、age在构造方法被调用时</span></span><br><span class="line">        <span class="comment">//会在构造方法的栈帧中开辟空间</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//setName()方法在方法区中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//speak()方法在方法区中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;...&quot;</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//showCountry()方法在方法区中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">showCountry</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;country=&quot;</span>+country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面代码中更容易看出区别，这部分还是要多想多记！</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/JVM/">JVM</category>
      
      
      
      <comments>http://example.com/2021/03/01/%E7%B1%BB%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE%E6%AF%94%E8%BE%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode刷题—LRU缓存机制</title>
      <link>http://example.com/2021/02/27/LeetCode%E5%88%B7%E9%A2%98%E2%80%94LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
      <guid>http://example.com/2021/02/27/LeetCode%E5%88%B7%E9%A2%98%E2%80%94LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
      <pubDate>Sat, 27 Feb 2021 03:26:04 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;strong&gt;146，LRU缓存机制，medium&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;LRUCache&lt;/code&gt; 类：&lt;/p&gt;
&lt;p&gt;• &lt;code&gt;LRUCache(int capacity)&lt;/code&gt; 以正整数作为容量 &lt;code&gt;capacity&lt;/code&gt; 初始化 LRU 缓存&lt;/p&gt;
&lt;p&gt;• &lt;code&gt;int get(int key)&lt;/code&gt; 如果关键字 &lt;code&gt;key&lt;/code&gt; 存在于缓存中，则返回关键字的值，否则返回 -1 。&lt;/p&gt;
&lt;p&gt;• &lt;code&gt;void put(int key, int value)&lt;/code&gt; 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。&lt;/p&gt;
&lt;p&gt;进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><strong>146，LRU缓存机制，medium</strong></p><p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。</p><p>实现 <code>LRUCache</code> 类：</p><p>• <code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</p><p>• <code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 -1 。</p><p>• <code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><a id="more"></a><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1&#125;</span><br><span class="line">lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 1</span><br><span class="line">lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    &#x2F;&#x2F; 返回 3</span><br><span class="line">lRUCache.get(4);    &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>LRU 缓存淘汰算法是一种常用策略，认为最近使用的数据是「有用的」，很久没用过的数据是「没用的」，当内存满了就优先删除没用的数据。</p><p>此题需要设计数据结构，首先接收一个 <code>capacity</code> 参数作为缓存的最大容量，然后实现两个 API，一个是 <code>put(key, val)</code> 方法存入键值对，另一个是 <code>get(key)</code> 方法获取 key 对应的 val，如果 key 不存在则返回 -1。</p><p>此数据结构的必要条件： 1. cache 中的元素必须有时序，区分最近使用和久未使用的数据。 2. API 需要快速查找，快速插入，快速删除。</p><p>哈希表能实现快速查找，但无固定顺序。链表有顺序，能实现快速插入和删除，但查找慢。结合一下就形成新的数据结构：哈希链表 LinkedHashMap 。</p><ul><li><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p></li><li><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p></li></ul><p>这样一来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 <code>get</code> 或者 <code>put</code> 操作。具体的方法如下：</p><ul><li>对于 <code>get</code> 操作，首先判断 key 是否存在：<ul><li>如果 key 不存在，则返回−1；</li><li>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</li></ul></li><li>对于 <code>put</code> 操作，首先判断 key 是否存在：<ul><li>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</li><li>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</li></ul></li></ul><p>为什么要用双向链表不用单向链表呢？下面通过代码思考。</p><p>双链表的节点类： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后依靠 Node 类型构建一个双向链表，实现几个LRU算法需要的API： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    <span class="comment">//头尾虚拟节点</span></span><br><span class="line">    Node head;</span><br><span class="line">    Node tail;</span><br><span class="line">    <span class="comment">//元素数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化双向链表</span></span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.next = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加节点到头部</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将节点移至头部</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除链表中最后一个节点，并返回该节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node res = tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 到这里就能回答刚才「为什么必须要用双向链表」的问题了，因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。</p><p>有了双向链表，只需要在LRU算法中把它和哈希表结合起来即可。代码框架： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCahche</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 下面就能实现LRU算法的 <code>get</code> 和 <code>put</code> 方法。在维护链表的同时也要注意 <code>map</code> 中元素的增加、删除。</p><p><code>get</code> 操作较简单：若不存在 key，返回 -1；若存在，将链表中对应节点提至链表头部，再返回对应的value 值。</p><p><code>put</code> 操作较复杂，通过一个流程图来梳理： <img src="https://img-blog.csdnimg.cn/20210227112311467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>到此为止整个算法流程就梳理完了，还有一个问题要思考： 既然哈希表中已经存了 key，为什么链表中还要存 key 和 val 呢，只存 val 不就行了？</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">        <span class="comment">//头尾虚拟节点</span></span><br><span class="line">        Node head;</span><br><span class="line">        Node tail;</span><br><span class="line">        <span class="comment">//元素数量</span></span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//初始化双向链表</span></span><br><span class="line">            head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            head.next = tail;</span><br><span class="line">            tail.next = head;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加节点到头部</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            node.prev = head;</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            head.next.prev = node;</span><br><span class="line">            head.next = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            node.prev.next = node.next;</span><br><span class="line">            node.next.prev = node.prev;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将节点移至头部</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            removeNode(node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除链表中最后一个节点，并返回该节点</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Node res = tail.prev;</span><br><span class="line">            removeNode(res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        <span class="comment">//提至头部</span></span><br><span class="line">        cache.moveToHead(n);</span><br><span class="line">        <span class="keyword">return</span> n.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node n = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="comment">//若key已存在，修改链表中的值并提至头部，修改map中的键值对</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            cache.removeNode(map.get(key));</span><br><span class="line">            cache.moveToHead(n);</span><br><span class="line">            map.put(key, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若key不存在，需要插入n</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//若容量已满，删除尾部最后一个 和map中对应的键值对</span></span><br><span class="line">            <span class="keyword">if</span>(cache.size() == capacity)&#123;</span><br><span class="line">                Node node = cache.removeTail();</span><br><span class="line">                map.remove(node.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向链表头部和map中添加新元素</span></span><br><span class="line">            cache.addToHead(n);</span><br><span class="line">            map.put(key, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>put</code> 方法，可以回答上面的问题。容量满了要删除最后一个久未使用的元素，同时还要将 <code>map</code> 中对应的键删除。如果链表中只存储 <code>value</code>，那么就无法得知 <code>key</code>，就无法删除 <code>map</code> 中对应的键值对。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/LeetCode%E5%88%B7%E9%A2%98/">LeetCode刷题</category>
      
      
      <category domain="http://example.com/tags/LRU/">LRU</category>
      
      
      <comments>http://example.com/2021/02/27/LeetCode%E5%88%B7%E9%A2%98%E2%80%94LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>易错！！String类与常量池</title>
      <link>http://example.com/2021/02/18/%E6%98%93%E9%94%99%EF%BC%81%EF%BC%81String%E7%B1%BB%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%B1%A0/</link>
      <guid>http://example.com/2021/02/18/%E6%98%93%E9%94%99%EF%BC%81%EF%BC%81String%E7%B1%BB%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%B1%A0/</guid>
      <pubDate>Thu, 18 Feb 2021 14:16:02 GMT</pubDate>
      
      <description>&lt;p&gt;一、String对象有两种创建方式：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//第一种&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String str1 = &lt;span class=&quot;string&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//第二种&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String str2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两种方法是有差别的。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>一、String对象有两种创建方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line">String str1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><p>两种方法是有差别的。</p><a id="more"></a><ul><li>第一种方式是在<strong>常量池中取对象</strong>：先检查字符串常量池中有没有&quot;a&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;a&quot;；</li><li>第二种方式是直接在<strong>堆内存空间创建</strong>一个新的对象。</li></ul><p>再如： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str3 = <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure> str1 与 str3 都指向常量池中的 “a”，而 str2 指向堆中新创建的 “a”。 <img src="https://img-blog.csdnimg.cn/20210218215326378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 记住一点：只要<strong>使用 new 方法，便需要创建新的对象。</strong></p><p>二、String 类型的常量池的使用： - 直接使用双引号声明出来的 String 对象会直接存储在常量池中。 - 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中<strong>已经包含一个等于此 String 对象内容的字符串</strong>，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是<strong>在常量池中记录此字符串的引用</strong>，<strong>并返回</strong>该引用。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;计算机&quot;</span>);<span class="comment">//堆</span></span><br><span class="line">String s2 = s1.intern();<span class="comment">//常量池</span></span><br><span class="line">String s3 = <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure> 三、一个小问题</p><p><code>String str = new String(&quot;abc&quot;);</code> 这句话创建了几个字符串对象？ 答：1 或 2 个。如果常量池中已有 “abc”，只在堆空间创建一个 “abc”；如果常量池中没有 “abc”，将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);<span class="comment">// 堆内存的地址值</span></span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">// 输出 true，内容相同</span></span><br></pre></td></tr></table></figure> 四、字符串拼接</p><p>常量池中的对象可以直接拼接成一个新的字符串。两个字符串拼接的结果在堆中。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str4 = str1 + str2; <span class="comment">//在堆上创建的新的对象      </span></span><br><span class="line">String str5 = <span class="string">&quot;string&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure> <img src="https://img-blog.csdnimg.cn/20210218221413161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>五、扩展：Integer 类 与 常量池</p><p>Integer 类默认创建数值[-128，127] 的相应类型的缓存数据。 1. <code>Integer i1=40；</code> Java 在编译的时候会直接将代码封装成 <code>Integer i1=Integer.valueOf(40);</code>，从而使用常量池中的对象。 2. <code>Integer i1 = new Integer(40);</code> 这种情况下会创建新的对象。</p><p>一个例子: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));     </span><br></pre></td></tr></table></figure> 结果： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i1&#x3D;i2   true</span><br><span class="line">i1&#x3D;i2+i3   true</span><br><span class="line">i1&#x3D;i4   false</span><br><span class="line">i4&#x3D;i5   false</span><br><span class="line">i4&#x3D;i5+i6   true</span><br><span class="line">40&#x3D;i5+i6   true</span><br></pre></td></tr></table></figure> 解释：</p><p>语句 i4 == i5 + i6，因为 + 这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行<strong>自动拆箱</strong>操作，进行数值相加，即 i4 == 40。然后 <strong>Integer 对象无法与数值进行直接比较</strong>，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java-SE/">Java SE</category>
      
      
      <category domain="http://example.com/tags/JVM/">JVM</category>
      
      
      <comments>http://example.com/2021/02/18/%E6%98%93%E9%94%99%EF%BC%81%EF%BC%81String%E7%B1%BB%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%B1%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode刷题—双指针解数组排序</title>
      <link>http://example.com/2021/02/17/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</link>
      <guid>http://example.com/2021/02/17/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</guid>
      <pubDate>Wed, 17 Feb 2021 03:01:57 GMT</pubDate>
      
      <description>&lt;h5 id=&quot;前言&quot;&gt;前言&lt;/h5&gt;
&lt;p&gt;双指针分为快慢指针（向一个方向遍历）和左右指针（从两个方向相对遍历）， 在进行数组排序时常用到第一种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指针 j 用于探路，找到目标元素&lt;/strong&gt;与指针 i 所指元素交换，并将 i 向前一步，继续。&lt;/p&gt;
&lt;h5 id=&quot;模板&quot;&gt;模板&lt;/h5&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h5 id="前言">前言</h5><p>双指针分为快慢指针（向一个方向遍历）和左右指针（从两个方向相对遍历）， 在进行数组排序时常用到第一种。</p><p><strong>指针 j 用于探路，找到目标元素</strong>与指针 i 所指元素交换，并将 i 向前一步，继续。</p><h5 id="模板">模板</h5><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="comment">//j 指针探路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(找到目标元素)&#123;</span><br><span class="line">                <span class="comment">//交换</span></span><br><span class="line">                swap(A, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="按奇偶排序数组easy">905，按奇偶排序数组，easy</h5><p>给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。</p><p>你可以返回满足此条件的任何数组作为答案。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,1,2,4]</span><br><span class="line">输出：[2,4,3,1]</span><br><span class="line">（输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。）</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>此题目标是用 指针j 找到偶数元素，将偶数元素往前提。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">//找到偶数元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(A, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移动-0easy">283，移动 0，easy</h5><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>此题目标是用 指针j 找到非 0 元素，将非 0 元素往前提。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            <span class="comment">//找到非 0 元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] != <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="颜色分类medium">75，颜色分类，medium</h5><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,0,1]</span><br><span class="line">输出：[0,1,2]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>与前两题不同在 需要两次交换，先用 指针j 找到 0，将 0 往前提。</p><p>再将 j 定于此位置，继续找 1，将 1 往前提。</p><p>过程如下：</p><p><img src="https://img-blog.csdnimg.cn/20210217113417103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" /></p><p><a href="https://pic.leetcode-cn.com/4ff01311844f58b83124a449e24857e9d02fd6c04067e9551fda6bccbe59b87e-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%94%B9%E5%8F%98.gif">动画演示</a></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//第一步：将 0 往前提</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二步：将 1 往前提</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == <span class="number">1</span>)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/LeetCode%E5%88%B7%E9%A2%98/">LeetCode刷题</category>
      
      
      <category domain="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/">双指针</category>
      
      
      <comments>http://example.com/2021/02/17/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode刷题—岛屿问题</title>
      <link>http://example.com/2021/02/16/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</link>
      <guid>http://example.com/2021/02/16/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 16 Feb 2021 09:48:47 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个二维矩阵从某个点开始向四周扩展，直到无法再扩展为止。&lt;/p&gt;
&lt;p&gt;矩阵，可以抽象为一幅「图」，这就是⼀个图的遍历问题，也就类似⼀个 N 叉树遍历的问题。几行代码就能解决，直接上框架吧：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><strong>思路</strong></p><p>一个二维矩阵从某个点开始向四周扩展，直到无法再扩展为止。</p><p>矩阵，可以抽象为一幅「图」，这就是⼀个图的遍历问题，也就类似⼀个 N 叉树遍历的问题。几行代码就能解决，直接上框架吧：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (x, y) 为坐标位置 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">fill(x - <span class="number">1</span>, y); <span class="comment">// 上 </span></span><br><span class="line"></span><br><span class="line">fill(x + <span class="number">1</span>, y); <span class="comment">// 下 </span></span><br><span class="line"></span><br><span class="line">fill(x, y - <span class="number">1</span>); <span class="comment">// 左 </span></span><br><span class="line"></span><br><span class="line">fill(x, y + <span class="number">1</span>); <span class="comment">// 右 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个框架可以解决所有在二维矩阵中遍历的问题，说得高端点，这就叫深度优先搜索（Depth First Search，简称 <strong>DFS</strong>），说得简单点，这就叫四叉树遍历框架。坐标 (x, y) 就是 root，四个方向就是 root 的四个子节点。</p><p><strong>DFS模板</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line"><span class="comment">//dfs出口，不满足条件就退出</span></span><br><span class="line"><span class="keyword">if</span>(结束条件)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;    </span><br><span class="line">    操作</span><br><span class="line"><span class="comment">//递归，接着进一步DFS</span></span><br><span class="line">    dfs(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="图像渲染easy">733，图像渲染，easy</h5><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p><p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p><p>从初始坐标开始，记录初始坐标的<u>上下左右</u>四个方向上像素值<u>与初始坐标相同</u>的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。<u>将所有有记录的像素点的颜色值改为新的颜色值</u>。</p><p>最后返回经过上色渲染后的图像。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">输出: [[2,2,2],[2,2,0],[2,0,1]]</span><br></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/20210216174746701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解析: </span><br><span class="line">在图像的正中间，(坐标(sr,sc)&#x3D;(1,1)),</span><br><span class="line">在路径上所有符合条件的像素点的颜色都被更改成2。</span><br><span class="line">注意，右下角的像素没有更改为2，</span><br><span class="line">因为它不是在上下左右四个方向上与初始点相连的像素点。</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>从起始点开始，搜索四个方向</p><ul><li><p>如果这个方向越界且不需要渲染，结束搜索。</p></li><li><p>否则，继续从这个方向搜索它的上下左右。</p></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;      </span><br><span class="line">        <span class="comment">//如果新颜色与原来相同，不需更改</span></span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] == newColor) <span class="keyword">return</span> image;</span><br><span class="line">        </span><br><span class="line">        dfs(image, sr, sc, newColor, image[sr][sc]);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor, <span class="keyword">int</span> oldColor)</span></span>&#123;</span><br><span class="line">        <span class="comment">//出口：不在合法范围内 或 此位置与初始颜色不同</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidArea(image, sr, sc) || image[sr][sc] != oldColor) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//操作</span></span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        dfs(image, sr - <span class="number">1</span>, sc, newColor, oldColor);</span><br><span class="line">        dfs(image, sr + <span class="number">1</span>, sc, newColor, oldColor);</span><br><span class="line">        dfs(image, sr, sc - <span class="number">1</span>, newColor, oldColor);</span><br><span class="line">        dfs(image, sr, sc + <span class="number">1</span>, newColor, oldColor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合法：不处于边界之外</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidArea</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sr &lt; <span class="number">0</span> || sr &gt;= image.length || sc &lt; <span class="number">0</span> || sc &gt;= image[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="岛屿数量medium">200，岛屿数量，medium</h5><p>给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>本题的目标是得到“岛屿数量”，上下左右相连的 <code>1</code> 都被认为是连续岛屿。</p><p>总体思路：遍历地图，找到一个陆地（' 1 '），采用 dfs 向 上下左右 四个方向搜索，同时“岛屿数量” + 1。</p><p>dfs 流程：</p><ul><li><p>结束条件：不在合法范围内 或 不是陆地</p></li><li><p>操作：避免重复遍历，网格的dfs 会重复向四个方向找，可能重复遍历节点。</p><pre><code>         将已遍历过的陆地标记为 &#39;2&#39;</code></pre></li><li><p>递归：搜索上下左右的节点</p></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从 一个陆地 ‘1’向四个方向遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isValidArea(grid, r, c) || grid[r][c] != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//标记已遍历过的陆地</span></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidArea</span><span class="params">(<span class="keyword">char</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sr &lt; <span class="number">0</span> || sr &gt;= image.length || sc &lt; <span class="number">0</span> || sc &gt;= image[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="岛屿的最大面积medium">695，岛屿的最大面积，medium</h5><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中<strong>最大的岛屿面积</strong>。(如果没有岛屿，则返回面积为 0 。)</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>和上面思路一致，根据题目对结果进行修改。</p><p>题目目标是得到最大岛屿面积，在 dfs 过程中求出每个岛屿的面积，在主函数中得到最大的一个。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> a = dfs(grid, i, j);</span><br><span class="line">                    res = Math.max(a, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r ,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isValidArea(grid, r, c) || grid[r][c] != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//标记已遍历过的陆地</span></span><br><span class="line">        grid[r][c] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(grid, r - <span class="number">1</span>, c) + dfs(grid, r + <span class="number">1</span>, c) + dfs(grid, r, c - <span class="number">1</span>) + dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidArea</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sr &lt; <span class="number">0</span> || sr &gt;= image.length || sc &lt; <span class="number">0</span> || sc &gt;= image[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="岛屿的周长easy">463，岛屿的周长，easy</h5><p>给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。</p><p>网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p>示例 1：</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/6fd1a8c57dc7f3800628577ad6fc650f.png" alt="img" /><figcaption>img</figcaption></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]</span><br><span class="line">输出：16</span><br><span class="line">解释：它的周长是上面图片中的 16 个黄色的边</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>岛屿的周长是计算岛屿全部的「边缘」，而这些边缘就是我们在 DFS 遍历中，dfs 函数返回的位置。</p><p>可以将岛屿的周长中的边分为两类，如下图所示。黄色的边是与网格边界相邻的周长，而蓝色的边是与海洋格子相邻的周长。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/e84efa198ef108951ef340cc712e5aa0.png" alt="将岛屿周长中的边分为两类" /><figcaption>将岛屿周长中的边分为两类</figcaption></figure><p>dfs 函数直接返回有这几种情况：</p><ul><li><code>!inArea(grid, r, c)</code>，即坐标 (r, c) 超出了网格的范围，也就是「先污染后治理」的情况</li><li><code>grid[r][c] != 1</code>，即当前格子不是岛屿格子，这又分为两种情况：<ul><li><code>grid[r][c] == 0</code>，当前格子是海洋格子</li><li><code>grid[r][c] == 2</code>，当前格子是已遍历的陆地格子</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                   <span class="keyword">return</span> dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从 一个陆地 ‘1’向四个方向遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">//蓝色边界</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidArea(grid, r, c)) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//黄色边界</span></span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前格子是已遍历的陆地格子,和周长没关系</span></span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//标记已遍历过的陆地</span></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(grid, r - <span class="number">1</span>, c) + dfs(grid, r + <span class="number">1</span>, c) + dfs(grid, r, c - <span class="number">1</span>) + dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidArea</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sr &lt; <span class="number">0</span> || sr &gt;= image.length || sc &lt; <span class="number">0</span> || sc &gt;= image[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>更简单的写法：遍历每一个空格，遇到岛屿，计算其上下左右的情况，遇到水域或者出界的情况，就可以计算边了。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//4个方向</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> r = i + directions[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> c = j + directions[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= grid.length || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].length || grid[r][c] == <span class="number">0</span>) res++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/LeetCode%E5%88%B7%E9%A2%98/">LeetCode刷题</category>
      
      
      <category domain="http://example.com/tags/dfs/">dfs</category>
      
      
      <comments>http://example.com/2021/02/16/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode刷题—回溯算法</title>
      <link>http://example.com/2021/02/15/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
      <guid>http://example.com/2021/02/15/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
      <pubDate>Mon, 15 Feb 2021 08:10:05 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;回溯算法&quot;&gt;回溯算法&lt;/h2&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;「回溯是递归的副产品，只要有递归就会有回溯」&lt;/strong&gt;，所以回溯法也经常和二叉树遍历，深度优先遍历（&lt;span class=&quot;math inline&quot;&gt;\(dfs\)&lt;/span&gt;）混在一起，因为这两种方式都是用了递归。&lt;/p&gt;
&lt;p&gt;回溯法就是暴力搜索，优化回溯算法只有&lt;strong&gt;「剪枝」&lt;/strong&gt;一种方法。&lt;/p&gt;
&lt;p&gt;回溯算法能解决如下问题：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="回溯算法">回溯算法</h2><h3 id="前言">前言</h3><p><strong>「回溯是递归的副产品，只要有递归就会有回溯」</strong>，所以回溯法也经常和二叉树遍历，深度优先遍历（<span class="math inline">\(dfs\)</span>）混在一起，因为这两种方式都是用了递归。</p><p>回溯法就是暴力搜索，优化回溯算法只有<strong>「剪枝」</strong>一种方法。</p><p>回溯算法能解决如下问题：</p><a id="more"></a><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。你只需要思考 3 个问题：</p><p><strong>1、路径</strong>：也就是已经做出的选择。</p><p><strong>2、选择列表</strong>：也就是你当前可以做的选择。</p><p><strong>3、结束条件</strong>：也就是到达决策树底层，无法再做选择的条件。</p><p>代码的框架：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = [];<span class="comment">//结果集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(路径，选择列表)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (结束条件) &#123;</span><br><span class="line">        result.add(路径)；<span class="comment">//存放结果</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        做选择;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」。</strong></p><p>使用两个变量： res 和 path，res 表示<strong>最终的结果</strong>，path 保存<strong>已走过的路径</strong>。当满足结束条件，即<u>到达了决策树的底层</u>，就把 path 放到 res 中。</p><p>此总结参考于 labuladong的算法小抄 和 代码随想录。</p><h3 id="组合问题">组合问题</h3><h5 id="组合medium">77，组合，medium</h5><p>给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>n 相当于 树的宽度， k 相当于 树的高度。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/b15fff1a94206fa74dfd68dba60da8b9.png" alt="Image" /><figcaption>Image</figcaption></figure><p>由上面框架，选择一个数就填入路径集<code>path</code>，结束条件：路径集<code>path</code>大小 = k。</p><p>在每层递归如何选择数呢？需要变量 <code>index</code> 记录下一层递归的起始位置，<code>index + 1 ~ n</code>即为下层递归的选择列表。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        backtrack(n, k, <span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> index, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//横向遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt;= n ; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtrack(n, k, i + <span class="number">1</span>, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还可以进行优化，会将效率提高不少。若 <code>n = 5, k = 4</code>，现在 <code>path.size() = 1</code>，那还需 <code>k - path.size() = 3</code> 个数。若 <code>index = 4</code>，则只能选取 5，不满足，故 i 有限制条件。<code>i &lt;= n - (k - path.size()) + 1</code>，即在集合n中至多要从该起始位置 : <code>n - (k - path.size()) + 1</code>开始遍历。</p><h4 id="组合总和"><strong>组合总和</strong></h4><h5 id="组合总和medium">216，组合总和Ⅲ，medium</h5><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><p>所有数字都是正整数。 解集不能包含重复的组合。 示例 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>借鉴上一题的思路，组合中的数字为 1~9，则从1 开始分层遍历，结束条件即为 和为 n 且 <code>path.size() = k</code>。选择操作：将 i 添入路径，并加入和sum 中，撤销操作反之。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        backtracking(n, k, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, List&lt;Integer&gt; path, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == n &amp;&amp; path.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt;= <span class="number">9</span> ; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backtracking(n, k, path, i + <span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="组合总和medium-1">39，组合总和，medium</h5><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><p>所有数字（包括 target）都是正整数。 解集不能包含重复的组合。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= <code>candidates.length</code> &lt;= 30 1 &lt;= candidates[i] &lt;= 200 candidate 中的每个元素都是独一无二的。 1 &lt;= target &lt;= 500</p><p><strong>题解</strong></p><p>题意：在无重复元素的数组中可重复选取元素使其和为target，结果集中的数组不重复。</p><p>此题的难点在于不产生重复组合。</p><p>错误：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">    backtracking(i,...);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用 <code>index</code>，最后结果会有重复数组，如 [[2,2,3],[2,3,2],[3,2,2],[7]] 。</p><p>解决：仍需要 index，以使下一次选择的起点在当前选择的基础上，这样就不会选到本次选择同层左边的数。</p><figure><img src="https://img-blog.csdnimg.cn/20210215160501659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><p>正确：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.length; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">    backtracking(index,...);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>规律</strong>：若只在一个集合中选取组合，需要开始索引 <code>index</code>，如此题和上面两题。</p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用 <code>index</code>，如 17。</p><p>结束条件： <code>sum == target</code> 时填入路径，<code>sum &gt; target</code> 时舍弃。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/3fb042b5dcc8a9f74b94662b441a4914.png" alt="Image" /><figcaption>Image</figcaption></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            backtracking(candidates, target, i, path);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="组合总和medium-2">40，组合总和Ⅱ，medium</h5><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><p>所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>与39题比较：</p><p>39题 数组元素无重复，可重复选取，解集无重复</p><p>40题 数组元素有重复，不可重复选取，解集无重复</p><p>关键在于<strong>「去重」</strong>，对此题构成的树，从上而下的同一树枝可以有重复元素，同一树层之间不可以有重复元素。如数组[1,1,2]（为方便理解已排序），target = 3 时构成的树如图</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/fe56789ddce344a4a4c330191f845290.png" alt="Image" /><figcaption>Image</figcaption></figure><p>那么怎么区分树层的重复元素和树枝的重复元素呢？</p><p>使用boolean 数组 <code>used</code>，初始化为false，当选取元素改为true。</p><p>首先对数组进行排序，若相邻元素相等且前一元素已被<strong>同一树层</strong>使用过，跳过。代码表示为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">continue</span>;  </span><br></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/7bed7dc8842cad57af368e34732c0b05.png" alt="Image" /><figcaption>Image</figcaption></figure><p>在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：</p><ul><li>used[i - 1] == true，说明同一<strong>树支</strong>candidates[i - 1]使用过</li><li>used[i - 1] == false，说明同一<strong>树层</strong>candidates[i - 1]使用过</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;             <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[candidates.length];</span><br><span class="line">        Arrays.fill(used, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//先排序使相同元素处于相邻位置</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.length ; i++)&#123;</span><br><span class="line">            <span class="comment">//同一树层不可以重复</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">continue</span>;   </span><br><span class="line">            </span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i]; </span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtracking(candidates, target, i + <span class="number">1</span>, path, used);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多个集合求组合">多个集合求组合</h4><h5 id="电话号码的字母组合medium">17，电话号码的字母组合，medium</h5><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt="img" style="zoom:80%;" /></p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits &#x3D; &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits &#x3D; &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits &#x3D; &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>与上面题目不同，本题是在多个集合中找组合，不需要开始索引 index。</p><p>此题需要注意的地方有很多：</p><ul><li><p>数字与字母的映射——可以用数组或Map</p></li><li><p>结束条件怎么表示？用 <code>idx</code> 表示遍历到digits 的数字索引（即树的深度），当 <code>idx == digits.length()</code> 时，结束。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/b1b653f788c9024244727b6d2f8f6988.png" alt="Image" /><figcaption>Image</figcaption></figure></li><li><p>怎么选择？对 每个数字<code>digit</code> 对应的字母集<code>letter</code> 进行遍历，选择 <code>letter</code> 中的字母。</p></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String[] str = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;<span class="comment">//0-9对应字母集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backtracking(digits, <span class="keyword">new</span> StringBuffer(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String digits, StringBuffer path, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == digits.length())&#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> digit = digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>;     <span class="comment">// 将index指向的&#x27;数字&#x27;转为int</span></span><br><span class="line">        String letter = str[digit]; <span class="comment">// 第 index 个数字对应的字母集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letter.length(); i++)&#123;</span><br><span class="line">            path.append(letter.charAt(i));<span class="comment">//选择</span></span><br><span class="line">            backtracking(digits, path, idx + <span class="number">1</span>);  <span class="comment">//对下一层处理</span></span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);   <span class="comment">//撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>细节</strong></p><ul><li><code>StringBuffer</code> 与 String 加入字母的区别：</li></ul><p>因为<code>StringBuffer</code>传入的都是同一个对象，所以在递归完成之后必须撤回上一次的操作，需要删除上一次添加的字符。而String每次改变之后传入的都是不同的对象。故无需撤销操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; letters.length() ; i ++)&#123;</span><br><span class="line">backtracking(digits, index + <span class="number">1</span>, s + letters.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>int 与 char 类型的转换</p><p>char 不能直接转为int，得到是‘3’的<code>Ascii</code>，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> numChar = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> intNum = (<span class="keyword">int</span>)numChar;</span><br><span class="line">    System.out.println(numChar + <span class="string">&quot;: &quot;</span> + intNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3：51</span><br></pre></td></tr></table></figure><p>char 转为 int 的正确方法是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> numChar = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> intNum = numChar - ‘<span class="number">0</span>’;</span><br><span class="line">    System.out.println(numChar + <span class="string">&quot;: &quot;</span> + intNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3：3</span><br></pre></td></tr></table></figure><p>而 int 可以强转为 char</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">char</span> b = (<span class="keyword">char</span>)a; <span class="comment">//b = &#x27;9&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="子集问题">子集问题</h3><h5 id="子集medium">78，子集，medium</h5><p>给你一个整数数组 <code>nums</code> ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= <code>nums.length</code> &lt;= 10 -10 &lt;= <code>nums[i]</code> &lt;= 10 <code>nums</code> 中的所有元素 互不相同</p><p><strong>题解</strong></p><p>与上面组合问题不同在于<strong>「子集」</strong>是这棵树的所有节点，而不是只有叶子节点。</p><p>解中不含重复子集，则<strong>取过的元素不会重复取</strong>，for 循环的开始索引 <code>index</code>，而不是 0。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/c6a0773ead22e31d8482e76a08275fa9.png" alt="Image" /><figcaption>Image</figcaption></figure><p>那结束条件是什么呢？可以不需要加终止条件，因为<code>index &gt;= nums.size()</code>，本层for循环本来也结束了。</p><p><strong>「求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树」</strong>。</p><p>根据上面的模板有</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        backtracking(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不需结束条件</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="子集medium-1">90，子集Ⅱ，medium</h5><p>给定一个可能包含重复元素的整数数组 <code>nums</code>，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>与 78 题的区别：</p><ul><li>78题 —— 数组不含重复元素，解不含重复子集。</li><li>90题 —— 数组含重复元素，解不含重复子集。</li></ul><p>此题与 40题 类似，解题思路也一致。</p><p>同一树层不能取相同元素（否则解中的子集会重复），而同一树枝可以有相同元素。</p><p>使用boolean数组 <code>used</code> ，初始化为false，当选取元素改为true。</p><p>首先对数组进行<strong>排序</strong>，若相邻元素相等且前一元素已被同一树层使用过，跳过。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/a388616952b76a18a2463b2dc667537a.png" alt="Image" /><figcaption>Image</figcaption></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracking(nums, <span class="number">0</span>, used, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">boolean</span>[] used, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>, used, path);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="递增子序列medium">491，递增子序列，medium</h5><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4, 6, 7, 7]</span><br><span class="line">输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>首先判断 此题的<strong>「去重」</strong>与 40、90题不同，上面的做法是将数组先排序再去重，防止同一层的相同元素重复使用，使解中出现重复子集。但此题要求递增子序列，不可打乱顺序。</p><p>采用 <strong><code>HashSet</code></strong> 去重，记录同层使用过的元素。</p><p>如果当前元素在 set 中有重复元素，则跳过。</p><p>那怎么保证递增呢？</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/da35e130f6e7e7fc10ccbb196613288d.png" alt="Image" /><figcaption>Image</figcaption></figure><p>如果当前元素 小于 上一个选取的元素，则跳过。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        backtracking(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="comment">//注意此处没有return</span></span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//当同层有相同元素已经在set中，或要加入的nums[i] &lt; 上一个加入的元素时</span></span><br><span class="line">            <span class="keyword">if</span>(!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="number">1</span>) || set.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>细节</strong></p><p>set 定义在递归函数上面，为了确保本层不选取重复元素。新的一层 set 都会重新定义（清空），所以要知道 set 只负责本层！</p><p>因为递增序列中至少两个元素，所以 <code>path.size() &gt; 1</code> 才添加到 res 中，注意<strong>不能写 return</strong>，因为要记录树的所有节点。</p><p>添加 return 返回的结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[4,7],[4,6],[7,7],[6,7]]</span><br></pre></td></tr></table></figure><h4 id="小总结">小总结</h4><p>如果给定数组中包含重复元素 / 组合和子集问题中要求<strong>解中不含重复结果</strong> / 在一个集合中找组合，就需要开始索引 <code>idx</code> 对同层元素去重。（77，39，216，40）</p><p>子集问题不需要剪枝，因为要返回所有可能集合。不需要return。</p><h3 id="切割问题">切割问题</h3><h5 id="分割回文串medium">131，分割回文串，medium</h5><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>不能重复截取，所以仍需要 <code>idx</code>。</p><ul><li>结束条件：分割线到字符串末尾，将path填入 res 中。</li><li>选择：如果当前形成的字符串<code>[idx,i]</code> 不是回文串，跳过。是则进行递归。 <img src="https://img-blog.csdnimg.cn/20210214165327228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        backtracking(<span class="keyword">new</span> ArrayList&lt;String&gt;(), s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;String&gt; path, String s, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历完成</span></span><br><span class="line">        <span class="keyword">if</span>(idx == s.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt; s.length(); i++)&#123;</span><br><span class="line">             <span class="comment">//子串 [idx,i]</span></span><br><span class="line">            String str = s.substring(idx, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果不是回文，跳过</span></span><br><span class="line">            <span class="keyword">if</span>(!isPalindrome(str))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;         </span><br><span class="line">            path.add(str);</span><br><span class="line">            backtracking(path, s, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是不是回文字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(left) != str.charAt(right))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排列问题">排列问题</h3><h5 id="全排列medium">46，全排列，medium</h5><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><ul><li><p>不需要idx：解中的组合是有序的，例如：在同一树层已经选择了 1，下一次选择还可以选 1，即 [2,1] ≠[1,2]。所以不需要 <code>idx</code>。</p></li><li><p>使用boolean 数组 used：全排列，组合中没有重复数字，同一树枝上不能重复选择。用used 数组记录当前元素是否已被选择。</p></li></ul><figure><img src="https://img-blog.csdnimg.cn/20210215160540814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="" /><figcaption><img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv51h5BKbTHZUOibWKplkvJfSAfBfMiaRlo2Dpob0U8tABjUsSaMm20Z1NgdOpcb8D5ZuQjHHItRRewQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:80%;" /></figcaption></figure><ul><li>结束条件：当递归到树的叶子节点结束，path 添加到res 中。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtracking(nums, used, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == n)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//如果一个树枝上的元素已被选择（path已有nums[i]），跳过</span></span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="keyword">true</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtracking(nums, used, path);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>排列问题的不同：</strong></p><ul><li>因为解中的数组是有序的，每层都是从0开始搜索而不是startIndex</li><li>需要used数组记录path里都放了哪些元素了</li></ul><h5 id="全排列medium-1">47，全排列Ⅱ，medium</h5><p>给定一个<strong>可包含重复数字</strong>的序列 nums ，按任意顺序 返回所有<strong>不重复</strong>的全排列。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>与46题的区别</p><p>此题有 重复数字，则在同一层不能选取相同数字，否则会出现重复排列。类似 40题的思路来去重。</p><p>在同一树枝中，同一个数字不能被重复选，需要通过 <code>used[i]</code> 判断是否已被选取过。</p><figure><img src="https://img-blog.csdnimg.cn/2021021516071763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//先排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracking(nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//同一层相同元素已被选取，跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; used[i - <span class="number">1</span>] == <span class="keyword">false</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//同一枝同一元素已被选取，跳过</span></span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="keyword">true</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtracking(nums, path, used);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>注意解中<u>有序和无序</u>的区别：在 组合、子集、切割问题 中，<u>一个集合</u>的问题，需要开始索引 idx。排列问题从 0 开始遍历。</p><p>注意<u>同一层</u>的重复元素和<u>同一树枝</u>的重复元素的区别：常借用 boolean数组 记录被选择的元素，进行 <strong>去重</strong>。</p><p>注意结束条件：树的节点，所有节点 或 叶子节点 或满足题意的节点。</p><h3 id="其他">其他</h3><h5 id="括号生成medium">22，括号生成，medium</h5><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= n &lt;= 8</p><p><strong>题解</strong></p><p>选择：将左括号 或 右括号 填入path。</p><p>结束条件：当左括号 和 右括号都用完了，或 <code>path.length() == 2 * n</code> 就结束。</p><p>遍历过程：</p><ul><li>剪枝：当选择的右括号数量 &gt; 左括号。</li><li>选择：当选择的左括号数量 &lt; n，填入左括号；右括号同。 <img src="https://img-blog.csdnimg.cn/20210215160739252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        backtracking(n, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//l 表示已填入path 的左括号数量，r 表示已填入path 的右括号数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r, StringBuilder path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结束条件</span></span><br><span class="line">        <span class="comment">// if(path.length() == 2 * n)&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(l == n &amp;&amp; r == n)&#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已选择的左括号数量 &lt; 右括号，剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; n)&#123;</span><br><span class="line">            path.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            backtracking(n, l + <span class="number">1</span>, r, path);<span class="comment">//向下递归</span></span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; n)&#123;</span><br><span class="line">            path.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            backtracking(n, l, r + <span class="number">1</span>, path);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的回溯">图的回溯</h2><p>二维图可看作多个子节点多个分支，进行深度遍历搜索得到结果。</p><p>容易与【岛屿问题】混淆，岛屿问题用 DFS 来解，图的问题与岛屿问题有什么区别呢？下面由具体题目来体会。</p><h5 id="单词搜索medium">79，单词搜索，medium</h5><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">board &#x3D;</span><br><span class="line">[</span><br><span class="line">  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],</span><br><span class="line">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class="line">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class="line">]</span><br><span class="line">给定 word &#x3D; &quot;ABCCED&quot;, 返回 true</span><br><span class="line">给定 word &#x3D; &quot;SEE&quot;, 返回 true</span><br><span class="line">给定 word &#x3D; &quot;ABCB&quot;, 返回 false</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>一开始当做岛屿问题来做，为了避免每次DFS的时候被搜过的地方再重复搜索，修改已经搜索过的网格为 '.'。</p><p>给定 word = &quot;ABCB&quot;时就会发现，第一次dfs后的结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;E&#39;],</span><br><span class="line"></span><br><span class="line">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class="line"></span><br><span class="line">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>矩阵发生了变化，不能再继续搜索到 ABC 了。这时候就想到用回溯，修改了状态再改回来就好了嘛。</p><p>一段官方点的说法：DFS前后必须要保证执行前后程序面对问题的状态是相同的，因此当前问题缩小为子问题时所做的对当前问题状态产生影响的事情应该全部失效，这就是所谓的回溯时还原现场。</p><p>直接写回溯可能会超时，还可以进行优化，也就是【剪枝】。</p><p>当已经找到路径时，不需再回溯。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> columns = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(backtracking(board, word, i, j, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//结束条件：不在合法区域 或  当前字符与目标不一致</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidArea(board, i, j) || board[i][j] != word.charAt(idx))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//搜索完单词</span></span><br><span class="line">        <span class="keyword">if</span>(idx == word.length() - <span class="number">1</span>)&#123;</span><br><span class="line">            res = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//还没找到全部路径</span></span><br><span class="line">        <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="comment">//向四个方向搜索</span></span><br><span class="line">            <span class="keyword">boolean</span> r1 = backtracking(board, word, i + <span class="number">1</span>, j, idx + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">boolean</span> r2 = backtracking(board, word, i , j + <span class="number">1</span>, idx + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">boolean</span> r3 = backtracking(board, word, i - <span class="number">1</span>, j, idx + <span class="number">1</span>); </span><br><span class="line">            <span class="keyword">boolean</span> r4 = backtracking(board, word, i, j - <span class="number">1</span>, idx + <span class="number">1</span>); </span><br><span class="line">            board[i][j] = temp;</span><br><span class="line">            <span class="keyword">return</span> r1 || r2 || r3 || r4;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidArea</span><span class="params">(<span class="keyword">char</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sr &lt; <span class="number">0</span> || sr &gt;= image.length || sc &lt; <span class="number">0</span> || sc &gt;= image[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/LeetCode%E5%88%B7%E9%A2%98/">LeetCode刷题</category>
      
      
      <category domain="http://example.com/tags/%E5%9B%9E%E6%BA%AF/">回溯</category>
      
      
      <comments>http://example.com/2021/02/15/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
