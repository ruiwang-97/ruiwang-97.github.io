<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rui</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>去摘遥不可及的星星</description>
    <pubDate>Mon, 28 Jun 2021 12:34:37 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>怎样测试一个杯子</title>
      <link>http://example.com/2021/06/28/%E6%80%8E%E6%A0%B7%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E6%9D%AF%E5%AD%90/</link>
      <guid>http://example.com/2021/06/28/%E6%80%8E%E6%A0%B7%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E6%9D%AF%E5%AD%90/</guid>
      <pubDate>Mon, 28 Jun 2021 12:33:15 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;界面测试&quot;&gt;界面测试&lt;/h2&gt;
&lt;p&gt;对于不同的用户，对外观的需求也不一样。比如这款杯子的主要用户是儿童，那就要看杯子是不是可爱有趣；对于男性，杯子是否简约大方。&lt;/p&gt;
&lt;h2 id=&quot;功能测试&quot;&gt;功能测试&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="界面测试">界面测试</h2><p>对于不同的用户，对外观的需求也不一样。比如这款杯子的主要用户是儿童，那就要看杯子是不是可爱有趣；对于男性，杯子是否简约大方。</p><h2 id="功能测试">功能测试</h2><a id="more"></a><ol type="1"><li><p>杯子是否能装水</p></li><li><p>杯子是否漏水</p></li><li><p>（如果是保温杯）是否保温</p></li></ol><h2 id="性能测试">性能测试</h2><ol type="1"><li><p>杯子是否易碎</p></li><li><p>杯子从多高的地方跌落会破损</p></li><li><p>带有保护套时，从多高的地方跌落会破损</p></li></ol><h2 id="易用性">易用性</h2><ol type="1"><li><p>水是否容易喝到</p></li><li><p>是否方便携带</p></li><li><p>是否好拿</p></li><li><p>在不同温度下杯子是否耐受</p></li></ol><h2 id="安全性测试">安全性测试</h2><p>杯子的材料是否对人体有害</p><h2 id="兼容性测试">兼容性测试</h2><p>杯子是否能装不同的液体：水、饮料、汽油、药液等</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/">测试用例设计</category>
      
      
      
      <comments>http://example.com/2021/06/28/%E6%80%8E%E6%A0%B7%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E6%9D%AF%E5%AD%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL数据库主键与外键</title>
      <link>http://example.com/2021/06/28/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E4%B8%8E%E5%A4%96%E9%94%AE/</link>
      <guid>http://example.com/2021/06/28/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E4%B8%8E%E5%A4%96%E9%94%AE/</guid>
      <pubDate>Mon, 28 Jun 2021 08:35:04 GMT</pubDate>
      
      <description>&lt;p&gt;主键和外键都是约束。主键用于保持数据完整性，外键作用于两个表建立连接。下面分别介绍主键、外键及其区别。&lt;/p&gt;
&lt;h2 id=&quot;主键&quot;&gt;主键&lt;/h2&gt;
&lt;p&gt;表中经常有多个列，主键是唯一标识表中每行的列。一个表只能有一个主键，主键列不能包含null值。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>主键和外键都是约束。主键用于保持数据完整性，外键作用于两个表建立连接。下面分别介绍主键、外键及其区别。</p><h2 id="主键">主键</h2><p>表中经常有多个列，主键是唯一标识表中每行的列。一个表只能有一个主键，主键列不能包含null值。</p><p>例如：</p><a id="more"></a><p><code>学生表(学号，姓名，性别，班级)</code> 其中每个学生的学号是唯一的，学号就是一个主键；</p><p><code>课程表(课程编号，课程名，学分)</code> 其中课程编号是唯一的，课程编号就是一个主键</p><h4 id="联合主键">联合主键</h4><p>当某一列不能唯一识别每行，使用联合主键，将两列看为一个整体。非空、唯一、不重复。</p><p>例如： <code>成绩表(学号，课程号，成绩)</code></p><p>成绩表中单一一个属性无法唯一标识一条记录，学号和课程编号的组合才可以唯一标识一条记录，所以学号和课程编号的属性组是一个主键。</p><h2 id="外键">外键</h2><p>外键用于与另一张表相关联。以另一个表的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。 表的外键值必须在主表中能找到。 当主表的记录被从表参照时，主表的记录不允许删除。</p><p>例如： <img src="https://img-blog.csdnimg.cn/img_convert/b41ff90900c71fc998df6b76df8b2fcd.png#pic_center" alt="在这里插入图片描述" /></p><p>class表与Student表通过class_id 关联，实现一对多的关系。class_id作为Student表的外键，Student表为从表，在class表中为主键，class表为主表。</p><h2 id="主键外键和索引的区别">主键、外键和索引的区别：</h2><h4 id="a.定义">a.定义</h4><p>主键：唯一标识一条记录，不能有重复，不允许为空。 外键：表的外键是另一表的主键，外键是可以有重复的，可以是空值。 索引：该字段没有重复值，但可以有一个空值。</p><h4 id="b.作用">b.作用</h4><p>主键：用来保证数据完整性 外键：用来和其他表建立联系用 索引：用来提高查询排序的速度</p><h4 id="c.个数">c.个数</h4><p>主键：主键只能有一个。 外键：一个表可以有多个外键。 索引：一个表可以有多个唯一索引。</p><h2 id="添加主键外键约束">添加主键、外键约束</h2><p>主键约束 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">  列名<span class="number">1</span> 数据类型 primary <span class="keyword">key</span>,</span><br><span class="line">列名<span class="number">2</span> 数据类型</span><br><span class="line">);</span><br><span class="line"><span class="comment">--------或------------</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">  列名<span class="number">1</span> 数据类型,</span><br><span class="line">列名<span class="number">2</span> 数据类型,</span><br><span class="line">  primary <span class="keyword">key</span>(列名<span class="number">1</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">------已经存在的表-----</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> primary <span class="keyword">key</span>(列名);</span><br></pre></td></tr></table></figure> 外键约束 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">---------主表------</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表<span class="number">1</span>(</span><br><span class="line">列名<span class="number">1</span> 数据类型 primary <span class="keyword">key</span>,</span><br><span class="line">列名<span class="number">2</span> 数据类型  </span><br><span class="line">);</span><br><span class="line"><span class="comment">----从表（外键约束所在的表）------</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表<span class="number">2</span>(</span><br><span class="line">FK_列名<span class="number">1</span> 数据类型,</span><br><span class="line">  列名<span class="number">2</span> 数据类型,</span><br><span class="line">  <span class="keyword">constraint</span> 外键约束的名字 <span class="keyword">foreign</span> <span class="keyword">key</span>(从表的列名<span class="number">1</span>) <span class="keyword">references</span> 主表表名(主表的列名<span class="number">1</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/">MySQL数据库</category>
      
      
      <category domain="http://example.com/tags/%E4%B8%BB%E9%94%AE%E5%A4%96%E9%94%AE/">主键外键</category>
      
      
      <comments>http://example.com/2021/06/28/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E4%B8%8E%E5%A4%96%E9%94%AE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>自动售货机测试用例</title>
      <link>http://example.com/2021/06/26/%E8%87%AA%E5%8A%A8%E5%94%AE%E8%B4%A7%E6%9C%BA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</link>
      <guid>http://example.com/2021/06/26/%E8%87%AA%E5%8A%A8%E5%94%AE%E8%B4%A7%E6%9C%BA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</guid>
      <pubDate>Sat, 26 Jun 2021 13:31:29 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;功能测试&quot;&gt;功能测试&lt;/h2&gt;
&lt;p&gt;​ 1. 货物能否正常放置&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="功能测试">功能测试</h2><p>​ 1. 货物能否正常放置</p><a id="more"></a><ol start="2" type="1"><li><p>点击货物选择按钮是否能进入支付页面</p></li><li><p>是否支持选择多个货物</p></li></ol><p>支付</p><ol start="4" type="1"><li><p>是否支持硬币、纸币、扫码支付</p></li><li><p>是否支持找零</p></li><li><p>货物是否能正常取出</p></li><li><p>出现故障时能否自动退款</p></li></ol><p>屏幕显示</p><ol start="8" type="1"><li>屏幕是否正常播放广告</li><li>屏幕是否显示二维码</li></ol><h2 id="性能测试">性能测试</h2><ol type="1"><li><p>选择商品后跳转到支付页面的时间</p></li><li><p>支付成功后商品掉落时间</p></li><li><p>是否支持多个用户同时扫码支付</p></li><li><p>能否制热</p></li><li><p>能否制冷</p></li></ol><h2 id="界面测试">界面测试</h2><ol type="1"><li><p>图案是否鲜明亮丽</p></li><li><p>投币口是否明显</p></li><li><p>取物口是否明显</p></li></ol><h2 id="安全性测试">安全性测试</h2><ol type="1"><li><p>是否容易发生漏电</p></li><li><p>受到外力撞击是否容易倾倒</p></li><li><p>玻璃是否易被敲碎</p></li></ol><h2 id="兼容性测试">兼容性测试</h2><ol type="1"><li>是否能在室外工作</li><li>是否能在高温下工作</li><li>是否能在低温下工作</li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/">测试用例设计</category>
      
      
      
      <comments>http://example.com/2021/06/26/%E8%87%AA%E5%8A%A8%E5%94%AE%E8%B4%A7%E6%9C%BA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微信评论测试用例</title>
      <link>http://example.com/2021/06/25/%E5%BE%AE%E4%BF%A1%E8%AF%84%E8%AE%BA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</link>
      <guid>http://example.com/2021/06/25/%E5%BE%AE%E4%BF%A1%E8%AF%84%E8%AE%BA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</guid>
      <pubDate>Fri, 25 Jun 2021 13:35:50 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;功能测试&quot;&gt;功能测试&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;评论是否能够成功&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="功能测试">功能测试</h2><ol type="1"><li>评论是否能够成功</li></ol><a id="more"></a><ol type="1"><li><p>评论类型：文字、表情和图片</p></li><li><p>文字的长度限制，表情和图片的大小限制</p></li><li><p>是否支持复制粘贴评论</p></li><li><p>能否删除评论</p></li><li><p>评论之后共同好友是否可以看到</p></li><li><p>是否可以看到其他共同好友的评论</p></li><li><p>共同好友的评论显示备注</p></li><li><p>是否可以回复其他共同好友的评论</p></li><li><p>其他共同好友评论后是否有提醒</p></li><li><p>和其他共同好友评论显示的顺序是否按照时间顺序</p></li><li><p>评论提醒是否正常显示头像昵称</p></li><li><p>退出之后，评论是否还存在</p></li></ol><h2 id="性能测试">性能测试</h2><ol type="1"><li><p>评论之后多久能显示</p></li><li><p>共同好友评论之后多久能提醒</p></li><li><p>多用户评论的反应时间</p></li><li><p>评论时打电话、收到短信能否评论成功</p></li></ol><h2 id="界面测试">界面测试</h2><ol type="1"><li><p>评论是否正常显示头像昵称</p></li><li><p>全部评论是否都正常显示</p></li></ol><h2 id="兼容性测试">兼容性测试</h2><ol type="1"><li>电脑端能否评论</li><li>安卓、苹果手机不同系统下功能是否正常</li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/">测试用例设计</category>
      
      
      
      <comments>http://example.com/2021/06/25/%E5%BE%AE%E4%BF%A1%E8%AF%84%E8%AE%BA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>【LeetCode刷题】旋转数组</title>
      <link>http://example.com/2021/06/25/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E3%80%91%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</link>
      <guid>http://example.com/2021/06/25/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E3%80%91%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</guid>
      <pubDate>Fri, 25 Jun 2021 07:35:36 GMT</pubDate>
      
      <description>&lt;p&gt;数组有序时常用二分法来查找，时间复杂度降到O(logn)。旋转的有序数组也可以使用二分法，通过讨论mid所指元素在数组中的位置来重新确定搜索范围。&lt;/p&gt;
&lt;h2 id=&quot;寻找旋转排序数组中的最小值medium&quot;&gt;153，寻找旋转排序数组中的最小值，medium&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>数组有序时常用二分法来查找，时间复杂度降到O(logn)。旋转的有序数组也可以使用二分法，通过讨论mid所指元素在数组中的位置来重新确定搜索范围。</p><h2 id="寻找旋转排序数组中的最小值medium">153，寻找旋转排序数组中的最小值，medium</h2><a id="more"></a><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。</p><p>请找出其中最小的元素。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 5000</span><br><span class="line">-5000 &lt;&#x3D; nums[i] &lt;&#x3D; 5000</span><br><span class="line">nums 中的所有整数都是 唯一 的</span><br><span class="line">nums 原来是一个升序排序的数组，但在预先未知的某个点上进行了旋转</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>在找到 mid 时，要确定最小值在 mid 的左侧还是右侧。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//[5,1,2,3,4]</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &lt; numbers[r])&#123;</span><br><span class="line">                <span class="comment">//最小值在左</span></span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//[3,4,5,1,2]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &gt; numbers[r])&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//[1,1,1,0,1]</span></span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索旋转排序数组medium">33，搜索旋转排序数组，medium</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>升序排列的整数数组 <code>nums</code> 在预先未知的某个点上进行了旋转（例如， [0,1,2,4,5,6,7] 经旋转后可能变为 [4,5,6,7,0,1,2] ）。</p><p>请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>在二分查找过程中通过 <code>mid</code> 将数组分割为两部分，[l, mid] 和 [mid+1, r]，通过比较大小可确定哪部分是有序的。确定nums[mid]在左部分还是右部分，再确定target在mid的左边还是右边，从而调整left和right。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//确定nums[mid]在左部分还是右部分，再确定target在mid的左边还是右边，从而调整left和right</span></span><br><span class="line">            <span class="comment">//如果nums[mid]在左</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[left])&#123;</span><br><span class="line">                <span class="comment">//target在前半部分</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt; target &amp;&amp; target &gt;= nums[left]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果nums[mid]在右</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//target在后半部分</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题10.03">面试题10.03</h2><p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1:</span><br><span class="line"></span><br><span class="line"> 输入: arr &#x3D; [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target &#x3D; 5</span><br><span class="line"> 输出: 8（元素5在该数组中的索引）</span><br><span class="line">示例2:</span><br><span class="line"></span><br><span class="line"> 输入：arr &#x3D; [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target &#x3D; 11</span><br><span class="line"> 输出：-1 （没有找到）</span><br></pre></td></tr></table></figure> 提示：arr 长度范围在[1, 1000000]之间</p><p><strong>题解</strong></p><p>注意此题与上面题的区别在于可以有重复元素。且已旋转多次。</p><p><img src="https://img-blog.csdnimg.cn/20210625154829803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//二分法</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//左边值等于目标值，已找到</span></span><br><span class="line">            <span class="keyword">if</span>(arr[l] == target)</span><br><span class="line">                <span class="keyword">return</span> l;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[l] == arr[mid])</span><br><span class="line">                l++;</span><br><span class="line">            <span class="comment">//左 &lt; 中，左边升序</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; arr[l])&#123;</span><br><span class="line">                <span class="comment">//target也在左 [4,5,6,1,2,3]</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt; arr[l] &amp;&amp; target &lt;= arr[mid]) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左边无序 [6,1,2,3,4,5] [3,3,1,1,1,3]</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//target在右 </span></span><br><span class="line">                <span class="keyword">if</span>(target &gt; arr[mid] &amp;&amp; target &lt; arr[l]) </span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这道题很类似了，换汤不换药</p><h2 id="搜索旋转排序数组medium-1">81，搜索旋转排序数组Ⅱ，medium</h2><p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p><p>示例 1： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure> 示例 2： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//左边值等于目标值，已找到</span></span><br><span class="line">            <span class="keyword">if</span>(arr[l] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[l] == arr[mid])</span><br><span class="line">                l++;</span><br><span class="line">            <span class="comment">//左 &lt; 中，左边升序</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; arr[l])&#123;</span><br><span class="line">                <span class="comment">//target也在左 [4,5,6,1,2,3]</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt; arr[l] &amp;&amp; target &lt;= arr[mid]) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左边无序 [6,1,2,3,4,5] [3,3,1,1,1,3]</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//target在右 </span></span><br><span class="line">                <span class="keyword">if</span>(target &gt; arr[mid] &amp;&amp; target &lt; arr[l]) </span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/LeetCode%E5%88%B7%E9%A2%98/">LeetCode刷题</category>
      
      
      
      <comments>http://example.com/2021/06/25/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E3%80%91%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>登录测试用例</title>
      <link>http://example.com/2021/06/24/%E7%99%BB%E5%BD%95%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</link>
      <guid>http://example.com/2021/06/24/%E7%99%BB%E5%BD%95%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</guid>
      <pubDate>Thu, 24 Jun 2021 14:06:12 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;需求&quot;&gt;需求&lt;/h2&gt;
&lt;p&gt;有一个登陆页面， 上面有2个textbox, 一个提交按钮。&lt;/p&gt;
&lt;h2 id=&quot;功能测试&quot;&gt;功能测试&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="需求">需求</h2><p>有一个登陆页面， 上面有2个textbox, 一个提交按钮。</p><h2 id="功能测试">功能测试</h2><a id="more"></a><ol type="1"><li>输入正确的用户名和密码，点击提交按钮，验证是否能正确登录。</li><li>输入错误的用户名或密码，验证登录失败，并且会有相应提示。</li><li>登录成功后会跳转到正确页面</li><li>用户名和密码是否含有特殊字符</li><li>用户名和密码长度是否符合要求</li><li>输入用户名和密码后能否通过点击回车键跳转</li></ol><h2 id="界面测试">界面测试</h2><ol type="1"><li>布局是否合理，两个输入框和一个按钮是否对齐</li><li>两个输入框及提交按钮的高度和宽度是否符合要求</li><li>图片、文字是否显示正确 ## 性能测试</li><li>输入网址打开登录页面需要几秒</li><li>登录成功后跳转需要几秒</li><li>支持多少个用户登录 ## 兼容性测试</li><li>在不同浏览器下功能是否正常</li><li>在不同平台（Windows、Mac）下功能是否正常</li><li>在安卓和ios系统是否正常</li></ol><h2 id="安全性测试">安全性测试</h2><ol type="1"><li>登录成功生成的Cookie是否是httponly</li></ol><blockquote><p>如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击。XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。</p></blockquote><ol start="2" type="1"><li><p>用户名和密码输入防止sql注入</p></li><li><p>错误登陆的次数限制（防止暴力破解）</p></li><li><p>密码是否以星号显示</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/">测试用例设计</category>
      
      
      
      <comments>http://example.com/2021/06/24/%E7%99%BB%E5%BD%95%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode刷题-重叠区间问题</title>
      <link>http://example.com/2021/06/24/LeetCode%E5%88%B7%E9%A2%98-%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</link>
      <guid>http://example.com/2021/06/24/LeetCode%E5%88%B7%E9%A2%98-%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Thu, 24 Jun 2021 07:01:49 GMT</pubDate>
      
      <description>&lt;p&gt;跟着&lt;a href=&quot;https://mp.weixin.qq.com/s/ioUlNa4ZToCrun3qb4y4Ow&quot;&gt;甜姨&lt;/a&gt;整理了这一类问题，没有固定套路，但需要找规律以及细心。&lt;/p&gt;
&lt;h3 id=&quot;重叠区间&quot;&gt;重叠区间&lt;/h3&gt;
&lt;h5 id=&quot;会议室easy&quot;&gt;252，会议室，easy&lt;/h5&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>跟着<a href="https://mp.weixin.qq.com/s/ioUlNa4ZToCrun3qb4y4Ow">甜姨</a>整理了这一类问题，没有固定套路，但需要找规律以及细心。</p><h3 id="重叠区间">重叠区间</h3><h5 id="会议室easy">252，会议室，easy</h5><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20210624145840345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p><p><strong>题解</strong></p><p>实质是判断有没有重叠区间，将区间按照会议开始时间排序，然后遍历一遍即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAttendMeetings</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span></span>&#123;</span><br><span class="line">        Arrays.sort(intervals, (v1, v2)-&gt;v1[<span class="number">0</span>]-v2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="合并区间medium">56，合并区间，medium</h5><p><img src="https://img-blog.csdnimg.cn/20210624145904133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p><p><strong>题解</strong></p><p>与上一题的区别在于要合并重叠的区间，还是从intervals的第一个元素开始遍历，最开始比较的对象为<code>intervals[0][1]</code>，在遍历过程中不断更新，此对象的含义为上一个区间的末尾。即新的区间的开头比上一区间的末尾大，就不需要合并。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        Arrays.sort(intervals, (v1, v2) -&gt; v1[<span class="number">0</span>] - v2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> flag = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">0</span>] = intervals[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= flag)&#123;</span><br><span class="line">                res[idx][<span class="number">1</span>] = Math.max(res[idx][<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">                flag = res[idx][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[++idx] = intervals[i];</span><br><span class="line">                flag = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, idx + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入区间medium">57，插入区间，medium</h5><p><img src="https://img-blog.csdnimg.cn/20210624145939272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210624145956248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p><strong>题解</strong></p><p>本题中的区间已经按照起始端点升序排列，因此我们直接遍历区间列表，寻找新区间的插入位置即可。具体步骤如下：</p><ol type="1"><li>首先将新区间左边且相离的区间加入结果集（遍历时，如果当前区间的结束位置小于新区间的开始位置，说明当前区间在新区间的左边且相离）；</li><li>接着判断当前区间是否与新区间重叠，重叠的话就进行合并，直到遍历到当前区间在新区间的右边且相离，将最终合并后的新区间加入结果集；</li><li>最后将新区间右边且相离的区间加入结果集。</li></ol><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> pL = newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pR = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//[[1,2],[3,5],[6,7],[8,10],[12,16]]</span></span><br><span class="line">        <span class="comment">//         4          8</span></span><br><span class="line">        <span class="comment">//[[1,2],[3,10],[12,16]]</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//无重叠部分</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.length &amp;&amp; intervals[i][<span class="number">1</span>] &lt; pL)&#123;</span><br><span class="line">            res[idx++] = intervals[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接着判断当前区间是否与新区间重叠，重叠的话就进行合并，直到遍历到当前区间在新区间的右边且相离，</span></span><br><span class="line">        <span class="comment">// 将最终合并后的新区间加入结果集 </span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.length &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= pR)&#123;</span><br><span class="line">            pL = Math.min(intervals[i][<span class="number">0</span>], pL);</span><br><span class="line">            pR = Math.max(intervals[i][<span class="number">1</span>], pR);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res[idx++] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pL, pR&#125;;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.length)&#123;</span><br><span class="line">            res[idx++] = intervals[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除被覆盖区间medium">1288，删除被覆盖区间，medium</h5><p><img src="https://img-blog.csdnimg.cn/20210624150012985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p><p><strong>题解</strong></p><p>贪心</p><p>先按区间左边界升序排列，如果相等，按右区间降序排列（消除覆盖区间）</p><p>这样只需要更新一个右边界值即可</p><p>遍历区间，如果被覆盖，区间数-1；如果没有被覆盖，则更新新的边界值。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        Arrays.sort(intervals, (v1, v2) -&gt; v1[<span class="number">0</span>] == v2[<span class="number">0</span>] ? v2[<span class="number">1</span>] - v1[<span class="number">1</span>] : v1[<span class="number">0</span>] - v2[<span class="number">0</span>]);</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">int</span> res = intervals.length;</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &lt;= r)&#123;</span><br><span class="line">                res--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> r = Math.max(r, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="汇总区间easy">228，汇总区间，easy</h5><p><img src="https://img-blog.csdnimg.cn/20210624150029973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p><p><strong>题解</strong></p><p>对连续的数字按固定格式输出，那么双指针找到不连续的数字即可。</p><p>找到之后更新<code>i = j + 1</code>。</p><p>在一个循环中判断一下双指针所指位置，如果相同则只添加一个元素。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(String.valueOf(nums[<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            <span class="comment">//找到第一个不符合递增规则的，或者遍历完成</span></span><br><span class="line">            <span class="keyword">if</span>(j == nums.length - <span class="number">1</span> || nums[j] + <span class="number">1</span> != nums[j + <span class="number">1</span>])&#123;</span><br><span class="line">                String tmp = String.valueOf(nums[i]) + <span class="string">&quot;-&gt;&quot;</span> + String.valueOf(nums[j]);</span><br><span class="line">                <span class="keyword">if</span>(nums[i] != nums[j])</span><br><span class="line">                    res.add(tmp);</span><br><span class="line">                <span class="keyword">else</span> res.add(String.valueOf(nums[j]));</span><br><span class="line">                i = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/LeetCode%E5%88%B7%E9%A2%98/">LeetCode刷题</category>
      
      
      <category domain="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/">双指针</category>
      
      
      <comments>http://example.com/2021/06/24/LeetCode%E5%88%B7%E9%A2%98-%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微信红包怎么测试</title>
      <link>http://example.com/2021/06/23/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95/</link>
      <guid>http://example.com/2021/06/23/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95/</guid>
      <pubDate>Wed, 23 Jun 2021 14:29:58 GMT</pubDate>
      
      <description>&lt;p&gt;分为功能测试、性能测试、兼容性测试、界面测试、安全测试、中断测试几大方面。&lt;/p&gt;
&lt;h2 id=&quot;功能测试&quot;&gt;功能测试&lt;/h2&gt;
&lt;h4 id=&quot;发送给单个好友&quot;&gt;1）发送给单个好友&lt;/h4&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>分为功能测试、性能测试、兼容性测试、界面测试、安全测试、中断测试几大方面。</p><h2 id="功能测试">功能测试</h2><h4 id="发送给单个好友">1）发送给单个好友</h4><a id="more"></a><p>①发送金额，留言，表情</p><blockquote><p>正确的金额+无留言+无表情 　</p><p>错误的金额+无留言+无表情 　</p><p>正确的金额+有留言+无表情 　</p><p>错误的金额+有留言+无表情</p><p>正确的金额+无留言+有表情 　</p><p>错误的金额+无留言+有表情 　</p><p>正确的金额+有留言+有表情 　</p><p>错误的金额+有留言+有表情</p></blockquote><p>②金额为0.01~200，需要测试0，0.01，1，199.99，200，200.01这些边界值。</p><p>③留言是否可以输入数字，汉字，英文，特殊字符或它们的组合</p><p>④输入超长文本是是否有限制或提示</p><p>⑤添加表情时选择收藏的表情（动图/静图）</p><p>⑥是否可以录制表情</p><p>⑦表情添加后是否可删除</p><p><strong>付款</strong></p><p>①可以使用零钱/银行卡/添加新卡，需要考虑</p><p>金额＞零钱/银行卡余额，金额＜零钱/银行卡余额，金额=零钱/银行卡余额 三种情况</p><p>②使用指纹确认付款</p><p>③使用密码确认付款</p><p>④发送成功后，账户减少对应金额，退回原界面</p><p>⑤24小时后若没有领取，将退回原账户，此时原付款方式增加发出的金额</p><p><strong>好友</strong></p><p>① 金额、留言、表情可以正常显示</p><p>② 点击领取红包，零钱中增加相应的金额，再次点击只能看到信息不能领取</p><p>③ 24小时之内没有领取的红包将无法领取，显示已过期，并无法查看到金额</p><h4 id="发送群红包">2）发送群红包</h4><p>（部分相似）</p><p>①选择为普通红包，每个人领取的金额相同；拼手气红包，每个人收到的金额随机</p><p>②红包个数（1-100）：0，1，2，大于群成员人数，小于群成员人数，等于群成员人数，99，100，101，小数，中文、英文、特殊字符、表情或者他们的组合</p><p>③群里的人都可以抢一次，且最多一次</p><h2 id="性能测试">性能测试</h2><p>①打开和发送红包的响应时间不能超过2s，高并发场景下不能超过3s</p><p>②耗电量</p><p>③占内存大小</p><p>④消耗流量</p><h2 id="兼容性测试">兼容性测试</h2><p>①苹果手机和安卓手机</p><p>②ios不同版本</p><p>③安卓不同机型</p><p>④微信电脑端可以抢红包</p><h2 id="界面测试">界面测试</h2><p>①设计风格是否一致</p><p>②排版是否合理</p><p>③界面没有错别字</p><p>④易学、易理解</p><h2 id="中断测试">中断测试</h2><p>前后台切换，网络异常，低电量，断电，来电，短信等</p><h2 id="安全测试">安全测试</h2><p>①给好友发红包，是否会显示异地登录提醒</p><p>②红包发送失败，余额和银行卡的钱是否退回</p><p>③红包发送成功，是否会收到微信支付的通知</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/">测试用例设计</category>
      
      
      
      <comments>http://example.com/2021/06/23/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java中的锁机制—synchronized关键字</title>
      <link>http://example.com/2021/06/22/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6%E2%80%94synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <guid>http://example.com/2021/06/22/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6%E2%80%94synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <pubDate>Tue, 22 Jun 2021 07:14:49 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;java中的锁机制&quot;&gt;Java中的锁机制&lt;/h2&gt;
&lt;p&gt;Java中多线程加锁机制主要有两种：一种是jdk实现的Lock锁，一种是JVM底层实现的synchronized关键字。&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;synchronized用于方法或代码块；Lock是一个接口，实现类有ReentrantLock可重入锁、ReadWriteLock读写锁。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;synchronized是隐式锁，无需手动开启和关闭，因此不会出现死锁；Lock锁是显示锁，需要手动开启和关闭，如果开启和关闭次数不一致，可能发生死锁。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="java中的锁机制">Java中的锁机制</h2><p>Java中多线程加锁机制主要有两种：一种是jdk实现的Lock锁，一种是JVM底层实现的synchronized关键字。</p><p>区别：</p><ul><li><p>synchronized用于方法或代码块；Lock是一个接口，实现类有ReentrantLock可重入锁、ReadWriteLock读写锁。</p></li><li><p>synchronized是隐式锁，无需手动开启和关闭，因此不会出现死锁；Lock锁是显示锁，需要手动开启和关闭，如果开启和关闭次数不一致，可能发生死锁。</p></li></ul><a id="more"></a><p>在JDK1.6后，对synchronized进行了很多优化，如偏向锁、轻量级锁等，synchronized的性能已经与Reentrantlock大致相同，除非要使用Reentrantlock的一些高级功能（实现公平锁、中断锁等），一般推荐使用synchronized关键字来实现加锁机制。</p><h2 id="synchronized锁机制">synchronized锁机制</h2><p>在对象的MarkWord中记录一个锁状态，锁的状态有四种：<strong>无锁、偏向锁、轻量级锁、重量级锁</strong>。</p><p>随着竞争的增加，锁的使用情况如下:</p><blockquote><p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p></blockquote><p>其中偏向锁和轻量级锁是从 JDK 6 时引入的，在 JDK 6 中默认开启。 锁的升级（锁膨胀）是单向的，只能从低到高（从左到右）。不会出现锁的降级。</p><p><img src="https://img-blog.csdnimg.cn/20210622151128813.png" /></p><h3 id="锁状态转换">锁状态转换</h3><p><img src="https://img-blog.csdnimg.cn/20210622151234703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" /></p><h4 id="偏向锁">①偏向锁</h4><p>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01” （可偏向），即偏向模式，在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><h4 id="轻量级锁">②轻量级锁</h4><p>当两个线程交替获取一个对象的锁时，偏向锁会升级为轻量级锁。这个阶段线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。</p><h4 id="自旋锁">自旋锁</h4><p>如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。但是线程自旋是需要消耗CPU的。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。</p><h4 id="重量级锁">③重量级锁</h4><p>通过系统的线程互斥锁来实现的，代价最昂贵。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java%E5%B9%B6%E5%8F%91/">Java并发</category>
      
      
      
      <comments>http://example.com/2021/06/22/Java%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6%E2%80%94synchronized%E5%85%B3%E9%94%AE%E5%AD%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java类的初始化顺序（代码测试）</title>
      <link>http://example.com/2021/06/16/Java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%88%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%EF%BC%89/</link>
      <guid>http://example.com/2021/06/16/Java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%88%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%EF%BC%89/</guid>
      <pubDate>Wed, 16 Jun 2021 08:09:01 GMT</pubDate>
      
      <description>&lt;p&gt;Java类的初始化顺序为&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态变量/静态代码块—main()方法—非静态变量/代码块—构造器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码验证：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Java类的初始化顺序为</p><p><strong>静态变量/静态代码块—main()方法—非静态变量/代码块—构造器</strong></p><p>代码验证：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadClassTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">2</span>;<span class="comment">//成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态变量a=&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;我在静态代码块里&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在代码块里&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;成员变量b=&quot;</span> + b);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在main方法里&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">new</span> LoadClassTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadClassTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在构造器里&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="https://img-blog.csdnimg.cn/20210616155820829.png" /></p><p>注：关于成员变量和类变量的区别可以看<a href="https://blog.csdn.net/qq_39181839/article/details/114264566?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162383035716780264094464%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162383035716780264094464&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-114264566.nonecase&amp;utm_term=%E5%8F%98%E9%87%8F&amp;spm=1018.2226.3001.4450">这一篇</a></p><p>JVM自动执行静态变量/静态代码块，每个静态代码块只被执行一次。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadClassTest</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stu[] stu = <span class="keyword">new</span> Stu[<span class="number">3</span>];</span><br><span class="line">        stu[<span class="number">0</span>] = <span class="keyword">new</span> Stu(<span class="string">&quot;小李&quot;</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        stu[<span class="number">1</span>] = <span class="keyword">new</span> Stu(<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line">        stu[<span class="number">2</span>] = <span class="keyword">new</span> Stu(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Stu s : stu)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name：&quot;</span> + s.getName() + <span class="string">&quot;,id：&quot;</span> + s.getId() + <span class="string">&quot;, gender：&quot;</span> + s.getGender());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        Random generator = <span class="keyword">new</span> Random();</span><br><span class="line">        nextId = generator.nextInt(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(String name, <span class="keyword">char</span> gender)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(<span class="keyword">char</span> gender)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;Student #&quot;</span> + nextId , gender);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 测试结果： <img src="https://img-blog.csdnimg.cn/20210616161840494.png" /></p><p>可见静态代码块只执行了一次，而代码块随类的加载而执行。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Java-SE/">Java SE</category>
      
      
      <category domain="http://example.com/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/">静态代码块</category>
      
      
      <comments>http://example.com/2021/06/16/Java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%88%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
