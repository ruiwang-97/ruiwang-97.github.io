<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"8.0.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="刷了几道背包问题，用了一周时间，动态规划的难真的领会到了。但再难总有规律可循，总结中刷题，刷题中总结。 关于0-1背包的问题有：  416，分割等和子集 494，目标和 474，一和零  关于完全背包的问题有：  322，零钱兑换">
<meta property="og:type" content="article">
<meta property="og:title" content="一文看清背包套路">
<meta property="og:url" content="http://example.com/2021/01/08/%E4%B8%80%E6%96%87%E7%9C%8B%E6%B8%85%E8%83%8C%E5%8C%85%E5%A5%97%E8%B7%AF/index.html">
<meta property="og:site_name" content="Rui">
<meta property="og:description" content="刷了几道背包问题，用了一周时间，动态规划的难真的领会到了。但再难总有规律可循，总结中刷题，刷题中总结。 关于0-1背包的问题有：  416，分割等和子集 494，目标和 474，一和零  关于完全背包的问题有：  322，零钱兑换">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210107152332640.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210107155801985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/00df062b020fa03ff81e0a7000b1f3df.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210108113212272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210108114808230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210108114808238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2021-01-08T12:44:55.000Z">
<meta property="article:modified_time" content="2021-01-11T09:57:40.930Z">
<meta property="article:author" content="Rui Wang">
<meta property="article:tag" content="动态规划">
<meta property="article:tag" content="LeetCode刷题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20210107152332640.png#pic_center">


<link rel="canonical" href="http://example.com/2021/01/08/%E4%B8%80%E6%96%87%E7%9C%8B%E6%B8%85%E8%83%8C%E5%8C%85%E5%A5%97%E8%B7%AF/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>一文看清背包套路 | Rui</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

  
  <script type="text/javascript" src="/js/my_js/clicklove.js"></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/rss2.xml" title="Rui" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Rui</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%800-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">一、0-1背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E5%85%A5"><span class="nav-text">引入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86medium"><span class="nav-text">416，分割等和子集，medium</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8Cmedium"><span class="nav-text">494，目标和，medium</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E5%92%8C%E9%9B%B6medium"><span class="nav-text">474，一和零，medium</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93"><span class="nav-text">0-1背包总结</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">二、完全背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="nav-text">完全背包问题引入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2medium"><span class="nav-text">322，零钱兑换，medium</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%E4%BA%8C%E7%BB%B4%E5%85%88%E9%81%8D%E5%8E%86%E7%89%A9%E5%93%81%E5%86%8D%E9%81%8D%E5%8E%86%E8%83%8C%E5%8C%85"><span class="nav-text">解法一：二维（先遍历物品，再遍历背包）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%E4%B8%80%E7%BB%B4%E5%85%88%E9%81%8D%E5%8E%86%E8%83%8C%E5%8C%85%E5%86%8D%E9%81%8D%E5%8E%86%E7%89%A9%E5%93%81"><span class="nav-text">解法二：一维（先遍历背包，再遍历物品）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2medium-1"><span class="nav-text">518，零钱兑换Ⅱ，medium</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cmedium"><span class="nav-text">377，组合总和Ⅳ，medium</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86medium"><span class="nav-text">139，单词拆分，medium</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="nav-text">完全背包问题总结</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rui Wang"
      src="https://upload.jianshu.io/users/upload_avatars/525624/28c068b9-5f2b-4ff8-bc40-3a9e53773228.jpeg?imageMogr2/auto-orient/strip|imageView2/1/w/80/h/80/format/webp">
  <p class="site-author-name" itemprop="name">Rui Wang</p>
  <div class="site-description" itemprop="description">去摘遥不可及的星星</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/08/%E4%B8%80%E6%96%87%E7%9C%8B%E6%B8%85%E8%83%8C%E5%8C%85%E5%A5%97%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://upload.jianshu.io/users/upload_avatars/525624/28c068b9-5f2b-4ff8-bc40-3a9e53773228.jpeg?imageMogr2/auto-orient/strip|imageView2/1/w/80/h/80/format/webp">
      <meta itemprop="name" content="Rui Wang">
      <meta itemprop="description" content="去摘遥不可及的星星">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rui">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          一文看清背包套路
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-08 20:44:55" itemprop="dateCreated datePublished" datetime="2021-01-08T20:44:55+08:00">2021-01-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-11 17:57:40" itemprop="dateModified" datetime="2021-01-11T17:57:40+08:00">2021-01-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">LeetCode刷题</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>刷了几道背包问题，用了一周时间，动态规划的难真的领会到了。但再难总有规律可循，总结中刷题，刷题中总结。</p>
<p>关于0-1背包的问题有：</p>
<ul>
<li><p>416，分割等和子集</p></li>
<li><p>494，目标和</p></li>
<li><p>474，一和零</p></li>
</ul>
<p>关于完全背包的问题有：</p>
<ul>
<li>322，零钱兑换</li>
</ul>
<a id="more"></a>
<ul>
<li><p>518，零钱兑换Ⅱ</p></li>
<li><p>377，组合总和Ⅳ</p></li>
<li><p>139，单词拆分</p></li>
</ul>
<h2 id="一0-1背包问题">一、0-1背包问题</h2>
<h5 id="引入">引入</h5>
<p>一个可装载重量为<code>W</code>的背包和<code>N</code>个物品，每个物品有重量和价值两个属性。怎么装使这个背包装下物品的价值最大？</p>
<p><strong>套路</strong>：</p>
<ol type="1">
<li><p><strong>子问题</strong>：<strong>二维 <code>dp</code> 数组</strong> <span class="math inline">\(dp[i][j]\)</span>—对于前 <code>i</code> 个物品，当前背包容量为 <code>j</code>，这种情况下可以装的最大价值是 <span class="math inline">\(dp[i][j]\)</span>。</p>
<p>比如说，如果 <span class="math inline">\(dp[3][5] = 6\)</span>，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。 根据这个定义，我们想求的<strong>最终答案就是 <code>dp[N][W]</code></strong>。</p></li>
<li><p><strong>base case</strong>： 当没有物品 或 背包没有容量时，<span class="math inline">\(dp[0][...] = dp[...][0] = 0\)</span></p></li>
<li><p><strong>状态转移</strong>：</p>
<p>物品 i 有两种选择—装进背包和不装，设第 i 件物品体积为 w，价值为 v。</p>
<ul>
<li>物品 i 不装进背包，最大价值 <span class="math inline">\(dp[i][j] = dp[i - 1][j]\)</span></li>
<li>物品 i 装进背包，最大价值 <span class="math inline">\(dp[i][j] = dp[i - 1][j - w] + v\)</span></li>
</ul>
<p>因此，0-1 背包的状态转移方程为：</p>
<p><span class="math inline">\(dp[i][j] = Math.max(dp[i - 1][j],dp[i - 1][j - w] + v)\)</span></p></li>
</ol>
<p><strong>代码：</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// W 为背包总体积</span></span><br><span class="line"><span class="comment">// N 为物品数量</span></span><br><span class="line"><span class="comment">// weights 数组存储 N 个物品的重量</span></span><br><span class="line"><span class="comment">// values 数组存储 N 个物品的价值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] values)</span></span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]表示装 i 个物品背包容量为 j</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//默认初始化都为0，从第1行和第1列开始赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//物品从weight[0]开始添加，w表示第i个物品的体积，v表示第i个物品的价值</span></span><br><span class="line">        <span class="keyword">int</span> w = weight[i - <span class="number">1</span>]; <span class="keyword">int</span> v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; W + <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= w)</span><br><span class="line">            	dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - w] + v);</span><br><span class="line">            <span class="comment">// 当前背包容量装不下，只能选择不装入背包</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到 <span class="math inline">\(dp[i][j]\)</span> 都是通过上一行 <span class="math inline">\(dp[i-1][..]\)</span> 转移过来的，之前的数据都不会再使用了。 所以，我们可以进行状态压缩，将二维 dp 数组压缩为一维，节约空间复杂度，可见下一题。</p>
<h5 id="分割等和子集medium">416，分割等和子集，medium</h5>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:</p>
<p>每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure>
<ul>
<li><p>题意分析：</p>
<p>看起来和背包没关系，实际是<strong>背包问题的变体：子集背包问题</strong>。原背包问题的二维数组 <span class="math inline">\(v = dp[i][j]\)</span> 表示 对于前 <code>i</code> 个物品，当前背包容量为 <code>j</code>，这种情况下可以装的最大价值是 <span class="math inline">\(v\)</span>。</p>
<p>此题中，要把数组分割成两个等和子集，即背包容量：数组的和 <code>sum</code>的一半，物品：数组元素。如果遍历数组，部分元素的和恰好为 背包容量，则剩余元素的和也恰好为 <code>sum / 2</code>，返回true。</p></li>
<li><p>思路：</p>
<p><strong>特殊情况：</strong></p>
<p><code>nums</code> 数组的元素和 <code>sum</code> 若为奇数，则无法分割，返回false。</p>
<p>如果 <code>n &lt; 2</code>，数组无法分割，返回false。</p></li>
</ul>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(x = dp[i][j]\)</span> 表示 对于数组<code>nums</code> 的前 <code>i</code> 个元素，当前元素和是否为 <code>j</code>， 若为 j ，<span class="math inline">\(x = true\)</span>；否则，<span class="math inline">\(x = false\)</span>。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0][...] = false\)</span> 数组中没有元素可选取，返回false。</p>
<p><span class="math inline">\(dp[...][0] = true\)</span> 目标元素和为 0，不选取元素即可。</p></li>
<li><p>状态转移方程</p>
<p>当前元素 <code>num = nums[i - 1]</code>（从数组的 第 0 个元素开始遍历）</p>
<p>①. <code>j &gt;= num</code></p>
<ul>
<li><p>不将 <code>num</code> 算入，能否恰好等于 j ,<span class="math inline">\(dp[i][j]\)</span>取决于 <span class="math inline">\(dp[i - 1][j]\)</span></p></li>
<li><p>将 <code>num</code> 算入，能否恰好等于 j ,<span class="math inline">\(dp[i][j]\)</span>取决于 <span class="math inline">\(dp[i - 1][j - num]\)</span></p>
<p>理解：如果装入第 i 个元素，要看剩余元素和 <code>j - num</code> 限制下是否恰好装满。</p></li>
</ul>
<p>②.<code>j &lt; num</code></p>
<p>要达到的元素和 比 当前元素值 小，无法加入。</p>
<p>总结： <img src="https://img-blog.csdnimg.cn/20210107152332640.png#pic_center" alt="在这里插入图片描述" /></p></li>
</ol>
<ul>
<li><p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//dp[i][j]— [0, i]元素 元素是否为 j</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][target + <span class="number">1</span>];<span class="comment">//初始化都为false</span></span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; target + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//要达到的元素和 比 当前元素值 小，无法加入</span></span><br><span class="line">                <span class="keyword">if</span>(j &lt; num) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>降维</p>
<p><span class="math inline">\(dp[i][j]\)</span> 都是通过上一行 <span class="math inline">\(dp[i-1][..]\)</span> 转移过来的，可以进行状态压缩，将二维 dp 数组压缩为一维，但要注意 <strong>j 应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果。</strong></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = nums.length;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">          sum += num; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//特殊：</span></span><br><span class="line">      <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      sum = sum / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum + <span class="number">1</span>];</span><br><span class="line">      dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> num = nums[i - <span class="number">1</span>];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = sum; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">              <span class="keyword">if</span>(j &gt;= num)</span><br><span class="line">                  dp[j] = dp[j] | dp[j - num];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[sum];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结<strong>做题步骤</strong>：</p></li>
</ul>
<ol type="1">
<li><p><strong>理解题意</strong>，判定此题为 0-1背包问题</p></li>
<li><p>此题是否有<strong>特殊情况</strong></p></li>
<li><p><strong>动态规划</strong>正常做法 1. 子问题：确定背包和物品指代什么，<span class="math inline">\(dp[i][j]\)</span> 返回值是什么 2. base case：通常为 <span class="math inline">\(dp[0][...]、dp[...][0]、dp[0][0]\)</span> 3. 状态转移方程： 先遍历物品，再遍历背包。每个物品只有装和不装两个选择。</p>
<pre><code>组合问题公式   dp[i] += dp[i - num]
True、False问题公式    dp[i] = dp[i] or dp[i - num]
最大最小问题公式    dp[i] = min(dp[i], dp[i - num]+1) 或 dp[i] =  max(dp[i], dp[i - num]+1)</code></pre></li>
<li><p>最终<strong>返回结果</strong></p></li>
<li><p><strong>状态压缩</strong>至一维（可不进行）</p></li>
</ol>
<h5 id="目标和medium">494，目标和，medium</h5>
<p>给定一个非负整数数组<code>a1, a2, ..., an</code> 和一个目标数 S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"> 数组非空，且长度不会超过 20 。</span><br><span class="line">   初始的数组的和不会超过 1000 。</span><br><span class="line">  保证返回的最终结果能被 32 位整数存下。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>题意分析： <img src="https://img-blog.csdnimg.cn/20210107155801985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 则转换为 0-1背包问题：给定一个数组 和一个容量为 target 的背包，求多少种方式将背包填满。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(x = dp[i][j]\)</span> 表示 对于数组<code>nums</code> 的前 <code>i</code> 个元素，放进容量 <code>j</code> 的背包，装满方式为 x。</p></li>
</ol>
<p><strong>特殊情况：</strong></p>
<p><code>S + sum</code> 必须为偶数才可分解，<code>S &lt; sum</code> 才可使数组 <code>nums</code> 元素得到 <code>S</code>。</p></li>
</ul>
<ol start="2" type="1">
<li><p>base case</p>
<p><span class="math inline">\(dp[0][0] = 1\)</span> 没有元素，所以只能不选，和为0</p></li>
<li><p>状态转移方程</p>
<p>当前元素 <code>num = nums[i - 1]</code>（从数组的 第 0 个元素开始遍历）</p>
<p>①. <code>j &gt;= num</code></p>
<p>将 当前 <code>num = nums[i-1]</code> 放入或不放入背包，<span class="math inline">\(dp[i][j] = dp[i-1][j]+dp[i-1][j-num]\)</span></p>
<p>②. <code>j &lt; num</code></p>
<p>不能放入，取决于上一状态，<span class="math inline">\(dp[i][j] = dp[i-1][j]\)</span></p></li>
</ol>
<ul>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(S &gt; sum || (sum + S) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> target = (sum + S) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>][target + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; target + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= num)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对base case 的理解：</p>
<p><strong>注意</strong>与0-1背包的区别：</p>
<p>对于0-1 背包，物品大小为正数，可以先对二维数组初始化第0行（除<span class="math inline">\([0][0]\)</span> 位置外全为0）和第0列（全为1）。然后 i 和 j 都从1开始遍历。 对于该问题，列表中可能存在为 0 的元素，因此<strong>选不选这个0，都能将容量为0的背包装满</strong>。如，<code>nums=&#123;0,0&#125;,target=0,dp[2][0]≠1</code>。</p>
<p>所以base case 只有 <span class="math inline">\(dp[0][0]=1\)</span>, 剩下的第0列的其他位置的值用状态转移方程确定 （而不能将 <span class="math inline">\(dp[i][0]\)</span>初始化为1） 。即 i 从1开始遍历，j 从0开始遍历。</p></li>
<li><p>优化：将二维<code>dp</code>数组压缩为一维，<strong><code>dp[i][j]</code>都是通过上一行<code>dp[i-1][..]</code>转移过来的</strong>，之前的数据都不会再使用了。需要注意的是 <code>j</code>应该从后往前反向遍历，因为每个物品（数字）只能用一次，以免之前的结果影响其他的结果。</p>
<ol type="1">
<li><p>子问题：</p>
<p><span class="math inline">\(x = dp[i]\)</span> 表示数组 <code>nums</code> 的元素 装满 容量为 i 的背包，有 x 种装法。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0] = 1\)</span> 全部不装，一种装法。</p></li>
<li><p>状态转移方程</p>
<p>由上面的二维可得$ dp[j] = dp[j] + dp[j - num]$</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(S &gt; sum || (sum + S) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> target = (sum + S) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">//base case//放入背包重量为0的方案数为1，不选</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= num)</span><br><span class="line">                    dp[j] = dp[j] + dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>另一种方法：递归</p>
<p>对于第 i 个数，可以 ‘+’ 或 '-'，分别递归搜索两种操作，当搜索完一遍，如果元素和sum等于S，count+1。、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="number">0</span>, S);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> sum, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(i == nums.length)&#123;</span><br><span class="line">          <span class="keyword">if</span>(sum == S)</span><br><span class="line">              count++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//还没全部搜索完，递归两种情况</span></span><br><span class="line">          helper(nums, i + <span class="number">1</span>, sum + nums[i], S);</span><br><span class="line">          helper(nums, i + <span class="number">1</span>, sum - nums[i], S);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="一和零medium">474，一和零，medium</h5>
<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 m 和 n 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p>
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m &#x3D; 5, n &#x3D; 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m &#x3D; 1, n &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= <code>strs.length</code>&lt;= 600 1 &lt;= <code>strs[i].length</code> &lt;= 100 <code>strs[i]</code> 仅由 '0' 和 '1' 组成 1 &lt;= m, n &lt;= 100</p>
<ul>
<li><p>题目解析：</p>
<p>仍然是 0-1背包问题，但此题的背包有两个，一个放0，一个放1，称为背包0 和 背包1。物品：字符串数组中的字符。为最大最小问题。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i][j][k]\)</span> — 前 i 个字符串将 背包0容量为 j，背包1容量为k 的最大子集大小</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0][...][...]=0\)</span> 如果不使用任何一个字符串，则背包能装的字符串数就为0。</p>
<p><span class="math inline">\(dp[...][0][0]=0\)</span> 如果背包0，背包1的容量都为0，它能装的字符串数也为0。</p></li>
<li><p>状态转移方程</p>
<p>当前字符串str</p>
<ul>
<li><p>如果字符串<code>str</code>不装入背包，受上一状态影响。</p>
<p><span class="math inline">\(dp[i][j][k]=dp[i-1][j][k]\)</span></p></li>
<li><p>如果字符串<code>str</code> 装入背包，则与不装入的选择取最大值。</p>
<p><span class="math inline">\(dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-count_0][j-count_1] + 1)\)</span></p></li>
</ul>
<p>边界条件为 j 与 <code>str</code> 中0 的数量 的大小关系，k 与 <code>str</code> 中 1 的数量的大小关系。</p></li>
<li><p>返回 <span class="math inline">\(dp[len][m][n]\)</span></p></li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>][m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//base case dp[0][...][...]=0、dp[...][0][0]=0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先循环物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            String str = strs[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n + <span class="number">1</span>; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j &lt; count_0(str) || k &lt; count_1(str))</span><br><span class="line">                    dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    dp[i][j][k] = Math.max(dp[i - <span class="number">1</span>][j][k], dp[i - <span class="number">1</span>][j - count_0(str)][k - count_1(str)] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len][m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计str中0和1的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count_0</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str_c = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str_c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count_1</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str_c = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str_c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>状态压缩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            String str = strs[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= count_0(str); j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = n; k &gt;= count_1(str); k--)&#123;</span><br><span class="line">                    dp[j][k] = Math.max(dp[j][k], dp[j - count_0(str)][k - count_1(str)] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计str中0和1的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count_0</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str_c = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str_c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count_1</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str_c = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str_c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>思考：为什么背包0 和 背包1的 j、k要从 0 开始遍历？</p>
<p>字符串数组中如果存在“00”，“00”，选择也是不同的，会影响<span class="math inline">\(dp\)</span> 数组的结果。可参考494题中对 base case 的理解。</p></li>
</ul>
<h5 id="背包总结">0-1背包总结</h5>
<p>做题步骤：</p>
<ol type="1">
<li><p><strong>理解题意</strong>，判定此题为 0-1背包问题</p></li>
<li><p>此题是否有<strong>特殊情况</strong></p></li>
<li><p><strong>动态规划</strong>正常做法 1. 子问题：确定背包和物品指代什么，<span class="math inline">\(dp[i][j]\)</span> 返回值是什么 2. base case：通常为 <span class="math inline">\(dp[0][...]、dp[...][0]、dp[0][0]\)</span> 3. 状态转移方程： 先遍历物品，再遍历背包。每个物品只有装和不装两个选择。</p>
<p>组合问题公式 dp[i] += dp[i - num] True、False问题公式 dp[i] = dp[i] or dp[i - num] 最大最小问题公式 dp[i] = min(dp[i], dp[i - num]+1) 或 dp[i] = max(dp[i], dp[i - num]+1)</p></li>
<li><p>最终<strong>返回结果</strong></p></li>
<li><p><strong>状态压缩</strong>至一维（可不进行）</p></li>
</ol>
<p>套模板还是有用的，难的部分在于理清题意再转化到模板。base case 的情况容易混淆，分不清的时候先写出多维dp数组，再进行降维可能还有助于做题。 完全背包问题请见下一节总结内容。</p>
<h2 id="二完全背包问题">二、完全背包问题</h2>
<h5 id="完全背包问题引入">完全背包问题引入</h5>
<ul>
<li><p>完全背包的特点：物品可以无限次选取，且<strong>不考虑顺序</strong>。</p></li>
<li><p>与0-1背包不同在：</p>
<ul>
<li><p>0-1背包考虑当前物品装入或不装入背包，物品<strong>只有一件</strong>。</p></li>
<li>完全背包考虑当前物品装入或不装入背包，物品的数量<strong>无限</strong>，只要背包容量还有剩余就可以一直拿同一种物品。</li>
</ul></li>
<li><p>完全背包的变体问题：物品可以无限次选取，且<strong>考虑物品放入的顺序</strong>。</p></li>
</ul>
<p>下面在具体题目中进行总结。</p>
<h5 id="零钱兑换medium">322，零钱兑换，medium</h5>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 &#x3D; 5 + 5 + 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：coins &#x3D; [1], amount &#x3D; 0</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：coins &#x3D; [1], amount &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line">输入：coins &#x3D; [1], amount &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= <code>coins.length</code> &lt;= 12 1 &lt;= <code>coins[i]</code> &lt;= 231 - 1 0 &lt;= <code>amount</code> &lt;= 104</p>
<h6 id="解法一二维先遍历物品再遍历背包">解法一：二维（先遍历物品，再遍历背包）</h6>
<ul>
<li><p>题目解析：</p>
<p>数组的元素可以使用多次，对顺序没有要求，完全背包问题。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i][j]\)</span> 前 i 个硬币组成总金额 j，所需最少硬币个数。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[..][0] = 0\)</span> 金额为0，不取硬币。</p>
<p><strong>特殊情况：</strong></p>
<p>此题中若无法组成总金额，需返回 -1。思考怎么实现呢？</p>
<p>把二维数组 <span class="math inline">\(dp\)</span> 初始化成最大值 <code>amount + 1</code>（硬币面额最少为1），如果发现没更新则说明无法取硬币组成总金额，返回 -1。</p></li>
<li><p>递推关系</p>
<p>最小问题，取min。当前coin = coins[i-1]</p>
<ul>
<li><p>不选 coin，最少硬币个数不变，总金额不变。</p>
<p><span class="math inline">\(dp[i][j] = dp[i - 1][j]\)</span></p></li>
<li><p>选 coin，最少硬币个数 + 1。因为完全背包问题可以<strong>多次选取同一物品，所以为 <span class="math inline">\(dp[i][j - coin]\)</span></strong>，与 0-1背包的区别就体现在此。</p>
<p><span class="math inline">\(dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - coin] + 1)\)</span></p></li>
</ul></li>
</ol></li>
<li><p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化dp表，默认值为极大值，代表无解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i], amount + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//base case</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> coin = coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= coin)</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - coin] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                     dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][amount] &gt; amount ? -<span class="number">1</span>: dp[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>状态压缩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">         Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> coin = coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= coin)</span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span>: dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="解法二一维先遍历背包再遍历物品">解法二：一维（先遍历背包，再遍历物品）</h6>
<ul>
<li><p>题目解析：</p>
<p>数组的元素可以使用多次，对顺序没有要求，完全背包问题。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i]\)</span> 硬币组成金额为 i ，所需最少硬币个数。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0] = 0\)</span> 金额为0，不取硬币。</p></li>
<li><p>递推关系</p>
<p>以 coins=[1,2,5] amount = 11 为例</p>
<p>k 枚硬币 <code>a1，... ,ak</code> 总和为 11，即 <span class="math inline">\(dp[11] = k\)</span>，上一状态就是 <span class="math inline">\(dp[11-ak] = k-1\)</span></p>
<p>状态转移方程为：</p>
<p><span class="math inline">\(dp[i]=min(dp[i-coin])+1\)</span>，<code>for coin in coins  and if  i &gt;= coin</code></p></li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特殊判断，可有可无</span></span><br><span class="line">        <span class="keyword">if</span>(coins.length == <span class="number">1</span> &amp;&amp; amount % coins[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">              </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//硬币面额至少为1，最多为amount</span></span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//外循环为dp数组从1开始的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//内循环为 coins 数组元素值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> coin = coins[j];</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= coin)</span><br><span class="line">                    <span class="comment">//得到上一状态的最小值</span></span><br><span class="line">                    dp[i] = Math.min((dp[i - coin] + <span class="number">1</span>), dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">       <span class="comment">//如果dp[amount]没更新，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span>: dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="零钱兑换medium-1">518，零钱兑换Ⅱ，medium</h5>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: amount &#x3D; 5, coins &#x3D; [1, 2, 5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;2+2+1</span><br><span class="line">5&#x3D;2+1+1+1</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: amount &#x3D; 3, coins &#x3D; [2]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 只用面额2的硬币不能凑成总金额3。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: amount &#x3D; 10, coins &#x3D; [10] </span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<p>你可以假设：</p>
<p>0 &lt;= amount (总金额) &lt;= 5000 1 &lt;= coin (硬币面额) &lt;= 5000 硬币种类不超过 500 种 结果符合 32 位符号整数</p>
<ul>
<li><p>题目解析：</p>
<p>数组的元素可以使用多次，对顺序没有要求，完全背包问题。组合问题。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i][j]\)</span> — 前 i 个硬币组成金额 j 的组合数。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[..][0] = 1\)</span> 全部都不拿，只有这一种拿法。</p></li>
<li><p>递推关系</p>
<p><span class="math inline">\(dp[i][j]\)</span> 取决于是否选择 coin = coins[i-1]</p>
<ul>
<li>如果不选（即不将 coin 装入背包），<span class="math inline">\(dp[i][j] = dp[i - 1][j]\)</span></li>
<li>如果选（即将 coin 装入背包），<span class="math inline">\(dp[i][j] = dp[i][j-coin]\)</span>，注意<strong>此处与 0-1背包 不同，硬币还可再选取。</strong></li>
</ul>
<p>要得到总的组合数，状态转移方程为：</p>
<p><span class="math inline">\(dp[i][j] = dp[i - 1][j] + dp[i][j-coin]\)</span></p></li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> coin = coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= coin)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coin];</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>状态压缩：通过观察可以发现，<code>dp</code>数组的转移只和<code>dp[i][..]</code>和<code>dp[i-1][..]</code>有关，所以可以压缩状态，进一步降低算法的空间复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> coin = coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= coin)</span><br><span class="line">                    dp[j] += dp[j - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>下面两题为完全背包的变体：物品可以无限次选取，且<strong>考虑物品放入背包的顺序</strong>。</p>
<h5 id="组合总和medium">377，组合总和Ⅳ，medium</h5>
<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">target &#x3D; 4</span><br><span class="line"></span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line">因此输出为 7。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>题意分析</p>
<p>完全背包问题的变体：</p>
<p>数组的每个元素可以使用多次，直到等于target。</p>
<p>不同于完全背包：顺序不同的序列被视作不同的组合。</p></li>
<li><p>思路：</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i]\)</span> —数组的元素组合为 i 的个数。</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0] = 1\)</span> 所有数都不选，只有一种。</p></li>
<li><p>状态转移方程</p>
<figure>
<img src="https://img-blog.csdnimg.cn/img_convert/00df062b020fa03ff81e0a7000b1f3df.png" alt="image.png" /><figcaption>image.png</figcaption>
</figure>
<p>以 <code>nums =[1,2,3]，target = 4</code> 为例，</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210108113212272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>即将 <code>target = 4</code> 拆分为 <code>nums[i]</code> 和 <code>dp[target - nums[i]]</code>，最终得到 <span class="math inline">\(dp[4] = dp[3] + dp[2] + dp[1]\)</span></p>
<p>则状态转移方程为：</p>
<p><span class="math inline">\(dp[i] = sum(dp[i - num])\)</span> <code>for num in nums and if i &gt;= num</code></p></li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= i)&#123;</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="单词拆分medium">139，单词拆分，medium</h5>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<ul>
<li><p>题意分析</p>
<p>完全背包问题的变体：物品(<code>wordDict</code>中的单词)可以无限使用，直到填满背包（字符串s）。TRUE / False 问题。</p></li>
<li><p>思路</p>
<ol type="1">
<li><p>子问题</p>
<p><span class="math inline">\(dp[i]\)</span> 字符串前 i 个字符组成的字符串 s[0,i-1] 能否拆分为 <code>wordList</code> 中的单词</p></li>
<li><p>base case</p>
<p><span class="math inline">\(dp[0] = 0\)</span> 表示空串且合法。</p></li>
<li><p>递推关系</p>
<p>对于物品（<code>wordDict</code> 中的单词），要求有顺序放入背包（字符串s），则将物品迭代置于内循环，将背包迭代放在外循环，这样才能让物品按一定顺序放入背包中。</p>
<p>如果有单词 等于 字符串s的一部分，需要检查后面的字符串是否能放入背包。</p>
<p><span class="math inline">\(dp[i] = dp[i] | dp[i - len];\)</span><img src="https://img-blog.csdnimg.cn/20210108114808230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210108114808238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgxODM5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p></li>
</ol></li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//s 为背包</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String word : wordDict)&#123;</span><br><span class="line">                <span class="keyword">int</span> len = word.length();</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= len &amp;&amp; word.equals(s.substring(i-len, i)))</span><br><span class="line">                    dp[i] = dp[i] | dp[i - len];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="完全背包问题总结">完全背包问题总结</h5>
<p><strong>做题步骤</strong>：</p>
<ol type="1">
<li><p><strong>理解题意</strong>，判定此题为 完全背包问题 或 完全背包问题的变体。根据所求分为组合问题，True/False问题，最大最小问题。通常用<strong>一维 <span class="math inline">\(dp\)</span> 数组</strong>解题。</p></li>
<li><p>此题是否有<strong>特殊情况</strong></p></li>
<li><p><strong>动态规划</strong>正常做法</p>
<ol type="1">
<li><p>子问题：确定背包和物品指代什么，<span class="math inline">\(dp[i]\)</span> 返回值是什么</p>
<ol start="2" type="1">
<li>base case：通常为 <span class="math inline">\(dp[0]\)</span></li>
</ol></li>
<li><p>状态转移方程： <strong>先遍历背包，再遍历物品。</strong>这样才能保证放入顺序。</p></li>
</ol>
<p>组合问题公式 dp[i] += dp[i - num] True/False问题公式 dp[i] = dp[i] or dp[i - num] 最大最小问题公式 dp[i] = min(dp[i], dp[i - num]+1) 或 dp[i] = max(dp[i], dp[i - num]+1)</p></li>
<li><p>最终<strong>返回结果</strong></p></li>
</ol>

    </div>

    
    
    
	
	
      <div>
        
    <div style="text-align:center;color: #ccc;font-size:14px;">
        ------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div>
    
      </div>
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag"># 动态规划</a>
              <a href="/tags/LeetCode%E5%88%B7%E9%A2%98/" rel="tag"># LeetCode刷题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/01/06/idea%E5%AF%BC%E5%85%A5Github%E5%88%86%E6%94%AF/" rel="prev" title="idea导入Github分支">
                  <i class="fa fa-chevron-left"></i> idea导入Github分支
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/01/12/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E9%97%AE%E9%A2%98/" rel="next" title="一文解决股票交易问题">
                  一文解决股票交易问题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rui Wang</span>
</div>

<!---->

  <div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站总访客数:<span id="busuanzi_value_site_uv"></span>&nbsp;&nbsp;| 
  </span>
  <span id="busuanzi_container_site_pv">
      &nbsp;本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  </div>
  </div>
    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
