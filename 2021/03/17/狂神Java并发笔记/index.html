<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"8.0.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="1. 进程与线程（Process与Thread） 程序：指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。 进程：是执行程序的一次执行过程，是一个动态的概念。是系统资源分配的单位。 一个进程可以包含有多个线程，一个进程至少有一个线程，否则无存在的意义。 线程：CPU调度和执行的单位。">
<meta property="og:type" content="article">
<meta property="og:title" content="狂神Java并发笔记">
<meta property="og:url" content="http://example.com/2021/03/17/%E7%8B%82%E7%A5%9EJava%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Rui">
<meta property="og:description" content="1. 进程与线程（Process与Thread） 程序：指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。 进程：是执行程序的一次执行过程，是一个动态的概念。是系统资源分配的单位。 一个进程可以包含有多个线程，一个进程至少有一个线程，否则无存在的意义。 线程：CPU调度和执行的单位。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/39a6910a790933c20b2aa1f302dfc6ea.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/badc83ff799c2d727089aba680e453d2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/108e386949a520c6eb084bcc7fe70372.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/a56c8095f6782a3517339f78b7cc4ff6.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/9eafafb7112df45773906f4eeb2f515a.png#align=left&amp;display=inline&amp;height=147&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=293&amp;originWidth=761&amp;size=105440&amp;status=done&amp;style=none&amp;width=380.5">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/f64bdb285926fd726d3b06f5477dad11.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/70228c6c057d156188aa5e45ede3505f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ab99086261f260d0ba83fc9b54eca9bc.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/cfb96bc0219288871881585ac0de1674.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/9b298df8177413bdfb52947fbffd48cc.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/7794bf24d96021e2fa1ddbd0015e8b5a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4e02ebe6058f187ae111d2da67aabaab.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/15614631c903ea1718049031fafc6a89.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/16de8669f3a04cac3ffef40099facb86.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/6af5f339a22f0c3c255ede460ff6d9a9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/09bf0d3841ca41c4a429c2a730ab7436.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/145a1983f1eb9aafde4da1c095cea027.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/793a4006c3400d360c15fc06af8e8118.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/0a23b78a3b21e80e7eae825d108f4c7f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/7073e65aa6691eaf2af7743c3c3c1b61.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/b68e21752b69b500b0cbe0da27a30913.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/806060b441322a9be7805a0f9e8ce42e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/d1d0b7d0a863d5ed76a1bf476a246d13.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/6c7b4c5a150de2552478e4a3a426c87c.png">
<meta property="article:published_time" content="2021-03-17T07:28:41.000Z">
<meta property="article:modified_time" content="2021-03-17T07:34:28.414Z">
<meta property="article:author" content="Rui Wang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/img_convert/39a6910a790933c20b2aa1f302dfc6ea.png">


<link rel="canonical" href="http://example.com/2021/03/17/%E7%8B%82%E7%A5%9EJava%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>狂神Java并发笔记 | Rui</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

  
  <script type="text/javascript" src="/js/my_js/clicklove.js"></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/rss2.xml" title="Rui" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Rui</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8Bprocess%E4%B8%8Ethread"><span class="nav-text">1. 进程与线程（Process与Thread）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">核心概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E9%87%8D%E7%82%B9"><span class="nav-text">2. 线程创建（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BFthread%E7%B1%BB"><span class="nav-text">1）、继承Thread类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0runnable%E6%8E%A5%E5%8F%A3"><span class="nav-text">2）、实现Runnable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0callable%E6%8E%A5%E5%8F%A3%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF"><span class="nav-text">3）、实现Callable接口（了解即可）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">3. 静态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#start%E4%B8%8Erun%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">start()与run()方法的区别：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">4. Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-text">1.作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.函数式接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lambda%E7%AE%80%E5%8D%95%E6%8E%A8%E5%AF%BC"><span class="nav-text">3.lambda简单推导</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-text">5. 线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81-1"><span class="nav-text">1、线程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">2、线程停止的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="nav-text">3、线程休眠</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9---yield"><span class="nav-text">4、线程礼让 - yield()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%BC%BA%E5%88%B6%E6%89%A7%E8%A1%8C---join"><span class="nav-text">5、线程强制执行 - join()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E6%B5%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-text">6、观测线程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">7、线程的优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B---setdaemontrue"><span class="nav-text">8、守护线程 - setDaemon(true)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%87%8D%E7%82%B9%E9%9A%BE%E7%82%B9"><span class="nav-text">6. 线程同步（重点、难点）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">6.1 线程同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E4%B8%8D%E5%AE%89%E5%85%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">6.2 三大不安全案例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%B0%E7%A5%A8"><span class="nav-text">(1)买票</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%93%B6%E8%A1%8C"><span class="nav-text">(2)不安全的银行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="nav-text">(3)不安全的集合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%9D%97"><span class="nav-text">6.3 同步方法和同步方法块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-text">同步方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">同步代码块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text">7. 死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-text">1、定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%E6%96%B9%E6%B3%95"><span class="nav-text">2.死锁避免方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lock%E9%94%81"><span class="nav-text">8. Lock锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized%E4%B8%8Elock%E5%AF%B9%E6%AF%94"><span class="nav-text">synchronized与Lock对比</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-text">9. 线程通信—生产者消费者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a.%E7%AE%A1%E7%A8%8B%E6%B3%95"><span class="nav-text">a.管程法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">10. 线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">使用线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if-you-get-gainsplease-give-a-like"><span class="nav-text">If you get gains，please give a like！</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rui Wang"
      src="https://upload.jianshu.io/users/upload_avatars/525624/28c068b9-5f2b-4ff8-bc40-3a9e53773228.jpeg?imageMogr2/auto-orient/strip|imageView2/1/w/80/h/80/format/webp">
  <p class="site-author-name" itemprop="name">Rui Wang</p>
  <div class="site-description" itemprop="description">去摘遥不可及的星星</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/17/%E7%8B%82%E7%A5%9EJava%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://upload.jianshu.io/users/upload_avatars/525624/28c068b9-5f2b-4ff8-bc40-3a9e53773228.jpeg?imageMogr2/auto-orient/strip|imageView2/1/w/80/h/80/format/webp">
      <meta itemprop="name" content="Rui Wang">
      <meta itemprop="description" content="去摘遥不可及的星星">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rui">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          狂神Java并发笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-17 15:28:41 / 修改时间：15:34:28" itemprop="dateCreated datePublished" datetime="2021-03-17T15:28:41+08:00">2021-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="进程与线程process与thread">1. 进程与线程（Process与Thread）</h2>
<p>程序：指令和数据的有序集合，其本身没有任何运行的含义，是<u>一个静态的概念</u>。 进程：是执行程序的一次执行过程，是一个<u>动态的概念</u>。是系统资源分配的单位。 一个进程可以包含有多个线程，一个进程<strong>至少</strong>有一个线程，否则无存在的意义。 线程：<strong>CPU调度和执行的单位</strong>。</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/img_convert/39a6910a790933c20b2aa1f302dfc6ea.png" /> 多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发。</p>
<h3 id="核心概念">核心概念</h3>
<ul>
<li>线程就是独立的执行路径；</li>
<li>在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程；</li>
<li>main()称为主线程，为系统的入口，用于执行整个程序；</li>
<li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能认为干预的；</li>
<li>对同一份资源操作时，会存在资源抢夺问题，需要加入并发控制；</li>
<li>线程会带来额外的开销，如CPU调度时间，并发控制开销；</li>
<li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</li>
</ul>
<h2 id="线程创建重点">2. 线程创建（重点）</h2>
<p><img src="https://img-blog.csdnimg.cn/img_convert/badc83ff799c2d727089aba680e453d2.png" /></p>
<h3 id="继承thread类">1）、继承Thread类</h3>
<p>a.创建Thread类 b.重写run()方法 c.调用start()开启线程 <img src="https://img-blog.csdnimg.cn/img_convert/108e386949a520c6eb084bcc7fe70372.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建线程方式一：继承Thread类，重写run()方法，调用start()开启线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//run方法线程体</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;我在看代码&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//main线程，主线程</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建一个线程对象</span></span><br><span class="line">		Test01 t= <span class="keyword">new</span> Test01();</span><br><span class="line"><span class="comment">//		t.run();     调用run()方法，执行完run方法体再执行main方法体</span></span><br><span class="line">		<span class="comment">//调用start()方法开启线程     同时执行</span></span><br><span class="line">		t.start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">			System.out.println(“我在学多线程<span class="string">&quot;+i);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>总结：<strong>线程开启不一定立即执行，由CPU调度执行</strong></p>
<h3 id="实现runnable接口">2）、实现Runnable接口</h3>
<p>a.实现Runnable接口 b.重写run(）方法 c.创建线程对象，调用start()方法启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//run方法线程体</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;我在看代码&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建Runnable接口的实现类对象</span></span><br><span class="line">		Test01 t= <span class="keyword">new</span> Test01();</span><br><span class="line">        <span class="comment">//创建线程对象，通过线程对象来开启线程，代理</span></span><br><span class="line">		<span class="comment">//Thread thread = new Thread(t);</span></span><br><span class="line">        <span class="comment">//thread.start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread(t).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">			System.out.println(“我在学多线程<span class="string">&quot;+i);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="小结">小结</h3>
<p>以上两者区别</p>
<ul>
<li>继承Thread类：
<ul>
<li>子类继承Thread类具备多线程能力</li>
<li>启动线程：子类对象.start()</li>
<li>不建议使用：避免OOP单继承局限性</li>
</ul></li>
<li>实现Runnable接口
<ul>
<li>实现Runnable接口具备多线程能力</li>
<li>启动线程：new Thread(子类对象).start()</li>
<li><strong>推荐使用</strong>：<strong>避免单继承局限性，方便同一个对象被多个线程使用</strong></li>
</ul></li>
</ul>
<p>练习：买票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//票数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ticketNums&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//模拟延时</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">200</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;拿到了第&quot;</span>+ticketNums-- +<span class="string">&quot;票&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestTread ticket = <span class="keyword">new</span> TestTread();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(ticket,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(ticket,<span class="string">&quot;老师&quot;</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(ticket,<span class="string">&quot;黄牛&quot;</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现问题：不同的人拿到了同一张票。多个线程操作同一资源的情况下，线程不安全，数据紊乱。</p>
<h3 id="实现callable接口了解即可">3）、实现Callable接口（了解即可）</h3>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a56c8095f6782a3517339f78b7cc4ff6.png" /></p>
<h2 id="静态代理">3. 静态代理</h2>
<p>——多线程底层实现原理 例子： 真实角色:你； 代理角色:婚庆公司； 结婚:实现结婚接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		WeddingCompany company = <span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You());</span><br><span class="line">		company.happyMarry();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;结婚了真开心！&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理角色，帮助你结婚</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Marry target;</span><br><span class="line">	<span class="comment">//target传入真实目标角色</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry target)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		before();</span><br><span class="line">		<span class="keyword">this</span>.target.happyMarry();<span class="comment">//这就是真实对象</span></span><br><span class="line">		after();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;结婚之后，收尾款&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;结婚前，布置现场&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结：</h3>
<p>静态代理有如下要素： 1.目标角色（真实角色）。 2.代理角色。 3.目标角色和代理角色实现同一接口。 4.代理角色持有目标角色的引用。</p>
<p><strong>优点</strong>：代理对象可以做很多真实对象不能做的事情， 真实对象专注自己的事情</p>
<p>结合线程来看： 线程体（也就是我们要执行的具体任务）实现了Runnable接口和run方法。 同时Thread类也实现了Runnable接口。此时，线程体就相当于目标角色，Thread就相当于代理角色。当程序调用了Thread的start()方法后，Thread的run()方法会在某个特定的时候被调用。 Thread类中对Runnable接口的run方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">           target.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="start与run方法的区别">start()与run()方法的区别：</h3>
<ul>
<li>start：用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。</li>
<li>run： run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</li>
<li>总结：调用start方法方可启动线程，真正实现了多线程运行。而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。</li>
</ul>
<h2 id="lambda表达式">4. Lambda表达式</h2>
<ul>
<li>避免匿名内部类定义过多</li>
<li>实质属于函数式编程的概念</li>
</ul>
<p><strong><img src="https://img-blog.csdnimg.cn/img_convert/9eafafb7112df45773906f4eeb2f515a.png#align=left&amp;display=inline&amp;height=147&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=293&amp;originWidth=761&amp;size=105440&amp;status=done&amp;style=none&amp;width=380.5" alt="image.png" /></strong></p>
<h5 id="作用">1.<strong>作用</strong></h5>
<ul>
<li>避免匿名内部类定义过多</li>
<li>使代码看起来简介</li>
<li>简化代码，只留下核心逻辑</li>
</ul>
<h5 id="函数式接口">2.<strong>函数式接口</strong></h5>
<p>定义：任何接口，如果只包含唯一一个抽象方法，那么它就是一个<strong>函数式接口</strong> <img src="https://img-blog.csdnimg.cn/img_convert/f64bdb285926fd726d3b06f5477dad11.png" /> 对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。</p>
<h5 id="lambda简单推导">3.lambda简单推导</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 推导Lambda表达式</span></span><br><span class="line"><span class="comment"> * 一步步简化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">Ilike</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i like lambda2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ilike like = <span class="keyword">new</span> Like();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        like = <span class="keyword">new</span> Like2();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">Ilike</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i like lambda4&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        like = <span class="keyword">new</span> Like3();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.匿名内部类</span></span><br><span class="line">        like = <span class="keyword">new</span> Ilike() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i like lambda5&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.用lambda简化</span></span><br><span class="line">        like = ()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i like lambda5&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.定义一个函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Ilike</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Like</span> <span class="keyword">implements</span> <span class="title">Ilike</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i like lambda&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li><p>lambda表达式只能有一行代码的情况下才能简化成为一行，如果有多行，那么就用代码块包裹。</p></li>
<li><p>lambda表达式的前提是接口为函数式接口。</p></li>
<li><p>多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号。</p></li>
</ul>
<h2 id="线程状态">5. 线程状态</h2>
<h3 id="线程状态-1">1、线程状态</h3>
<p><img src="https://img-blog.csdnimg.cn/img_convert/70228c6c057d156188aa5e45ede3505f.png" /></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ab99086261f260d0ba83fc9b54eca9bc.png" /></p>
<h3 id="线程停止的方法">2、线程停止的方法</h3>
<ul>
<li>建议线程正常停止（自己停下来）——&gt;利用次数，不建议死循环</li>
<li>建议使用标志位进行终止变量——&gt;设置一个标志位flag，当flag = false，则终止线程运行。</li>
<li>不要使用stop或者destroy等过时或者JDK不建议使用的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.设置一个标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run...Thread&quot;</span>+ i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置一个公开的方法停止线程，转换标志位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestStop stop = <span class="keyword">new</span> TestStop();</span><br><span class="line">        <span class="keyword">new</span> Thread(stop).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">900</span>)&#123;</span><br><span class="line">                <span class="comment">//调用stop方法切换标志位，让线程停止</span></span><br><span class="line">                stop.stop();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程停止了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h3 id="线程休眠">3、线程休眠</h3>
<ul>
<li>leep(时间)指定当前线程阻塞的毫秒数；</li>
<li>sleep存在异常InterruptedException；</li>
<li>sleep时间达到后线程进入就绪状态；</li>
<li>sleep可以模拟网络延时，倒计时等；</li>
<li>每一个对象都有一个锁，<strong>sleep不会释放锁。</strong></li>
</ul>
<h3 id="线程礼让---yield">4、线程礼让 - yield()</h3>
<ul>
<li>礼让线程，让当前正在执行的线程暂停，但不阻塞；</li>
<li>将线程从运行状态转为就绪状态;</li>
<li>让CPU重新调度，<strong>礼让不一定成功</strong>，看CPU心情。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyYield myYield = <span class="keyword">new</span> MyYield();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(myYield,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;START&quot;</span>);</span><br><span class="line">        Thread.yield();   <span class="comment">//礼让</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不进行礼让（或礼让但失败了）：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cfb96bc0219288871881585ac0de1674.png" /></p>
<p>进行礼让且礼让成功：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9b298df8177413bdfb52947fbffd48cc.png" /></p>
<h3 id="线程强制执行---join">5、线程强制执行 - join()</h3>
<ul>
<li>join合并线程，待此线程执行完后，再执行其它线程，其它线程阻塞；</li>
<li>可以想象成插队</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程VIP来了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestJoin testJoin = <span class="keyword">new</span> TestJoin();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(testJoin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">200</span>)&#123;</span><br><span class="line">                thread.start();</span><br><span class="line">                thread.join(); <span class="comment">//插队</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;main&quot;</span>+i);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果： <img src="https://img-blog.csdnimg.cn/img_convert/7794bf24d96021e2fa1ddbd0015e8b5a.png" /></p>
<p>线程插队，执行完（打印100次）之后再执行主线程</p>
<h3 id="观测线程状态">6、观测线程状态</h3>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4e02ebe6058f187ae111d2da67aabaab.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;///&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//观察状态</span></span><br><span class="line">        Thread.State state = thread.getState();</span><br><span class="line">        System.out.println(state);    <span class="comment">//NEW</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//观察后启动</span></span><br><span class="line">        thread.start();   <span class="comment">//启动线程</span></span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println();   <span class="comment">//Runnable</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(state != Thread.State.TERMINATED)&#123;  <span class="comment">//只要线程不停止，就一直输出状态</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            state = thread.getState();    <span class="comment">//更新线程状态</span></span><br><span class="line">            System.out.println(state);   <span class="comment">//输出状态</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//thread.start();   报错，因为已经死亡的线程不能再启动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果： <img src="https://img-blog.csdnimg.cn/img_convert/15614631c903ea1718049031fafc6a89.png" /></p>
<h3 id="线程的优先级">7、线程的优先级</h3>
<ul>
<li>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级来决定应该调度哪个线程来执行。</li>
<li>线程的优先级用数字表示，范围从1~10.
<ul>
<li>Thread.MIN_PRIORITY = 1;</li>
<li>Thread.MAX_PRIORITY = 10;</li>
<li>Thread.NORM_PRIORITY = 5;</li>
</ul></li>
<li>使用一下方法改变或获取优先级</li>
</ul>
<p><code>getPriority.setPriority(int xxx)</code></p>
<ul>
<li>优先级的设定建议在start()调度前</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPriority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//主线程默认优先级</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority());</span><br><span class="line"></span><br><span class="line">        MyPriority myPriority = <span class="keyword">new</span> MyPriority();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t6 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先设置优先级，再启动</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        t2.setPriority(<span class="number">1</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t3.setPriority(<span class="number">4</span>);</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        t4.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        t5.setPriority(-1);   //Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span></span><br><span class="line"><span class="comment">//        t5.start();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        t6.setPriority(11);   //Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span></span><br><span class="line"><span class="comment">//        t6.start();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPriority</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果： <img src="https://img-blog.csdnimg.cn/img_convert/16de8669f3a04cac3ffef40099facb86.png" /> <strong>总结</strong>：优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了。这都看CPU的调度。</p>
<h3 id="守护线程---setdaemontrue">8、守护线程 - setDaemon(true)</h3>
<ul>
<li>线程分为<strong>用户线程</strong>和<strong>守护线程</strong></li>
<li>虚拟机必须确保用户线程执行完毕 （如，main）</li>
<li>虚拟机不用等待守护线程执行完毕 （如，后台记录操作日志，监控内存，垃圾回收……）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上帝守护你</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaemon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        You you = <span class="keyword">new</span> You();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);   <span class="comment">//默认false表示是用户线程，正常的线程都是用户线程</span></span><br><span class="line"></span><br><span class="line">        thread.start();  <span class="comment">//上帝守护线程启动</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(you).start();   <span class="comment">//你 用户线程启动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上帝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上帝保佑你&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//你</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">36500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你一生都开心的活着&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====GoodBye World!======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：You的线程执行完毕，虚拟机即可进行GC。</p>
<h2 id="线程同步重点难点">6. 线程同步（重点、难点）</h2>
<h3 id="线程同步">6.1 线程同步</h3>
<p>并发：<strong>同一个对象</strong>被<strong>多个线程</strong>同时操作 （如：上万人同时抢票）</p>
<ul>
<li>处理多线程问题时，多线程访问同一个对象(并发)，并且某些线程还想修改这个对象。这时则需要线程同步。</li>
<li><strong>线程同步</strong>其实是一种等待机制，多个需要同时访问此对象的线程进入这个<strong>对象的等待池</strong>形成队列，等待前面的线程使用完毕，下一个线程再使用。</li>
<li>线程同步的形成条件：==队列+锁==（每个对象都有一把锁）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6af5f339a22f0c3c255ede460ff6d9a9.png" /></p>
<h3 id="三大不安全案例">6.2 三大不安全案例</h3>
<h5 id="买票">(1)买票</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程不安全 有负数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBuyTicket</span>  <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;  <span class="comment">//外部停止方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">           buy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有票</span></span><br><span class="line">        <span class="keyword">if</span>(ticketNums&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟延时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;拿到了第&quot;</span>+ticketNums-- +<span class="string">&quot;票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeBuyTicket ticket = <span class="keyword">new</span> UnsafeBuyTicket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;老师&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;黄牛&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果出现负数 <img src="https://img-blog.csdnimg.cn/img_convert/09bf0d3841ca41c4a429c2a730ab7436.png" /></p>
<h5 id="不安全的银行">(2)不安全的银行</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBank</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//账户</span></span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="number">100</span>,<span class="string">&quot;基金&quot;</span>);</span><br><span class="line">        Drawing you = <span class="keyword">new</span> Drawing(account,<span class="number">50</span>,<span class="string">&quot;你&quot;</span>);</span><br><span class="line">        Drawing wo = <span class="keyword">new</span> Drawing(account,<span class="number">100</span>,<span class="string">&quot;我&quot;</span>);</span><br><span class="line"></span><br><span class="line">        you.start();</span><br><span class="line">        wo.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//账户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money; <span class="comment">//余额</span></span><br><span class="line">    String name;  <span class="comment">//卡名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行：模拟取款</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    Account account;  <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">int</span> drawingMoney;  <span class="comment">//取了多少钱</span></span><br><span class="line">    <span class="keyword">int</span> nowMoney;   <span class="comment">//现在手里有多少钱</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Drawing</span><span class="params">(Account account, <span class="keyword">int</span> drawingMoney, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawingMoney = drawingMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取钱</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断有没有钱</span></span><br><span class="line">        <span class="keyword">if</span>(account.money-drawingMoney&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;钱不够，取不了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//try &#123;</span></span><br><span class="line">        <span class="comment">//    Thread.sleep(1000);</span></span><br><span class="line">        <span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line">        <span class="comment">//    e.printStackTrace();</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//卡内余额 = 余额 - 取的钱</span></span><br><span class="line">        account.money = account.money - drawingMoney;</span><br><span class="line">        <span class="comment">//手里的钱</span></span><br><span class="line">        nowMoney = nowMoney + drawingMoney;</span><br><span class="line"></span><br><span class="line">        System.out.println(account.name+<span class="string">&quot;余额为：&quot;</span>+account.money);</span><br><span class="line">        <span class="comment">//this.getName()=Thread.currentThread.getName() 继承了Thread类</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName()+<span class="string">&quot;手里的钱：&quot;</span>+nowMoney);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基金余额为：100</span><br><span class="line">你手里的钱：50</span><br><span class="line">我钱不够，取不了</span><br></pre></td></tr></table></figure>
<p>添加休眠后，you线程暂停，wo线程执行。放大了问题的发生性。 此时测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基金余额为：50</span><br><span class="line">你手里的钱：50</span><br><span class="line">基金余额为：-50</span><br><span class="line">我手里的钱：100</span><br></pre></td></tr></table></figure>
<p>两个人都在余额100时取钱，线程不安全。</p>
<h5 id="不安全的集合">(3)不安全的集合</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               list.add(Thread.currentThread().getName());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：9999</span></span><br></pre></td></tr></table></figure>
<h3 id="同步方法和同步方法块">6.3 同步方法和同步方法块</h3>
<h4 id="同步方法">同步方法</h4>
<ul>
<li><p>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：==synchronized方法和synchronized块==</p>
<p><code>同步方法: public synchronized void method(int args) &#125;</code></p></li>
<li><p>synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁,继续执行。</p>
<p>缺陷：若将一个大的方法申明为synchronized将会影响效率</p></li>
<li><p>方法里需要修改的内容才需要锁，否则浪费资源</p></li>
</ul>
<p>对于刚才买票的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBuyTicket</span>  <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;  <span class="comment">//外部停止方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">           		buy();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            	e.printStackTrace();</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//synchronized 同步方法，锁的是this</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有票</span></span><br><span class="line">        <span class="keyword">if</span>(ticketNums&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟延时</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">     </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;拿到了第&quot;</span>+ticketNums-- +<span class="string">&quot;票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeBuyTicket ticket = <span class="keyword">new</span> UnsafeBuyTicket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;老师&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;黄牛&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：当前这个人买到票才释放锁，才能再买票 <img src="https://img-blog.csdnimg.cn/img_convert/145a1983f1eb9aafde4da1c095cea027.png" /></p>
<h4 id="同步代码块">同步代码块</h4>
<ul>
<li>同步块: <code>synchronized ``(Obj)&#123;&#125;</code></li>
<li>Obj称之为<strong>同步监视器</strong>
<ul>
<li>Obj可以是任何对象,但是推荐使用共享资源作为同步监视器</li>
<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this , 就是这个对象本身，或者是class [反射中讲解]</li>
</ul></li>
<li>同步监视器的执行过程</li>
</ul>
<p>1.第一个线程访问，锁定同步监视器，执行其中代码. 2.第二个线程访问，发现同步监视器被锁定，无法访问. 3.第一个线程访问完毕，解锁同步监视器 4.第二个线程访问， 发现同步监视器没有锁,然后锁定并访问 对于银行取钱的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBank</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//账户</span></span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="number">100</span>,<span class="string">&quot;基金&quot;</span>);</span><br><span class="line">        Drawing you = <span class="keyword">new</span> Drawing(account,<span class="number">50</span>,<span class="string">&quot;你&quot;</span>);</span><br><span class="line">        Drawing wo = <span class="keyword">new</span> Drawing(account,<span class="number">100</span>,<span class="string">&quot;我&quot;</span>);</span><br><span class="line"></span><br><span class="line">        you.start();</span><br><span class="line">        wo.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//账户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money; <span class="comment">//余额</span></span><br><span class="line">    String name;  <span class="comment">//卡名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行：模拟取款</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    Account account;  <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">int</span> drawingMoney;  <span class="comment">//取了多少钱</span></span><br><span class="line">    <span class="keyword">int</span> nowMoney;   <span class="comment">//现在手里有多少钱</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Drawing</span><span class="params">(Account account, <span class="keyword">int</span> drawingMoney, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawingMoney = drawingMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取钱</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//锁的对象就是变化的量，需要增删改的量</span></span><br><span class="line">        <span class="keyword">synchronized</span>(account)&#123;</span><br><span class="line">        	<span class="comment">//判断有没有钱</span></span><br><span class="line">        	<span class="keyword">if</span>(account.money-drawingMoney&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            	System.out.println(Thread.currentThread().getName()+<span class="string">&quot;钱不够，取不了&quot;</span>);</span><br><span class="line">            	<span class="keyword">return</span>;</span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">            	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           	 	e.printStackTrace();</span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line">        	<span class="comment">//卡内余额 = 余额 - 取的钱</span></span><br><span class="line">        	account.money = account.money - drawingMoney;</span><br><span class="line">        	<span class="comment">//手里的钱</span></span><br><span class="line">        	nowMoney = nowMoney + drawingMoney;</span><br><span class="line"></span><br><span class="line">        	System.out.println(account.name+<span class="string">&quot;余额为：&quot;</span>+account.money);</span><br><span class="line">			System.out.println(<span class="keyword">this</span>.getName()+<span class="string">&quot;手里的钱：&quot;</span>+nowMoney);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果： <img src="https://img-blog.csdnimg.cn/img_convert/793a4006c3400d360c15fc06af8e8118.png" /> 如果使用同步方法，锁的是this，是对象本身（银行），对于改变的用户没有用。<u>锁的对象就是变化的量，需要增删改的量。</u></p>
<p>对于集合的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">                    list.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：10000</span></span><br></pre></td></tr></table></figure>
<h2 id="死锁">7. 死锁</h2>
<h3 id="定义">1、定义</h3>
<p>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。 某<u>一个同步块同时拥有“两个以上对象的锁”</u>时，就可能会发生“死锁”的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//死锁：多个线程互相抱着对方需要的资源</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Makeup m1 = <span class="keyword">new</span> Makeup(<span class="number">0</span>,<span class="string">&quot;灰姑凉&quot;</span>);</span><br><span class="line">        Makeup m2 = <span class="keyword">new</span> Makeup(<span class="number">1</span>,<span class="string">&quot;白雪公主&quot;</span>);</span><br><span class="line"></span><br><span class="line">        m1.start();</span><br><span class="line">        m2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//口红</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lipstick</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//镜子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mirror</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//化妆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Makeup</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要的资源只有一份，用static来保证只有一份</span></span><br><span class="line">    <span class="keyword">static</span> Lipstick lipstick = <span class="keyword">new</span> Lipstick();</span><br><span class="line">    <span class="keyword">static</span> Mirror mirror = <span class="keyword">new</span> Mirror();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> choice;   <span class="comment">//选择</span></span><br><span class="line">    String name;   <span class="comment">//使用化妆品的人</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Makeup</span><span class="params">(<span class="keyword">int</span> choice, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.choice = choice;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//化妆</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeup();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//化妆，互相持有对方的锁，就是需要拿到对方的资源</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeup</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lipstick)&#123;  <span class="comment">//获得口红的锁</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;获得口红的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (mirror)&#123;  <span class="comment">//一秒钟后想获得镜子的锁</span></span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;获得镜子的锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mirror)&#123;  <span class="comment">//获得镜子的锁</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;获得镜子的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lipstick) &#123;  <span class="comment">//两秒钟后想获得口红的锁</span></span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;获得口红的锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果： <img src="https://img-blog.csdnimg.cn/img_convert/0a23b78a3b21e80e7eae825d108f4c7f.png" /> 将程序修改一下，把同步代码块拿出来，两个人不抱着对方的锁就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (lipstick)&#123;  <span class="comment">//获得口红的锁</span></span><br><span class="line">          System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;获得口红的锁&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (mirror)&#123;  <span class="comment">//一秒钟后想获得镜子的锁</span></span><br><span class="line">          System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;获得镜子的锁&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mirror)&#123;  <span class="comment">//获得镜子的锁</span></span><br><span class="line">          System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;获得镜子的锁&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (lipstick) &#123;  <span class="comment">//两秒钟后想获得口红的锁</span></span><br><span class="line">          System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;获得口红的锁&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：正常结束。 <img src="https://img-blog.csdnimg.cn/img_convert/7073e65aa6691eaf2af7743c3c3c1b61.png" /></p>
<h3 id="死锁避免方法">2.死锁避免方法</h3>
<p>产生死锁的四个必要条件：</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在未使用完之前不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>只要破坏其中一个。就可以避免死锁。</p>
<h2 id="lock锁">8. Lock锁</h2>
<ul>
<li>从JDK 5.0开始，Java提供了更强大的线程同步机制—— 通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当</li>
<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象</li>
<li>ReentrantLock类（可重入锁 ）实现了Lock ，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock,可以显式加锁、释放锁。</li>
<li>语法：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b68e21752b69b500b0cbe0da27a30913.png" /> 举例，买票：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();  <span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span> (ticketNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;拿到了第&quot;</span> + ticketNums-- + <span class="string">&quot;票&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="synchronized与lock对比">synchronized与Lock对比</h5>
<ul>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁， 出了作用域自动释放</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
<li>优先使用顺序:</li>
</ul>
<p>Lock &gt;同步代码块(已经进入了方法体，分配了相应资源) &gt;同步方法(在方法体之外)</p>
<h2 id="线程通信生产者消费者模式">9. 线程通信—生产者消费者模式</h2>
<p>（1）应用场景:生产者和消费者问题 ◆ 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。 ◆ 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。 ◆ 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。 （2）分析： <strong>这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。</strong> ◆ 对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后又需要马上通知消费者消费。 ◆ 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。 ◆ 在生产者消费者问题中，仅有synchronized是不够的 ◆ synchronized可阻止并发更新同一个共享资源，实现了同步 ◆ synchronized不能用来实现不同线程之间的消息传递(通信) <img src="https://img-blog.csdnimg.cn/img_convert/806060b441322a9be7805a0f9e8ce42e.png" /> <strong>(3)解决方式：</strong> 并发协作模型“生产者/消费者模式”–&gt;</p>
<h6 id="a.管程法"><strong>a.管程法</strong></h6>
<p>◆生产者:负责生产数据的模块(可能是方法,对象,线程,进程); ◆消费者:负责处理数据的模块(可能是方法,对象,线程,进程); ◆缓冲区:消费者不能直接使用生产者的数据,他们之间有个“缓冲区“ <strong>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</strong> <img src="https://img-blog.csdnimg.cn/img_convert/d1d0b7d0a863d5ed76a1bf476a246d13.png" /> 分析代码，需要四个类：</p>
<ul>
<li>产品类，这里用鸡举例，每只鸡有编号id</li>
<li>生产者负责生产，也就是把鸡不断放入缓冲区</li>
<li>消费者负责消费，也就是从缓冲池不断取出鸡</li>
<li>缓冲区，定义容器大小和放入、取出的方法</li>
</ul>
<p>利用缓冲区容量来设定线程什么时候等待，什么时候唤醒，实现线程通信。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">extends</span>  <span class="title">Thread</span></span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            container.push(<span class="keyword">new</span> Chicken(i));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产了第&quot;</span>+i+<span class="string">&quot;只鸡&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费了----第&quot;</span>+container.pop().id+<span class="string">&quot;只鸡&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;  <span class="comment">//产品编号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chicken</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span></span>&#123;</span><br><span class="line">    <span class="comment">//需要一个容器大小</span></span><br><span class="line">    Chicken[] chickens = <span class="keyword">new</span> Chicken[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//容器计数器</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者放入产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Chicken chicken)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果容器满了，就需要等待消费者消费</span></span><br><span class="line">        <span class="keyword">if</span>(count == chickens.length)&#123;</span><br><span class="line">            <span class="comment">//通知消费者消费，生产等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有满，我们就需要丢入产品</span></span><br><span class="line">        chickens[count] = chicken;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以通知消费者消费了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者消费产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Chicken <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断能否消费</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//通等待生产者生产</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果可以消费。就取出产品</span></span><br><span class="line">        count--;</span><br><span class="line">       Chicken chicken = chickens[count];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以通知生产者消费了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> chicken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SynContainer container = <span class="keyword">new</span> SynContainer();</span><br><span class="line">        <span class="keyword">new</span> Productor(container).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(container).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> </strong>b.信号灯法，通过标志位** 利用判断标志位来设定线程什么时候等待，什么时候唤醒，实现线程通信。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者--演员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">&quot;快乐大本营&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">&quot;天天向上&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费者--观众</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Watcher</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            tv.watch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产品--节目</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span></span>&#123;</span><br><span class="line">    <span class="comment">//演员表演，观众等待  T</span></span><br><span class="line">    <span class="comment">//观众观看，演员等待  F</span></span><br><span class="line">    String voice;   <span class="comment">//表演节目</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表演</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String voice)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;演员表演了：&quot;</span>+voice);</span><br><span class="line">        <span class="comment">//通知观众观看</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();   <span class="comment">//通知唤醒</span></span><br><span class="line">        <span class="keyword">this</span>.voice = voice;</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;观看了：&quot;</span>+voice);</span><br><span class="line">        <span class="comment">//通知演员表演</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池">10. 线程池</h2>
<h3 id="使用线程池">使用线程池</h3>
<p>◆ 背景:经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 ◆ 思路:提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。 可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 ◆ 好处:</p>
<ul>
<li>提高响应速度(减少了创建新线程的时间)</li>
<li>降低资源消耗(重复利用线程池中线程，不需要每次都创建)</li>
<li>便于线程管理…</li>
</ul>
<p><code>corePoolSize</code> : 核心池的大小 <code>maximumPoolSize</code> :最大线程数 <code>keepAliveTime</code> : 线程没有任务时最多保持多长时间后会终止 ◆ JDK 5.0起提供了线程池相关API: <strong>ExecutorService</strong> 和<strong>Executors</strong> ◆ ExecutorService: 真正的线程池接口。常见子类ThreadPoolExecutor <code>void execute(Runnable command)</code> :执行任务/命令,没有返回值，一般用来执行Runnable <code>Future submit(Callable task)</code> :执行任务,有返回值，一般用来执行Callable <code>void shutdown()</code> :关闭连接池 ◆ Executors: 工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建服务，创建线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);  <span class="comment">//参数为线程池大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.关闭连接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果： <img src="https://img-blog.csdnimg.cn/img_convert/6c7b4c5a150de2552478e4a3a426c87c.png" /></p>
<h2 id="if-you-get-gainsplease-give-a-like">If you get gains，please give a like！</h2>

    </div>

    
    
    
	
	
      <div>
        
    <div style="text-align:center;color: #ccc;font-size:14px;">
        ------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div>
    
      </div>
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/15/%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%88%B0Github/" rel="prev" title="上传本地项目到Github">
                  <i class="fa fa-chevron-left"></i> 上传本地项目到Github
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/21/SpringBoot-MyBatis-MySQL%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86/" rel="next" title="SpringBoot-MyBatis-MySQL员工管理">
                  SpringBoot-MyBatis-MySQL员工管理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rui Wang</span>
</div>

<!---->

  <div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站总访客数:<span id="busuanzi_value_site_uv"></span>&nbsp;&nbsp;| 
  </span>
  <span id="busuanzi_container_site_pv">
      &nbsp;本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  </div>
  </div>
    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
